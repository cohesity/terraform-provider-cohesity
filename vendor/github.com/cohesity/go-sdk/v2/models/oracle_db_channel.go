// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OracleDbChannel Oracle Protection Group Database Node Channel
//
// Specifies the DB channel info for all the databases of app entity. Length of this array will be 1 for RAC and Standalone setups.
//
// swagger:model OracleDbChannel
type OracleDbChannel struct {

	// Specifies the number of days archive log should be stored. For keeping the archived log forever, set this to -1. For deleting the archived log immediately, set this to 0. For deleting the archived log after n days, set this to n.
	ArchiveLogRetentionDays *int32 `json:"archiveLogRetentionDays,omitempty"`

	// Specifies the number of hours archive log should be stored. For keeping the archived log forever, set this to -1. For deleting the archived log immediately, set this to 0. For deleting the archived log after k hours, set this to k.
	ArchiveLogRetentionHours *int32 `json:"archiveLogRetentionHours,omitempty"`

	// Specifies the Database credentials.
	Credentials *Credentials `json:"credentials,omitempty"`

	// Specifies the unique Name of the database.
	DatabaseUniqueName *string `json:"databaseUniqueName,omitempty"`

	// Specifies the database unique id. This is an internal field and is filled by magneto master based on corresponding app entity id.
	DatabaseUUID *string `json:"databaseUuid,omitempty"`

	// Specifies the default number of channels to use per node per database. This value is used on all Oracle Database Nodes unless databaseNodeList item's channelCount is specified for the node. Default value for the number of channels will be calculated as the minimum of number of nodes in Cohesity cluster and 2 * number of CPU on the host. If the number of channels is unspecified here and unspecified within databaseNodeList, the above formula will be used to determine the same.
	DefaultChannelCount *int32 `json:"defaultChannelCount,omitempty"`

	// Specifies the Node info from where we are allowed to take the backup/restore.
	DatabaseHosts []*OracleDatabaseHost `json:"databaseNodeList"`

	// Specifies the maximum number of hosts from which backup/restore is allowed in parallel. This will be less than or equal to the number of databaseNode specified within databaseNodeList.
	MaxHostCount *int32 `json:"maxHostCount,omitempty"`

	// Specifies whether the database having the Primary role within Data Guard configuration is to be backed up.
	EnableDgPrimaryBackup *bool `json:"enableDgPrimaryBackup,omitempty"`

	// Specifies the type of Oracle RMAN backup requested
	// Enum: ["kImageCopy","kBackupSets","kSbt"]
	RmanBackupType string `json:"rmanBackupType,omitempty"`
}

// Validate validates this oracle db channel
func (m *OracleDbChannel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatabaseHosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRmanBackupType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OracleDbChannel) validateCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.Credentials) { // not required
		return nil
	}

	if m.Credentials != nil {
		if err := m.Credentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *OracleDbChannel) validateDatabaseHosts(formats strfmt.Registry) error {
	if swag.IsZero(m.DatabaseHosts) { // not required
		return nil
	}

	for i := 0; i < len(m.DatabaseHosts); i++ {
		if swag.IsZero(m.DatabaseHosts[i]) { // not required
			continue
		}

		if m.DatabaseHosts[i] != nil {
			if err := m.DatabaseHosts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("databaseNodeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("databaseNodeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var oracleDbChannelTypeRmanBackupTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kImageCopy","kBackupSets","kSbt"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		oracleDbChannelTypeRmanBackupTypePropEnum = append(oracleDbChannelTypeRmanBackupTypePropEnum, v)
	}
}

const (

	// OracleDbChannelRmanBackupTypeKImageCopy captures enum value "kImageCopy"
	OracleDbChannelRmanBackupTypeKImageCopy string = "kImageCopy"

	// OracleDbChannelRmanBackupTypeKBackupSets captures enum value "kBackupSets"
	OracleDbChannelRmanBackupTypeKBackupSets string = "kBackupSets"

	// OracleDbChannelRmanBackupTypeKSbt captures enum value "kSbt"
	OracleDbChannelRmanBackupTypeKSbt string = "kSbt"
)

// prop value enum
func (m *OracleDbChannel) validateRmanBackupTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, oracleDbChannelTypeRmanBackupTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OracleDbChannel) validateRmanBackupType(formats strfmt.Registry) error {
	if swag.IsZero(m.RmanBackupType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRmanBackupTypeEnum("rmanBackupType", "body", m.RmanBackupType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this oracle db channel based on the context it is used
func (m *OracleDbChannel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatabaseHosts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OracleDbChannel) contextValidateCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.Credentials != nil {

		if swag.IsZero(m.Credentials) { // not required
			return nil
		}

		if err := m.Credentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *OracleDbChannel) contextValidateDatabaseHosts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DatabaseHosts); i++ {

		if m.DatabaseHosts[i] != nil {

			if swag.IsZero(m.DatabaseHosts[i]) { // not required
				return nil
			}

			if err := m.DatabaseHosts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("databaseNodeList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("databaseNodeList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OracleDbChannel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OracleDbChannel) UnmarshalBinary(b []byte) error {
	var res OracleDbChannel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
