// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataSourceConnector Data-Source Connector
//
// Specifies all the properties of the data-source connector. A connector is uniquely identified by a 'connectorId' for a given tenant. A connector resource is created internally by the system when a connector is registered with the cluster and thus, a POST API doesn't exist and isn't needed for creating a connector resource. An active connector is always associated with a data-source connection belonging to its tenant. A connector can never be associated with more than one connection/tenant/cluster at a given time. A connector also has a name which can be updated by the user. Names of connectors for a tenant or across tenants needn't be unique. Also, a connector constituent can optionally have two actively used NICs (dual-homed connectors).
//
// swagger:model DataSourceConnector
type DataSourceConnector struct {

	// Specifies the unique ID of the connector.
	// Required: true
	ConnectorID string `json:"connectorId"`

	// Specifies the name of the connector. The name of a connector need not be unique within a tenant or across tenants. The name of the connector can be updated as needed.
	ConnectorName *string `json:"connectorName,omitempty"`

	// Specifies the ID of the connection to which this connector belongs.
	// Required: true
	ConnectionID string `json:"connectionId"`

	// Specifies the IP of the connector's NIC facing the cluster.
	// Read Only: true
	ClusterSideIP *string `json:"clusterSideIp,omitempty"`

	// Specifies the IP of the connector's NIC facing the sources of the tenant to which the connector belongs.
	// Read Only: true
	TenantSideIP *string `json:"tenantSideIp,omitempty"`

	// Specifies the connector's software version.
	// Read Only: true
	SoftwareVersion *string `json:"softwareVersion,omitempty"`

	// Specifies connector's connectivity status information, for example if it's currently connected to the cluster, when it last connected to the cluster successfully, etc.
	// Read Only: true
	ConnectivityStatus *ConnectorConnectivityStatus `json:"connectivityStatus,omitempty"`

	// Specifies connector's upgrade status information, for example when the upgrade started, current status of the upgrade, errors for upgrade failure etc.
	// Read Only: true
	UpgradeStatus *ConnectorUpgradeStatus `json:"upgradeStatus,omitempty"`

	// Specifies connector's patch status information, for example when the patch started, current status of the patch, errors for patch failure etc.
	// Read Only: true
	PatchStatus *ConnectorPatchStatus `json:"patchStatus,omitempty"`
}

// Validate validates this data source connector
func (m *DataSourceConnector) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConnectorID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectivityStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpgradeStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatchStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataSourceConnector) validateConnectorID(formats strfmt.Registry) error {

	if err := validate.RequiredString("connectorId", "body", m.ConnectorID); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnector) validateConnectionID(formats strfmt.Registry) error {

	if err := validate.RequiredString("connectionId", "body", m.ConnectionID); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnector) validateConnectivityStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ConnectivityStatus) { // not required
		return nil
	}

	if m.ConnectivityStatus != nil {
		if err := m.ConnectivityStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connectivityStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connectivityStatus")
			}
			return err
		}
	}

	return nil
}

func (m *DataSourceConnector) validateUpgradeStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.UpgradeStatus) { // not required
		return nil
	}

	if m.UpgradeStatus != nil {
		if err := m.UpgradeStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("upgradeStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("upgradeStatus")
			}
			return err
		}
	}

	return nil
}

func (m *DataSourceConnector) validatePatchStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.PatchStatus) { // not required
		return nil
	}

	if m.PatchStatus != nil {
		if err := m.PatchStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchStatus")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this data source connector based on the context it is used
func (m *DataSourceConnector) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusterSideIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenantSideIP(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectivityStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpgradeStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePatchStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataSourceConnector) contextValidateClusterSideIP(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterSideIp", "body", m.ClusterSideIP); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnector) contextValidateTenantSideIP(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenantSideIp", "body", m.TenantSideIP); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnector) contextValidateSoftwareVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "softwareVersion", "body", m.SoftwareVersion); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnector) contextValidateConnectivityStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.ConnectivityStatus != nil {

		if swag.IsZero(m.ConnectivityStatus) { // not required
			return nil
		}

		if err := m.ConnectivityStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connectivityStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connectivityStatus")
			}
			return err
		}
	}

	return nil
}

func (m *DataSourceConnector) contextValidateUpgradeStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.UpgradeStatus != nil {

		if swag.IsZero(m.UpgradeStatus) { // not required
			return nil
		}

		if err := m.UpgradeStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("upgradeStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("upgradeStatus")
			}
			return err
		}
	}

	return nil
}

func (m *DataSourceConnector) contextValidatePatchStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.PatchStatus != nil {

		if swag.IsZero(m.PatchStatus) { // not required
			return nil
		}

		if err := m.PatchStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchStatus")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataSourceConnector) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataSourceConnector) UnmarshalBinary(b []byte) error {
	var res DataSourceConnector
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
