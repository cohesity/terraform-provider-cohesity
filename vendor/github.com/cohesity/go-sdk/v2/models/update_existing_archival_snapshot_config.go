// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateExistingArchivalSnapshotConfig Update Archival Snapshot Config.
//
// Specifies the configuration about updating an existing Archival Snapshot Run.
//
// swagger:model UpdateExistingArchivalSnapshotConfig
type UpdateExistingArchivalSnapshotConfig struct {

	// Specifies the id of the archival target.
	// Required: true
	ID *int64 `json:"id"`

	// Specifies the name of the archival target.
	Name *string `json:"name,omitempty"`

	// Specifies the snapshot's archival target type from which recovery has been performed.
	// Required: true
	// Enum: ["Tape","Cloud","Nas"]
	ArchivalTargetType *string `json:"archivalTargetType"`

	// Specifies whether to retain the snapshot for legal purpose. If set to true, the snapshots cannot be deleted until the retention period. Note that using this option may cause the Cluster to run out of space. If set to false explicitly, the hold is removed, and the snapshots will expire as specified in the policy of the Protection Group. If this field is not specified, there is no change to the hold of the run. This field can be set only by a User having Data Security Role.
	EnableLegalHold *bool `json:"enableLegalHold,omitempty"`

	// Specifies whether to delete the snapshot. When this is set to true, all other params will be ignored.
	DeleteSnapshot *bool `json:"deleteSnapshot,omitempty"`

	// Specifies whether to retry the archival operation in case if earlier attempt failed. If not specified or set to false, archival is not retried.
	Resync *bool `json:"resync,omitempty"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time, the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason. <br>'Administrative' implies WORM retention is set for administrative purposes.
	// Enum: ["Compliance","Administrative"]
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies number of days to retain the snapshots. If positive, then this value is added to exisiting expiry time thereby increasing  the retention period of the snapshot. Conversly, if this value is negative, then value is subtracted to existing expiry time thereby decreasing the retention period of the snaphot. Here, by this operation if expiry time goes below current time then snapshot is immediately deleted.
	DaysToKeep *int64 `json:"daysToKeep,omitempty"`
}

// Validate validates this update existing archival snapshot config
func (m *UpdateExistingArchivalSnapshotConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchivalTargetType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLock(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateExistingArchivalSnapshotConfig) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

var updateExistingArchivalSnapshotConfigTypeArchivalTargetTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Tape","Cloud","Nas"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateExistingArchivalSnapshotConfigTypeArchivalTargetTypePropEnum = append(updateExistingArchivalSnapshotConfigTypeArchivalTargetTypePropEnum, v)
	}
}

const (

	// UpdateExistingArchivalSnapshotConfigArchivalTargetTypeTape captures enum value "Tape"
	UpdateExistingArchivalSnapshotConfigArchivalTargetTypeTape string = "Tape"

	// UpdateExistingArchivalSnapshotConfigArchivalTargetTypeCloud captures enum value "Cloud"
	UpdateExistingArchivalSnapshotConfigArchivalTargetTypeCloud string = "Cloud"

	// UpdateExistingArchivalSnapshotConfigArchivalTargetTypeNas captures enum value "Nas"
	UpdateExistingArchivalSnapshotConfigArchivalTargetTypeNas string = "Nas"
)

// prop value enum
func (m *UpdateExistingArchivalSnapshotConfig) validateArchivalTargetTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateExistingArchivalSnapshotConfigTypeArchivalTargetTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateExistingArchivalSnapshotConfig) validateArchivalTargetType(formats strfmt.Registry) error {

	if err := validate.Required("archivalTargetType", "body", m.ArchivalTargetType); err != nil {
		return err
	}

	// value enum
	if err := m.validateArchivalTargetTypeEnum("archivalTargetType", "body", *m.ArchivalTargetType); err != nil {
		return err
	}

	return nil
}

var updateExistingArchivalSnapshotConfigTypeDataLockPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Compliance","Administrative"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateExistingArchivalSnapshotConfigTypeDataLockPropEnum = append(updateExistingArchivalSnapshotConfigTypeDataLockPropEnum, v)
	}
}

const (

	// UpdateExistingArchivalSnapshotConfigDataLockCompliance captures enum value "Compliance"
	UpdateExistingArchivalSnapshotConfigDataLockCompliance string = "Compliance"

	// UpdateExistingArchivalSnapshotConfigDataLockAdministrative captures enum value "Administrative"
	UpdateExistingArchivalSnapshotConfigDataLockAdministrative string = "Administrative"
)

// prop value enum
func (m *UpdateExistingArchivalSnapshotConfig) validateDataLockEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateExistingArchivalSnapshotConfigTypeDataLockPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateExistingArchivalSnapshotConfig) validateDataLock(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLock) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataLockEnum("dataLock", "body", *m.DataLock); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this update existing archival snapshot config based on context it is used
func (m *UpdateExistingArchivalSnapshotConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *UpdateExistingArchivalSnapshotConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateExistingArchivalSnapshotConfig) UnmarshalBinary(b []byte) error {
	var res UpdateExistingArchivalSnapshotConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
