// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FailoverRunConfiguration Specifies the configuration required for execting special run as a part of failover workflow. This special run is triggered during palnned failover to sync the source cluster to replication cluster with minimum possible delta. Please note that if this object is passed then this special run will ignore the other archivals and retention settings.
//
// swagger:model FailoverRunConfiguration
type FailoverRunConfiguration struct {

	// Specifies the replication cluster Id where planned run will replicate objects.
	// Required: true
	ReplicationClusterID *int64 `json:"replicationClusterId"`

	// Specifies the list of all local entity ids of all the objects being failed from the source cluster.
	// Required: true
	Objects []*FailoverObject `json:"objects"`

	// Specifies the active protection group id on the source cluster from where the objects are being failed over.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Specifies the type of the backup run to be triggered by this request. If this is not set defaults to incremental backup.
	// Enum: ["kAll","kHydrateCDP","kSystem","kStorageArraySnapshot","kIncremental","kFull","kLog"]
	RunType string `json:"runType,omitempty"`

	// If failover is initiated by view based orchastrator, then this field specifies the local view id of source cluster which is being failed over.
	ViewID *int64 `json:"viewId,omitempty"`

	// If set to true, other ongoing runs backing up the same set of entities being failed over will be initiated for cancellation. Non conflicting run operations such as replications to other clusters, archivals will not be cancelled. If set to false, then new run will wait for all the pending operations to finish normally before scheduling a new backup/replication.
	CancelNonFailoverRuns *bool `json:"cancelNonFailoverRuns,omitempty"`

	// If this is set to true then unless failover operation is completed, all the next runs will be pasued.
	PauseNextRuns *bool `json:"pauseNextRuns,omitempty"`
}

// Validate validates this failover run configuration
func (m *FailoverRunConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateReplicationClusterID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjects(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FailoverRunConfiguration) validateReplicationClusterID(formats strfmt.Registry) error {

	if err := validate.Required("replicationClusterId", "body", m.ReplicationClusterID); err != nil {
		return err
	}

	return nil
}

func (m *FailoverRunConfiguration) validateObjects(formats strfmt.Registry) error {

	if err := validate.Required("objects", "body", m.Objects); err != nil {
		return err
	}

	for i := 0; i < len(m.Objects); i++ {
		if swag.IsZero(m.Objects[i]) { // not required
			continue
		}

		if m.Objects[i] != nil {
			if err := m.Objects[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var failoverRunConfigurationTypeRunTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAll","kHydrateCDP","kSystem","kStorageArraySnapshot","kIncremental","kFull","kLog"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		failoverRunConfigurationTypeRunTypePropEnum = append(failoverRunConfigurationTypeRunTypePropEnum, v)
	}
}

const (

	// FailoverRunConfigurationRunTypeKAll captures enum value "kAll"
	FailoverRunConfigurationRunTypeKAll string = "kAll"

	// FailoverRunConfigurationRunTypeKHydrateCDP captures enum value "kHydrateCDP"
	FailoverRunConfigurationRunTypeKHydrateCDP string = "kHydrateCDP"

	// FailoverRunConfigurationRunTypeKSystem captures enum value "kSystem"
	FailoverRunConfigurationRunTypeKSystem string = "kSystem"

	// FailoverRunConfigurationRunTypeKStorageArraySnapshot captures enum value "kStorageArraySnapshot"
	FailoverRunConfigurationRunTypeKStorageArraySnapshot string = "kStorageArraySnapshot"

	// FailoverRunConfigurationRunTypeKIncremental captures enum value "kIncremental"
	FailoverRunConfigurationRunTypeKIncremental string = "kIncremental"

	// FailoverRunConfigurationRunTypeKFull captures enum value "kFull"
	FailoverRunConfigurationRunTypeKFull string = "kFull"

	// FailoverRunConfigurationRunTypeKLog captures enum value "kLog"
	FailoverRunConfigurationRunTypeKLog string = "kLog"
)

// prop value enum
func (m *FailoverRunConfiguration) validateRunTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, failoverRunConfigurationTypeRunTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FailoverRunConfiguration) validateRunType(formats strfmt.Registry) error {
	if swag.IsZero(m.RunType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRunTypeEnum("runType", "body", m.RunType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this failover run configuration based on the context it is used
func (m *FailoverRunConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateObjects(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FailoverRunConfiguration) contextValidateObjects(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Objects); i++ {

		if m.Objects[i] != nil {

			if swag.IsZero(m.Objects[i]) { // not required
				return nil
			}

			if err := m.Objects[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FailoverRunConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FailoverRunConfiguration) UnmarshalBinary(b []byte) error {
	var res FailoverRunConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
