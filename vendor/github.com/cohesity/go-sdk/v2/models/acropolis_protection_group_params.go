// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AcropolisProtectionGroupParams Specifies the parameters which are related to Acropolis Protection Groups.
//
// swagger:model AcropolisProtectionGroupParams
type AcropolisProtectionGroupParams struct {

	// Specifies the objects included in the Protection Group.
	// Required: true
	// Min Items: 1
	// Unique: true
	Objects []*AcropolisProtectionGroupObjectParams `json:"objects"`

	// Specifies the id of the parent of the objects.
	// Read Only: true
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies the name of the parent of the objects.
	// Read Only: true
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the object ids to be excluded in the Protection Group.
	// Unique: true
	ExcludeObjectIds []int64 `json:"excludeObjectIds"`

	// Specifies settings for indexing files found in an Object (such as a VM) so these files can be searched and recovered. This also specifies inclusion and exclusion rules that determine the directories to index.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies whether or not to quiesce apps and the file system in order to take app consistent snapshots. If not specified or false then snapshots will not be app consistent.
	AppConsistentSnapshot *bool `json:"appConsistentSnapshot,omitempty"`

	// Specifies whether to continue backing up on quiesce failure
	ContinueOnQuiesceFailure *bool `json:"continueOnQuiesceFailure,omitempty"`

	// Specifies a list of disks to exclude from the backup.
	GlobalExcludeDisks []*AcropolisDiskInfo `json:"globalExcludeDisks"`

	// Specifies a list of disks to include in the backup.
	GlobalIncludeDisks []*AcropolisDiskInfo `json:"globalIncludeDisks"`
}

// Validate validates this acropolis protection group params
func (m *AcropolisProtectionGroupParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateObjects(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeObjectIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalExcludeDisks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalIncludeDisks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AcropolisProtectionGroupParams) validateObjects(formats strfmt.Registry) error {

	if err := validate.Required("objects", "body", m.Objects); err != nil {
		return err
	}

	iObjectsSize := int64(len(m.Objects))

	if err := validate.MinItems("objects", "body", iObjectsSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("objects", "body", m.Objects); err != nil {
		return err
	}

	for i := 0; i < len(m.Objects); i++ {
		if swag.IsZero(m.Objects[i]) { // not required
			continue
		}

		if m.Objects[i] != nil {
			if err := m.Objects[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AcropolisProtectionGroupParams) validateExcludeObjectIds(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeObjectIds) { // not required
		return nil
	}

	if err := validate.UniqueItems("excludeObjectIds", "body", m.ExcludeObjectIds); err != nil {
		return err
	}

	return nil
}

func (m *AcropolisProtectionGroupParams) validateIndexingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IndexingPolicy) { // not required
		return nil
	}

	if m.IndexingPolicy != nil {
		if err := m.IndexingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *AcropolisProtectionGroupParams) validateGlobalExcludeDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.GlobalExcludeDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.GlobalExcludeDisks); i++ {
		if swag.IsZero(m.GlobalExcludeDisks[i]) { // not required
			continue
		}

		if m.GlobalExcludeDisks[i] != nil {
			if err := m.GlobalExcludeDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AcropolisProtectionGroupParams) validateGlobalIncludeDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.GlobalIncludeDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.GlobalIncludeDisks); i++ {
		if swag.IsZero(m.GlobalIncludeDisks[i]) { // not required
			continue
		}

		if m.GlobalIncludeDisks[i] != nil {
			if err := m.GlobalIncludeDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this acropolis protection group params based on the context it is used
func (m *AcropolisProtectionGroupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateObjects(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIndexingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlobalExcludeDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlobalIncludeDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AcropolisProtectionGroupParams) contextValidateObjects(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Objects); i++ {

		if m.Objects[i] != nil {

			if swag.IsZero(m.Objects[i]) { // not required
				return nil
			}

			if err := m.Objects[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AcropolisProtectionGroupParams) contextValidateSourceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceId", "body", m.SourceID); err != nil {
		return err
	}

	return nil
}

func (m *AcropolisProtectionGroupParams) contextValidateSourceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceName", "body", m.SourceName); err != nil {
		return err
	}

	return nil
}

func (m *AcropolisProtectionGroupParams) contextValidateIndexingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.IndexingPolicy != nil {

		if swag.IsZero(m.IndexingPolicy) { // not required
			return nil
		}

		if err := m.IndexingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *AcropolisProtectionGroupParams) contextValidateGlobalExcludeDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GlobalExcludeDisks); i++ {

		if m.GlobalExcludeDisks[i] != nil {

			if swag.IsZero(m.GlobalExcludeDisks[i]) { // not required
				return nil
			}

			if err := m.GlobalExcludeDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AcropolisProtectionGroupParams) contextValidateGlobalIncludeDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GlobalIncludeDisks); i++ {

		if m.GlobalIncludeDisks[i] != nil {

			if swag.IsZero(m.GlobalIncludeDisks[i]) { // not required
				return nil
			}

			if err := m.GlobalIncludeDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AcropolisProtectionGroupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AcropolisProtectionGroupParams) UnmarshalBinary(b []byte) error {
	var res AcropolisProtectionGroupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
