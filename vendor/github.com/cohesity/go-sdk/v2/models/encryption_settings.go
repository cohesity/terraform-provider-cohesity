// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EncryptionSettings Specifis the encryption setting of the External Target
//
// swagger:model EncryptionSettings
type EncryptionSettings struct {

	// Specifies the type of encryption for the Setting.
	// Required: true
	// Enum: ["None","Weak","Strong"]
	EncryptionLevel *string `json:"encryptionLevel"`

	// Specifies the Key Management Service Server ID for the Encryption Setting.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// Enable Additional security by managing key manually
	EnableAdditionalSecurity *bool `json:"enableAdditionalSecurity,omitempty"`

	// Specifies the time (in microseconds) when the encryption key file was downloaded from the Cohesity Dashboard (Cohesity UI). An encryption key can only be downloaded once using Cohesity Dashboard. Can be set only once when the key is downloaded.
	// Read Only: true
	KeyFileDownloadTimeUsecs *int64 `json:"keyFileDownloadTimeUsecs,omitempty"`

	// Specifies the user who downloaded the encryption key from the Cohesity Dashboard (Cohesity UI). This field is only populated if encryption is enabled for the Vault and customerManagingEncryptionKeys is true. Can be set only once when the key is downloaded.
	// Read Only: true
	KeyFileDownloadUser *string `json:"keyFileDownloadUser,omitempty"`

	// Specifies if the encryption key file has been downloaded using the Cohesity Dashboard (Cohesity UI). If true, the encryption key has been downloaded using the Cohesity Dashboard. An encryption key can only be downloaded once using the Cohesity Dashboard. After setting it to true once, subsequent updates to this field will be ignored.
	EncryptionKeyFileDownloaded *bool `json:"encryptionKeyFileDownloaded,omitempty"`
}

// Validate validates this encryption settings
func (m *EncryptionSettings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEncryptionLevel(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var encryptionSettingsTypeEncryptionLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Weak","Strong"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		encryptionSettingsTypeEncryptionLevelPropEnum = append(encryptionSettingsTypeEncryptionLevelPropEnum, v)
	}
}

const (

	// EncryptionSettingsEncryptionLevelNone captures enum value "None"
	EncryptionSettingsEncryptionLevelNone string = "None"

	// EncryptionSettingsEncryptionLevelWeak captures enum value "Weak"
	EncryptionSettingsEncryptionLevelWeak string = "Weak"

	// EncryptionSettingsEncryptionLevelStrong captures enum value "Strong"
	EncryptionSettingsEncryptionLevelStrong string = "Strong"
)

// prop value enum
func (m *EncryptionSettings) validateEncryptionLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, encryptionSettingsTypeEncryptionLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *EncryptionSettings) validateEncryptionLevel(formats strfmt.Registry) error {

	if err := validate.Required("encryptionLevel", "body", m.EncryptionLevel); err != nil {
		return err
	}

	// value enum
	if err := m.validateEncryptionLevelEnum("encryptionLevel", "body", *m.EncryptionLevel); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this encryption settings based on the context it is used
func (m *EncryptionSettings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateKeyFileDownloadTimeUsecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyFileDownloadUser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EncryptionSettings) contextValidateKeyFileDownloadTimeUsecs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "keyFileDownloadTimeUsecs", "body", m.KeyFileDownloadTimeUsecs); err != nil {
		return err
	}

	return nil
}

func (m *EncryptionSettings) contextValidateKeyFileDownloadUser(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "keyFileDownloadUser", "body", m.KeyFileDownloadUser); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EncryptionSettings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EncryptionSettings) UnmarshalBinary(b []byte) error {
	var res EncryptionSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
