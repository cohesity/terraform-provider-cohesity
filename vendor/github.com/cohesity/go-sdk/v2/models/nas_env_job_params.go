// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NasEnvJobParams Specifies additional special parameters that are applicable only to Types of 'kGenericNas' type.
//
// swagger:model NasEnvJobParams
type NasEnvJobParams struct {
	CommonTieringPolicy

	FileUptieringParams

	FileStubbingParams

	// Specifies the preferred protocol to use if this device supports multiple protocols.
	// Enum: ["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]
	NasProtocol *string `json:"nasProtocol,omitempty"`

	// Specifies the preference of NFS version to be backed up if a volume supports multiple versions of NFS.
	// Enum: ["kNfs3","kNfs4_1"]
	NfsVersionPreference *string `json:"nfsVersionPreference,omitempty"`

	// Specifies whether or not the Protection Group should continue regardless of whether or not an error was encountered during protection group run.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Specifies whether the protection group should use encryption while backup or not.
	EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

	// Optional config that enables file locking for this view. It cannot be disabled during the edit of a view, if it has been enabled during the creation of the view. Also, it cannot be enabled if it was disabled during the creation of the view.
	FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

	// Specifies the incremental and full snapshot label for Data-Protect Netapp Volumes backup. If snapMirrorConfig is provided then snapshotLabel should not be provided.
	SnapshotLabel *SnapshotLabel `json:"snapshotLabel,omitempty"`

	// Specifies that snapshot label is not set for Data-Protect Netapp Volumes backup. If field is set to true, existing oldest snapshot is used for backup and subsequent incremental will be selected in ascending order of snapshot create time on the source. If snapshot label is set, this field is set to false.
	BackupExistingSnapshot *bool `json:"backupExistingSnapshot,omitempty"`

	// Specifies the list of IP addresses that are allowed or denied at the job level. Allowed IPs and Denied IPs cannot be used together.
	FilterIPConfig *FilterIPConfig `json:"filterIpConfig,omitempty"`

	// Specifies filters on the backup objects like files and directories. Specifying filters decide which objects within a source should be backed up. If this field is not specified, then all of the objects within the source will be backed up.
	FilePathFilters *FileFilteringPolicy `json:"filePathFilters,omitempty"`

	// Specifies the source throttling parameters to be used during full or incremental backup of the NAS source.
	ThrottlingConfig *NasThrottlingConfig `json:"throttlingConfig,omitempty"`

	// Specify whether to use the Isilon Changelist API to directly discover changed files/directories for faster incremental backup. Cohesity will keep an extra snapshot which will be deleted by the next successful backup.
	UseChangelist *bool `json:"useChangelist,omitempty"`

	// Specifies whether this job will enable faster incremental backups using change list or similar APIs
	EnableFasterIncrementalBackups *bool `json:"enableFasterIncrementalBackups,omitempty"`

	// Specifies if the NAS source permissions should be modified internally to allow backups.
	ModifySourcePermissions *bool `json:"modifySourcePermissions,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *NasEnvJobParams) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 CommonTieringPolicy
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.CommonTieringPolicy = aO0

	// AO1
	var aO1 FileUptieringParams
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.FileUptieringParams = aO1

	// AO2
	var aO2 FileStubbingParams
	if err := swag.ReadJSON(raw, &aO2); err != nil {
		return err
	}
	m.FileStubbingParams = aO2

	// AO3
	var dataAO3 struct {
		NasProtocol *string `json:"nasProtocol,omitempty"`

		NfsVersionPreference *string `json:"nfsVersionPreference,omitempty"`

		ContinueOnError *bool `json:"continueOnError,omitempty"`

		EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

		FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

		SnapshotLabel *SnapshotLabel `json:"snapshotLabel,omitempty"`

		BackupExistingSnapshot *bool `json:"backupExistingSnapshot,omitempty"`

		FilterIPConfig *FilterIPConfig `json:"filterIpConfig,omitempty"`

		FilePathFilters *FileFilteringPolicy `json:"filePathFilters,omitempty"`

		ThrottlingConfig *NasThrottlingConfig `json:"throttlingConfig,omitempty"`

		UseChangelist *bool `json:"useChangelist,omitempty"`

		EnableFasterIncrementalBackups *bool `json:"enableFasterIncrementalBackups,omitempty"`

		ModifySourcePermissions *bool `json:"modifySourcePermissions,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO3); err != nil {
		return err
	}

	m.NasProtocol = dataAO3.NasProtocol

	m.NfsVersionPreference = dataAO3.NfsVersionPreference

	m.ContinueOnError = dataAO3.ContinueOnError

	m.EncryptionEnabled = dataAO3.EncryptionEnabled

	m.FileLockConfig = dataAO3.FileLockConfig

	m.SnapshotLabel = dataAO3.SnapshotLabel

	m.BackupExistingSnapshot = dataAO3.BackupExistingSnapshot

	m.FilterIPConfig = dataAO3.FilterIPConfig

	m.FilePathFilters = dataAO3.FilePathFilters

	m.ThrottlingConfig = dataAO3.ThrottlingConfig

	m.UseChangelist = dataAO3.UseChangelist

	m.EnableFasterIncrementalBackups = dataAO3.EnableFasterIncrementalBackups

	m.ModifySourcePermissions = dataAO3.ModifySourcePermissions

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m NasEnvJobParams) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 4)

	aO0, err := swag.WriteJSON(m.CommonTieringPolicy)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	aO1, err := swag.WriteJSON(m.FileUptieringParams)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)

	aO2, err := swag.WriteJSON(m.FileStubbingParams)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO2)
	var dataAO3 struct {
		NasProtocol *string `json:"nasProtocol,omitempty"`

		NfsVersionPreference *string `json:"nfsVersionPreference,omitempty"`

		ContinueOnError *bool `json:"continueOnError,omitempty"`

		EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

		FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

		SnapshotLabel *SnapshotLabel `json:"snapshotLabel,omitempty"`

		BackupExistingSnapshot *bool `json:"backupExistingSnapshot,omitempty"`

		FilterIPConfig *FilterIPConfig `json:"filterIpConfig,omitempty"`

		FilePathFilters *FileFilteringPolicy `json:"filePathFilters,omitempty"`

		ThrottlingConfig *NasThrottlingConfig `json:"throttlingConfig,omitempty"`

		UseChangelist *bool `json:"useChangelist,omitempty"`

		EnableFasterIncrementalBackups *bool `json:"enableFasterIncrementalBackups,omitempty"`

		ModifySourcePermissions *bool `json:"modifySourcePermissions,omitempty"`
	}

	dataAO3.NasProtocol = m.NasProtocol

	dataAO3.NfsVersionPreference = m.NfsVersionPreference

	dataAO3.ContinueOnError = m.ContinueOnError

	dataAO3.EncryptionEnabled = m.EncryptionEnabled

	dataAO3.FileLockConfig = m.FileLockConfig

	dataAO3.SnapshotLabel = m.SnapshotLabel

	dataAO3.BackupExistingSnapshot = m.BackupExistingSnapshot

	dataAO3.FilterIPConfig = m.FilterIPConfig

	dataAO3.FilePathFilters = m.FilePathFilters

	dataAO3.ThrottlingConfig = m.ThrottlingConfig

	dataAO3.UseChangelist = m.UseChangelist

	dataAO3.EnableFasterIncrementalBackups = m.EnableFasterIncrementalBackups

	dataAO3.ModifySourcePermissions = m.ModifySourcePermissions

	jsonDataAO3, errAO3 := swag.WriteJSON(dataAO3)
	if errAO3 != nil {
		return nil, errAO3
	}
	_parts = append(_parts, jsonDataAO3)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this nas env job params
func (m *NasEnvJobParams) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with CommonTieringPolicy
	if err := m.CommonTieringPolicy.Validate(formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with FileUptieringParams
	if err := m.FileUptieringParams.Validate(formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with FileStubbingParams
	if err := m.FileStubbingParams.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNasProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsVersionPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileLockConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilterIPConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilePathFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThrottlingConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nasEnvJobParamsTypeNasProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasEnvJobParamsTypeNasProtocolPropEnum = append(nasEnvJobParamsTypeNasProtocolPropEnum, v)
	}
}

// property enum
func (m *NasEnvJobParams) validateNasProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasEnvJobParamsTypeNasProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasEnvJobParams) validateNasProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.NasProtocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateNasProtocolEnum("nasProtocol", "body", *m.NasProtocol); err != nil {
		return err
	}

	return nil
}

var nasEnvJobParamsTypeNfsVersionPreferencePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNfs3","kNfs4_1"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasEnvJobParamsTypeNfsVersionPreferencePropEnum = append(nasEnvJobParamsTypeNfsVersionPreferencePropEnum, v)
	}
}

// property enum
func (m *NasEnvJobParams) validateNfsVersionPreferenceEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasEnvJobParamsTypeNfsVersionPreferencePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasEnvJobParams) validateNfsVersionPreference(formats strfmt.Registry) error {

	if swag.IsZero(m.NfsVersionPreference) { // not required
		return nil
	}

	// value enum
	if err := m.validateNfsVersionPreferenceEnum("nfsVersionPreference", "body", *m.NfsVersionPreference); err != nil {
		return err
	}

	return nil
}

func (m *NasEnvJobParams) validateFileLockConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.FileLockConfig) { // not required
		return nil
	}

	if m.FileLockConfig != nil {
		if err := m.FileLockConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) validateSnapshotLabel(formats strfmt.Registry) error {

	if swag.IsZero(m.SnapshotLabel) { // not required
		return nil
	}

	if m.SnapshotLabel != nil {
		if err := m.SnapshotLabel.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotLabel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotLabel")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) validateFilterIPConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.FilterIPConfig) { // not required
		return nil
	}

	if m.FilterIPConfig != nil {
		if err := m.FilterIPConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) validateFilePathFilters(formats strfmt.Registry) error {

	if swag.IsZero(m.FilePathFilters) { // not required
		return nil
	}

	if m.FilePathFilters != nil {
		if err := m.FilePathFilters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filePathFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filePathFilters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) validateThrottlingConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.ThrottlingConfig) { // not required
		return nil
	}

	if m.ThrottlingConfig != nil {
		if err := m.ThrottlingConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas env job params based on the context it is used
func (m *NasEnvJobParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with CommonTieringPolicy
	if err := m.CommonTieringPolicy.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with FileUptieringParams
	if err := m.FileUptieringParams.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}
	// validation for a type composition with FileStubbingParams
	if err := m.FileStubbingParams.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileLockConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilterIPConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilePathFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThrottlingConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasEnvJobParams) contextValidateFileLockConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FileLockConfig != nil {

		if swag.IsZero(m.FileLockConfig) { // not required
			return nil
		}

		if err := m.FileLockConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) contextValidateSnapshotLabel(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotLabel != nil {

		if swag.IsZero(m.SnapshotLabel) { // not required
			return nil
		}

		if err := m.SnapshotLabel.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotLabel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotLabel")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) contextValidateFilterIPConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FilterIPConfig != nil {

		if swag.IsZero(m.FilterIPConfig) { // not required
			return nil
		}

		if err := m.FilterIPConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) contextValidateFilePathFilters(ctx context.Context, formats strfmt.Registry) error {

	if m.FilePathFilters != nil {

		if swag.IsZero(m.FilePathFilters) { // not required
			return nil
		}

		if err := m.FilePathFilters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filePathFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filePathFilters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParams) contextValidateThrottlingConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ThrottlingConfig != nil {

		if swag.IsZero(m.ThrottlingConfig) { // not required
			return nil
		}

		if err := m.ThrottlingConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasEnvJobParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasEnvJobParams) UnmarshalBinary(b []byte) error {
	var res NasEnvJobParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
