// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BackupRunSummary Summary information for local snapshot run.
//
// Specifies summary information about local snapshot run across all objects.
//
// swagger:model BackupRunSummary
type BackupRunSummary struct {

	// Type of Protection Group run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT (if supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture the database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume backup. It produces an image for bare metal recovery. 'kStorageArraySnapshot' indicates storage array snapshot backup.
	// Enum: ["kRegular","kFull","kLog","kSystem","kHydrateCDP","kStorageArraySnapshot"]
	RunType *string `json:"runType,omitempty"`

	// Indicated if SLA has been violated for this run.
	IsSLAViolated *bool `json:"isSlaViolated,omitempty"`

	// Specifies the start time of backup run in Unix epoch Timestamp(in microseconds).
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of backup run in Unix epoch Timestamp(in microseconds).
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Status of the backup run. 'Running' indicates that the run is still running. 'Canceled' indicates that the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates that the ongoing run has been paused. 'Failed' indicates that the run has failed. 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening. 'Succeeded' indicates that the run has finished successfully. 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages. 'Skipped' indicates that the run was skipped.
	// Enum: ["Accepted","Running","Canceled","Canceling","Failed","Missed","Succeeded","SucceededWithWarning","OnHold","Finalizing","Skipped","LegalHold","Paused"]
	Status *string `json:"status,omitempty"`

	// Message about the backup run.
	Messages []string `json:"messages"`

	// Specifies the count of objects for which backup was successful.
	SuccessfulObjectsCount *int64 `json:"successfulObjectsCount,omitempty"`

	// Specifies the count of objects for which backup failed.
	FailedObjectsCount *int64 `json:"failedObjectsCount,omitempty"`

	// Specifies the count of objects for which backup was cancelled.
	CancelledObjectsCount *int64 `json:"cancelledObjectsCount,omitempty"`

	// Specifies the count of objects for which backup was skipped.
	SkippedObjectsCount *int64 `json:"skippedObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup was successful.
	SuccessfulAppObjectsCount *int32 `json:"successfulAppObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup failed.
	FailedAppObjectsCount *int32 `json:"failedAppObjectsCount,omitempty"`

	// Specifies the count of app objects for which backup was cancelled.
	CancelledAppObjectsCount *int32 `json:"cancelledAppObjectsCount,omitempty"`

	// Statistics about local snapshot (across all objects).
	LocalSnapshotStats *BackupDataStats `json:"localSnapshotStats,omitempty"`

	// Progress monitor task for indexing.
	IndexingTaskID *string `json:"indexingTaskId,omitempty"`

	// Progress monitor task id for local backup run.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Stats task id for local backup run.
	StatsTaskID *string `json:"statsTaskId,omitempty"`

	// This field is deprecated. Use DataLockConstraints field instead.
	// Enum: ["Compliance","Administrative"]
	DataLock *string `json:"dataLock,omitempty"`

	// Task ID for a local protection run.
	LocalTaskID *string `json:"localTaskId,omitempty"`

	// Specifies the dataLock constraints for the archival target.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`
}

// Validate validates this backup run summary
func (m *BackupRunSummary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRunType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalSnapshotStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLockConstraints(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var backupRunSummaryTypeRunTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kRegular","kFull","kLog","kSystem","kHydrateCDP","kStorageArraySnapshot"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupRunSummaryTypeRunTypePropEnum = append(backupRunSummaryTypeRunTypePropEnum, v)
	}
}

const (

	// BackupRunSummaryRunTypeKRegular captures enum value "kRegular"
	BackupRunSummaryRunTypeKRegular string = "kRegular"

	// BackupRunSummaryRunTypeKFull captures enum value "kFull"
	BackupRunSummaryRunTypeKFull string = "kFull"

	// BackupRunSummaryRunTypeKLog captures enum value "kLog"
	BackupRunSummaryRunTypeKLog string = "kLog"

	// BackupRunSummaryRunTypeKSystem captures enum value "kSystem"
	BackupRunSummaryRunTypeKSystem string = "kSystem"

	// BackupRunSummaryRunTypeKHydrateCDP captures enum value "kHydrateCDP"
	BackupRunSummaryRunTypeKHydrateCDP string = "kHydrateCDP"

	// BackupRunSummaryRunTypeKStorageArraySnapshot captures enum value "kStorageArraySnapshot"
	BackupRunSummaryRunTypeKStorageArraySnapshot string = "kStorageArraySnapshot"
)

// prop value enum
func (m *BackupRunSummary) validateRunTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupRunSummaryTypeRunTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupRunSummary) validateRunType(formats strfmt.Registry) error {
	if swag.IsZero(m.RunType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRunTypeEnum("runType", "body", *m.RunType); err != nil {
		return err
	}

	return nil
}

var backupRunSummaryTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Accepted","Running","Canceled","Canceling","Failed","Missed","Succeeded","SucceededWithWarning","OnHold","Finalizing","Skipped","LegalHold","Paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupRunSummaryTypeStatusPropEnum = append(backupRunSummaryTypeStatusPropEnum, v)
	}
}

const (

	// BackupRunSummaryStatusAccepted captures enum value "Accepted"
	BackupRunSummaryStatusAccepted string = "Accepted"

	// BackupRunSummaryStatusRunning captures enum value "Running"
	BackupRunSummaryStatusRunning string = "Running"

	// BackupRunSummaryStatusCanceled captures enum value "Canceled"
	BackupRunSummaryStatusCanceled string = "Canceled"

	// BackupRunSummaryStatusCanceling captures enum value "Canceling"
	BackupRunSummaryStatusCanceling string = "Canceling"

	// BackupRunSummaryStatusFailed captures enum value "Failed"
	BackupRunSummaryStatusFailed string = "Failed"

	// BackupRunSummaryStatusMissed captures enum value "Missed"
	BackupRunSummaryStatusMissed string = "Missed"

	// BackupRunSummaryStatusSucceeded captures enum value "Succeeded"
	BackupRunSummaryStatusSucceeded string = "Succeeded"

	// BackupRunSummaryStatusSucceededWithWarning captures enum value "SucceededWithWarning"
	BackupRunSummaryStatusSucceededWithWarning string = "SucceededWithWarning"

	// BackupRunSummaryStatusOnHold captures enum value "OnHold"
	BackupRunSummaryStatusOnHold string = "OnHold"

	// BackupRunSummaryStatusFinalizing captures enum value "Finalizing"
	BackupRunSummaryStatusFinalizing string = "Finalizing"

	// BackupRunSummaryStatusSkipped captures enum value "Skipped"
	BackupRunSummaryStatusSkipped string = "Skipped"

	// BackupRunSummaryStatusLegalHold captures enum value "LegalHold"
	BackupRunSummaryStatusLegalHold string = "LegalHold"

	// BackupRunSummaryStatusPaused captures enum value "Paused"
	BackupRunSummaryStatusPaused string = "Paused"
)

// prop value enum
func (m *BackupRunSummary) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupRunSummaryTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupRunSummary) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *BackupRunSummary) validateLocalSnapshotStats(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalSnapshotStats) { // not required
		return nil
	}

	if m.LocalSnapshotStats != nil {
		if err := m.LocalSnapshotStats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localSnapshotStats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localSnapshotStats")
			}
			return err
		}
	}

	return nil
}

var backupRunSummaryTypeDataLockPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Compliance","Administrative"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupRunSummaryTypeDataLockPropEnum = append(backupRunSummaryTypeDataLockPropEnum, v)
	}
}

const (

	// BackupRunSummaryDataLockCompliance captures enum value "Compliance"
	BackupRunSummaryDataLockCompliance string = "Compliance"

	// BackupRunSummaryDataLockAdministrative captures enum value "Administrative"
	BackupRunSummaryDataLockAdministrative string = "Administrative"
)

// prop value enum
func (m *BackupRunSummary) validateDataLockEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupRunSummaryTypeDataLockPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupRunSummary) validateDataLock(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLock) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataLockEnum("dataLock", "body", *m.DataLock); err != nil {
		return err
	}

	return nil
}

func (m *BackupRunSummary) validateDataLockConstraints(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLockConstraints) { // not required
		return nil
	}

	if m.DataLockConstraints != nil {
		if err := m.DataLockConstraints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConstraints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConstraints")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup run summary based on the context it is used
func (m *BackupRunSummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocalSnapshotStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataLockConstraints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupRunSummary) contextValidateLocalSnapshotStats(ctx context.Context, formats strfmt.Registry) error {

	if m.LocalSnapshotStats != nil {

		if swag.IsZero(m.LocalSnapshotStats) { // not required
			return nil
		}

		if err := m.LocalSnapshotStats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localSnapshotStats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localSnapshotStats")
			}
			return err
		}
	}

	return nil
}

func (m *BackupRunSummary) contextValidateDataLockConstraints(ctx context.Context, formats strfmt.Registry) error {

	if m.DataLockConstraints != nil {

		if swag.IsZero(m.DataLockConstraints) { // not required
			return nil
		}

		if err := m.DataLockConstraints.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConstraints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConstraints")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupRunSummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupRunSummary) UnmarshalBinary(b []byte) error {
	var res BackupRunSummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
