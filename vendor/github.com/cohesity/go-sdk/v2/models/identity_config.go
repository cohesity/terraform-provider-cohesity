// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IdentityConfig Identity Provider Configuration
//
// swagger:model IdentityConfig
type IdentityConfig struct {

	// Specifies the ID of the IDP.
	// Read Only: true
	ID *int64 `json:"id,omitempty"`

	// Specifies domain of idp configuration
	// Required: true
	Domain *string `json:"domain"`

	// Specifies the tenant id if the idp is configured for a tenant. If this is not set, this idp configuration is used for the cluster level users and for all users of tenants not having an idp configuration.
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies a flag to enable or disable this idp service. When it is set to true, idp service is enabled. When it is set to false, idp service is disabled. By defaut idp is enabled i.e the value is true.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Specifies the last time this configuration was modified in microseconds since the epoch. This is may be specified for PUT operations to prevent stale requests from being written. If it is specified during a PUT operation then the request will be rejected if the specified time does not match the actual last modified time.
	LastModifiedTimestampUsecs *int64 `json:"lastModifiedTimestampUsecs,omitempty"`

	// Specifies the type of identity provider.
	// Required: true
	// Enum: ["OpenIdConnect","OAuth2"]
	IdentityProviderType *string `json:"identityProviderType"`

	// open Id connect params
	OpenIDConnectParams *OpenIDProvider `json:"openIdConnectParams,omitempty"`

	// o auth2 params
	OAuth2Params *OAuth2Provider `json:"oAuth2Params,omitempty"`
}

// Validate validates this identity config
func (m *IdentityConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentityProviderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenIDConnectParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOAuth2Params(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IdentityConfig) validateDomain(formats strfmt.Registry) error {

	if err := validate.Required("domain", "body", m.Domain); err != nil {
		return err
	}

	return nil
}

var identityConfigTypeIdentityProviderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OpenIdConnect","OAuth2"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		identityConfigTypeIdentityProviderTypePropEnum = append(identityConfigTypeIdentityProviderTypePropEnum, v)
	}
}

const (

	// IdentityConfigIdentityProviderTypeOpenIDConnect captures enum value "OpenIdConnect"
	IdentityConfigIdentityProviderTypeOpenIDConnect string = "OpenIdConnect"

	// IdentityConfigIdentityProviderTypeOAuth2 captures enum value "OAuth2"
	IdentityConfigIdentityProviderTypeOAuth2 string = "OAuth2"
)

// prop value enum
func (m *IdentityConfig) validateIdentityProviderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, identityConfigTypeIdentityProviderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IdentityConfig) validateIdentityProviderType(formats strfmt.Registry) error {

	if err := validate.Required("identityProviderType", "body", m.IdentityProviderType); err != nil {
		return err
	}

	// value enum
	if err := m.validateIdentityProviderTypeEnum("identityProviderType", "body", *m.IdentityProviderType); err != nil {
		return err
	}

	return nil
}

func (m *IdentityConfig) validateOpenIDConnectParams(formats strfmt.Registry) error {
	if swag.IsZero(m.OpenIDConnectParams) { // not required
		return nil
	}

	if m.OpenIDConnectParams != nil {
		if err := m.OpenIDConnectParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("openIdConnectParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("openIdConnectParams")
			}
			return err
		}
	}

	return nil
}

func (m *IdentityConfig) validateOAuth2Params(formats strfmt.Registry) error {
	if swag.IsZero(m.OAuth2Params) { // not required
		return nil
	}

	if m.OAuth2Params != nil {
		if err := m.OAuth2Params.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oAuth2Params")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oAuth2Params")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this identity config based on the context it is used
func (m *IdentityConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOpenIDConnectParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOAuth2Params(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IdentityConfig) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *IdentityConfig) contextValidateOpenIDConnectParams(ctx context.Context, formats strfmt.Registry) error {

	if m.OpenIDConnectParams != nil {

		if swag.IsZero(m.OpenIDConnectParams) { // not required
			return nil
		}

		if err := m.OpenIDConnectParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("openIdConnectParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("openIdConnectParams")
			}
			return err
		}
	}

	return nil
}

func (m *IdentityConfig) contextValidateOAuth2Params(ctx context.Context, formats strfmt.Registry) error {

	if m.OAuth2Params != nil {

		if swag.IsZero(m.OAuth2Params) { // not required
			return nil
		}

		if err := m.OAuth2Params.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oAuth2Params")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oAuth2Params")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IdentityConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IdentityConfig) UnmarshalBinary(b []byte) error {
	var res IdentityConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
