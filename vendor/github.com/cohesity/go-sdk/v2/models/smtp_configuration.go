// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SMTPConfiguration Specifies the SMTP configuration details.
//
// swagger:model SMTPConfiguration
type SMTPConfiguration struct {

	// Specifies the username which will be used to connect to the SMTP server. If username is not specified, then it would imply that SMTP server is set up for unauthenticated access.
	Username *string `json:"username,omitempty"`

	// Specifies the IP address or the FQDN of the SMTP server.
	// Required: true
	Hostname string `json:"hostname"`

	// Specifies the SMTP port. Usually 465 or 587. For authenticated connection, it is generally 587.
	// Required: true
	Port int32 `json:"port"`

	// This is set to true when the SMTP server uses SSL/TLS without supporting STARTTLS. Typically, this is used for port 465.
	UseSSL *bool `json:"useSSL,omitempty"`

	// Specifies if the SMTP configuration is active.
	IsActive *bool `json:"isActive,omitempty"`
}

// Validate validates this SMTP configuration
func (m *SMTPConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostname(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SMTPConfiguration) validateHostname(formats strfmt.Registry) error {

	if err := validate.RequiredString("hostname", "body", m.Hostname); err != nil {
		return err
	}

	return nil
}

func (m *SMTPConfiguration) validatePort(formats strfmt.Registry) error {

	if err := validate.Required("port", "body", int32(m.Port)); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this SMTP configuration based on context it is used
func (m *SMTPConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SMTPConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SMTPConfiguration) UnmarshalBinary(b []byte) error {
	var res SMTPConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
