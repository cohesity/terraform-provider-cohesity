// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProtectionPolicy Protection Policy
//
// Specifies common fields required to define Protection Policy.
//
// swagger:model ProtectionPolicy
type ProtectionPolicy struct {

	// Specifies the name of the Protection Policy.
	// Required: true
	Name *string `json:"name"`

	// Specifies the backup schedule of a Protection Policy.
	// Required: true
	BackupPolicy *BackupPolicy `json:"backupPolicy"`

	// Specifies the description of the Protection Policy.
	Description *string `json:"description,omitempty"`

	// Blackout Window
	//
	// List of Blackout Windows. If specified, this field defines blackout periods when new Group Runs are not started. If a Group Run has been scheduled but not yet executed and the blackout period starts, the behavior depends on the policy field AbortInBlackoutPeriod.
	BlackoutWindow []*BlackoutWindow `json:"blackoutWindow"`

	// Extended Retention
	//
	// Specifies additional retention policies that should be applied to the backup snapshots. A backup snapshot will be retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []*ExtendedRetentionPolicy `json:"extendedRetention"`

	// Specifies the remote, archival or cloudSpin targets where the snapshot is backed up.
	RemoteTargetPolicy *TargetsConfiguration `json:"remoteTargetPolicy,omitempty"`

	// Specifies the configuration for cascaded replications. Using cascaded replication, replication cluster(Rx) can further replicate and archive the snapshot copies to further targets. Its recommended to create cascaded configuration where protection group will be created.
	CascadedTargetsConfig []*CascadedTargetConfiguration `json:"cascadedTargetsConfig"`

	// Specifies the retry options of a Protection Policy.
	RetryOptions *RetryOptions `json:"retryOptions,omitempty"`

	// This field is now deprecated. Please use the DataLockConfig in the backup retention.
	// Enum: ["Compliance","Administrative"]
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies the current policy verison. Policy version is incremented for optionally supporting new features and differentialting across releases.
	Version *int32 `json:"version,omitempty"`

	// Specifies true if Calender Based Schedule is supported by client. Default value is assumed as false for this feature.
	IsCBSEnabled *bool `json:"isCBSEnabled,omitempty"`

	// Specifies the last time this Policy was updated. If this is passed into a PUT request, then the backend will validate that the timestamp passed in matches the time that the policy was actually last modified. If the two timestamps do not match, then the request will be rejected with a stale error.
	LastModificationTimeUsecs *int64 `json:"lastModificationTimeUsecs,omitempty"`

	// Specifies whether smart local retention adjustment is enabled or not. If enabled, local retention would be extended upon failure of any outgoing replications or archivals. Later, if manual intervention causes the failed copies to succeed, retention would automatically be reduced.
	EnableSmartLocalRetentionAdjustment *bool `json:"enableSmartLocalRetentionAdjustment,omitempty"`
}

// Validate validates this protection policy
func (m *ProtectionPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlackoutWindow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtendedRetention(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteTargetPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCascadedTargetsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetryOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLock(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProtectionPolicy) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ProtectionPolicy) validateBackupPolicy(formats strfmt.Registry) error {

	if err := validate.Required("backupPolicy", "body", m.BackupPolicy); err != nil {
		return err
	}

	if m.BackupPolicy != nil {
		if err := m.BackupPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionPolicy) validateBlackoutWindow(formats strfmt.Registry) error {
	if swag.IsZero(m.BlackoutWindow) { // not required
		return nil
	}

	for i := 0; i < len(m.BlackoutWindow); i++ {
		if swag.IsZero(m.BlackoutWindow[i]) { // not required
			continue
		}

		if m.BlackoutWindow[i] != nil {
			if err := m.BlackoutWindow[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionPolicy) validateExtendedRetention(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtendedRetention) { // not required
		return nil
	}

	for i := 0; i < len(m.ExtendedRetention); i++ {
		if swag.IsZero(m.ExtendedRetention[i]) { // not required
			continue
		}

		if m.ExtendedRetention[i] != nil {
			if err := m.ExtendedRetention[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionPolicy) validateRemoteTargetPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteTargetPolicy) { // not required
		return nil
	}

	if m.RemoteTargetPolicy != nil {
		if err := m.RemoteTargetPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteTargetPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteTargetPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionPolicy) validateCascadedTargetsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.CascadedTargetsConfig) { // not required
		return nil
	}

	for i := 0; i < len(m.CascadedTargetsConfig); i++ {
		if swag.IsZero(m.CascadedTargetsConfig[i]) { // not required
			continue
		}

		if m.CascadedTargetsConfig[i] != nil {
			if err := m.CascadedTargetsConfig[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cascadedTargetsConfig" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cascadedTargetsConfig" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionPolicy) validateRetryOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.RetryOptions) { // not required
		return nil
	}

	if m.RetryOptions != nil {
		if err := m.RetryOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retryOptions")
			}
			return err
		}
	}

	return nil
}

var protectionPolicyTypeDataLockPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Compliance","Administrative"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionPolicyTypeDataLockPropEnum = append(protectionPolicyTypeDataLockPropEnum, v)
	}
}

const (

	// ProtectionPolicyDataLockCompliance captures enum value "Compliance"
	ProtectionPolicyDataLockCompliance string = "Compliance"

	// ProtectionPolicyDataLockAdministrative captures enum value "Administrative"
	ProtectionPolicyDataLockAdministrative string = "Administrative"
)

// prop value enum
func (m *ProtectionPolicy) validateDataLockEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionPolicyTypeDataLockPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionPolicy) validateDataLock(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLock) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataLockEnum("dataLock", "body", *m.DataLock); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this protection policy based on the context it is used
func (m *ProtectionPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBackupPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlackoutWindow(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtendedRetention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteTargetPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCascadedTargetsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetryOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProtectionPolicy) contextValidateBackupPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupPolicy != nil {

		if err := m.BackupPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionPolicy) contextValidateBlackoutWindow(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BlackoutWindow); i++ {

		if m.BlackoutWindow[i] != nil {

			if swag.IsZero(m.BlackoutWindow[i]) { // not required
				return nil
			}

			if err := m.BlackoutWindow[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionPolicy) contextValidateExtendedRetention(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExtendedRetention); i++ {

		if m.ExtendedRetention[i] != nil {

			if swag.IsZero(m.ExtendedRetention[i]) { // not required
				return nil
			}

			if err := m.ExtendedRetention[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionPolicy) contextValidateRemoteTargetPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.RemoteTargetPolicy != nil {

		if swag.IsZero(m.RemoteTargetPolicy) { // not required
			return nil
		}

		if err := m.RemoteTargetPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteTargetPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteTargetPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionPolicy) contextValidateCascadedTargetsConfig(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CascadedTargetsConfig); i++ {

		if m.CascadedTargetsConfig[i] != nil {

			if swag.IsZero(m.CascadedTargetsConfig[i]) { // not required
				return nil
			}

			if err := m.CascadedTargetsConfig[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cascadedTargetsConfig" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cascadedTargetsConfig" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionPolicy) contextValidateRetryOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.RetryOptions != nil {

		if swag.IsZero(m.RetryOptions) { // not required
			return nil
		}

		if err := m.RetryOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retryOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProtectionPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProtectionPolicy) UnmarshalBinary(b []byte) error {
	var res ProtectionPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
