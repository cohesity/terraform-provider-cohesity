// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RemoteClusterParams Specifies the parameters to update a Remote Cluster config.
//
// swagger:model RemoteClusterParams
type RemoteClusterParams struct {

	// Specifies the purpose for which the remote cluster is being registered.
	Purpose []string `json:"purpose,omitempty"`

	// Specifies the name of the network interfaces to use for communicating with the Remote Cluster.
	NetworkInterface *string `json:"networkInterface,omitempty"`

	// Specifies the IP addresses of the interfaces in the local Cluster which will be used for communicating with the remote Cluster.
	// Read Only: true
	LocalAddresses []string `json:"localAddresses,omitempty"`

	// Specifies if the Tx clusters should be automatically registered at the Rx site.
	AutoRegisterTarget *bool `json:"autoRegisterTarget,omitempty"`

	// Specifies any additional information if needed.
	Description *string `json:"description,omitempty"`

	// Specifies the Remote Cluster id.
	// Read Only: true
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the Remote Cluster incarnation id.
	// Read Only: true
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the Remote Cluster name.
	// Read Only: true
	ClusterName *string `json:"clusterName,omitempty"`

	// Specifies if the Remote Cluster was registered automatically or manually.
	// Read Only: true
	IsAutoRegistered *bool `json:"isAutoRegistered,omitempty"`

	// Specifies if the Remote Cluster has Multi-Tenancy enabled.
	MultiTenancyEnabled *bool `json:"multiTenancyEnabled,omitempty"`

	// Specifies if Tenant Storage Domain sharing is enabled on the Remote Cluster.
	TenantStorageDomainSharingEnabled *bool `json:"tenantStorageDomainSharingEnabled,omitempty"`

	// Specifies the AES Encryption mode of the remote cluster.
	// Enum: ["CBC","GCM"]
	SupportedAesEncryptionMode *string `json:"supportedAesEncryptionMode,omitempty"`

	// Specifies the effective AES Encryption mode negotiated between local and the remote cluster.
	// Enum: ["CBC","GCM"]
	EffectiveAesEncryptionMode *string `json:"effectiveAesEncryptionMode,omitempty"`

	// Specifies if TLS is enabled on the Remote Cluster.
	TLSEnabled *bool `json:"tlsEnabled,omitempty"`

	// Specifies the tenant Id of the Remote Cluster.
	// Read Only: true
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies the replication config for a Remote Cluster. Required when usedForReplication is set to true.
	ReplicationParams *ReplicationParams `json:"replicationParams,omitempty"`
}

// Validate validates this remote cluster params
func (m *RemoteClusterParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePurpose(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedAesEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveAesEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicationParams(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var remoteClusterParamsPurposeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Replication","RemoteAccess"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		remoteClusterParamsPurposeItemsEnum = append(remoteClusterParamsPurposeItemsEnum, v)
	}
}

func (m *RemoteClusterParams) validatePurposeItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, remoteClusterParamsPurposeItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *RemoteClusterParams) validatePurpose(formats strfmt.Registry) error {
	if swag.IsZero(m.Purpose) { // not required
		return nil
	}

	for i := 0; i < len(m.Purpose); i++ {

		// value enum
		if err := m.validatePurposeItemsEnum("purpose"+"."+strconv.Itoa(i), "body", m.Purpose[i]); err != nil {
			return err
		}

	}

	return nil
}

var remoteClusterParamsTypeSupportedAesEncryptionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CBC","GCM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		remoteClusterParamsTypeSupportedAesEncryptionModePropEnum = append(remoteClusterParamsTypeSupportedAesEncryptionModePropEnum, v)
	}
}

const (

	// RemoteClusterParamsSupportedAesEncryptionModeCBC captures enum value "CBC"
	RemoteClusterParamsSupportedAesEncryptionModeCBC string = "CBC"

	// RemoteClusterParamsSupportedAesEncryptionModeGCM captures enum value "GCM"
	RemoteClusterParamsSupportedAesEncryptionModeGCM string = "GCM"
)

// prop value enum
func (m *RemoteClusterParams) validateSupportedAesEncryptionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, remoteClusterParamsTypeSupportedAesEncryptionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *RemoteClusterParams) validateSupportedAesEncryptionMode(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedAesEncryptionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateSupportedAesEncryptionModeEnum("supportedAesEncryptionMode", "body", *m.SupportedAesEncryptionMode); err != nil {
		return err
	}

	return nil
}

var remoteClusterParamsTypeEffectiveAesEncryptionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CBC","GCM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		remoteClusterParamsTypeEffectiveAesEncryptionModePropEnum = append(remoteClusterParamsTypeEffectiveAesEncryptionModePropEnum, v)
	}
}

const (

	// RemoteClusterParamsEffectiveAesEncryptionModeCBC captures enum value "CBC"
	RemoteClusterParamsEffectiveAesEncryptionModeCBC string = "CBC"

	// RemoteClusterParamsEffectiveAesEncryptionModeGCM captures enum value "GCM"
	RemoteClusterParamsEffectiveAesEncryptionModeGCM string = "GCM"
)

// prop value enum
func (m *RemoteClusterParams) validateEffectiveAesEncryptionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, remoteClusterParamsTypeEffectiveAesEncryptionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *RemoteClusterParams) validateEffectiveAesEncryptionMode(formats strfmt.Registry) error {
	if swag.IsZero(m.EffectiveAesEncryptionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateEffectiveAesEncryptionModeEnum("effectiveAesEncryptionMode", "body", *m.EffectiveAesEncryptionMode); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) validateReplicationParams(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicationParams) { // not required
		return nil
	}

	if m.ReplicationParams != nil {
		if err := m.ReplicationParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicationParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicationParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this remote cluster params based on the context it is used
func (m *RemoteClusterParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocalAddresses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterIncarnationID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsAutoRegistered(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenantID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicationParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RemoteClusterParams) contextValidateLocalAddresses(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "localAddresses", "body", []string(m.LocalAddresses)); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) contextValidateClusterID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterId", "body", m.ClusterID); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) contextValidateClusterIncarnationID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterIncarnationId", "body", m.ClusterIncarnationID); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) contextValidateClusterName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterName", "body", m.ClusterName); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) contextValidateIsAutoRegistered(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isAutoRegistered", "body", m.IsAutoRegistered); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) contextValidateTenantID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenantId", "body", m.TenantID); err != nil {
		return err
	}

	return nil
}

func (m *RemoteClusterParams) contextValidateReplicationParams(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicationParams != nil {

		if swag.IsZero(m.ReplicationParams) { // not required
			return nil
		}

		if err := m.ReplicationParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicationParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicationParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RemoteClusterParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RemoteClusterParams) UnmarshalBinary(b []byte) error {
	var res RemoteClusterParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
