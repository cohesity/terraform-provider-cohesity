// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AlertInfo Specifies the fields of an alert.
//
// swagger:model AlertInfo
type AlertInfo struct {

	// Specifies unique id of the alert.
	ID *string `json:"id,omitempty"`

	// Specifies a unique code that categorizes the Alert, for example: CE00200014, where CE stands for Cohesity Error, the alert state next 3 digits is the id of the Alert Category (e.g. 002 for 'kNode') and the last 5 digits is the id of the Alert Type (e.g. 00014 for 'kNodeHighCpuUsage').
	AlertCode *string `json:"alertCode,omitempty"`

	// Specifies Unix epoch Timestamp (in microseconds) of the first occurrence of the Alert.
	FirstTimestampUsecs *int64 `json:"firstTimestampUsecs,omitempty"`

	// Specifies Unix epoch Timestamp (in microseconds) of the most recent occurrence of the Alert.
	LatestTimestampUsecs *int64 `json:"latestTimestampUsecs,omitempty"`

	// Specifies the alert category.
	// Enum: ["kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature","kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kDataPath","kMetadata","kIndexing","kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade","kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage","kFaultTolerance","kBackupRestore","kArchivalRestore","kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kStorageDevice","kStoragePool","kGeneralSoftwareFailure","kAgent"]
	AlertCategory *string `json:"alertCategory,omitempty"`

	// Specifies the alert type.
	AlertType *int32 `json:"alertType,omitempty"`

	// Specifies the alert severity.
	// Enum: ["kCritical","kWarning","kInfo"]
	Severity *string `json:"severity,omitempty"`

	// Specifies the alert state.
	// Enum: ["kResolved","kOpen","kNote","kSuppressed"]
	AlertState *string `json:"alertState,omitempty"`

	// List of property key and values associated with alert
	PropertyList []*Label `json:"propertyList"`

	// Specifies Unix epoch Timestamps (in microseconds) for the last 25 occurrences of duplicated Alerts that are stored with the original/primary Alert. Alerts are grouped into one Alert if the Alerts are the same type, are reporting on the same Object and occur within one hour. 'dedupCount' always reports the total count of duplicated Alerts even if there are more than 25 occurrences. For example, if there are 100 occurrences of this Alert, dedupTimestamps stores the timestamps of the last 25 occurrences and dedupCount equals 100.
	DedupTimestamps []int64 `json:"dedupTimestamps"`

	// Specifies the dedup count of alert.
	DedupCount *int32 `json:"dedupCount,omitempty"`

	// Specifies unique id generated when the Alert is suppressed by the admin.
	SuppressionID *int64 `json:"suppressionId,omitempty"`

	// Specifies information about the Alert Resolution.
	ResolutionDetails *AlertResolutionDetails `json:"resolutionDetails,omitempty"`

	// Specifies more details related to alert.
	AlertDocument *AlertDocument `json:"alertDocument,omitempty"`

	// Specifies the tenants for which this alert has been raised.
	TenantIds []string `json:"tenantIds"`

	// Specifies the name of cluster which alert is raised from.
	ClusterName *string `json:"clusterName,omitempty"`

	// Id of the cluster which the alert is associated
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the region id of the alert.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies source where the event occurred.
	EventSource *string `json:"eventSource,omitempty"`

	// Specifies the Alert type bucket.
	// Enum: ["kHardware","kSoftware","kDataService","kMaintenance"]
	AlertTypeBucket *string `json:"alertTypeBucket,omitempty"`

	// Specifies Unix epoch Timestamps in microseconds when alert is resolved.
	ResolvedTimestampUsecs *int64 `json:"resolvedTimestampUsecs,omitempty"`

	// Specifies the labels for which this alert has been raised.
	LabelIds []string `json:"labelIds"`

	// Specifies information about vaults where source object associated with alert is vaulted. This could be empty if alert is not related to any source object or it is not vaulted.
	Vaults []*Vault `json:"vaults"`

	// Resolution Id String.
	ResolutionIDString *string `json:"resolutionIdString,omitempty"`
}

// Validate validates this alert info
func (m *AlertInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePropertyList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolutionDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertDocument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertTypeBucket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaults(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var alertInfoTypeAlertCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature","kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kDataPath","kMetadata","kIndexing","kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade","kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage","kFaultTolerance","kBackupRestore","kArchivalRestore","kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kStorageDevice","kStoragePool","kGeneralSoftwareFailure","kAgent"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertInfoTypeAlertCategoryPropEnum = append(alertInfoTypeAlertCategoryPropEnum, v)
	}
}

const (

	// AlertInfoAlertCategoryKDisk captures enum value "kDisk"
	AlertInfoAlertCategoryKDisk string = "kDisk"

	// AlertInfoAlertCategoryKNode captures enum value "kNode"
	AlertInfoAlertCategoryKNode string = "kNode"

	// AlertInfoAlertCategoryKCluster captures enum value "kCluster"
	AlertInfoAlertCategoryKCluster string = "kCluster"

	// AlertInfoAlertCategoryKChassis captures enum value "kChassis"
	AlertInfoAlertCategoryKChassis string = "kChassis"

	// AlertInfoAlertCategoryKPowerSupply captures enum value "kPowerSupply"
	AlertInfoAlertCategoryKPowerSupply string = "kPowerSupply"

	// AlertInfoAlertCategoryKCPU captures enum value "kCPU"
	AlertInfoAlertCategoryKCPU string = "kCPU"

	// AlertInfoAlertCategoryKMemory captures enum value "kMemory"
	AlertInfoAlertCategoryKMemory string = "kMemory"

	// AlertInfoAlertCategoryKTemperature captures enum value "kTemperature"
	AlertInfoAlertCategoryKTemperature string = "kTemperature"

	// AlertInfoAlertCategoryKFan captures enum value "kFan"
	AlertInfoAlertCategoryKFan string = "kFan"

	// AlertInfoAlertCategoryKNIC captures enum value "kNIC"
	AlertInfoAlertCategoryKNIC string = "kNIC"

	// AlertInfoAlertCategoryKFirmware captures enum value "kFirmware"
	AlertInfoAlertCategoryKFirmware string = "kFirmware"

	// AlertInfoAlertCategoryKNodeHealth captures enum value "kNodeHealth"
	AlertInfoAlertCategoryKNodeHealth string = "kNodeHealth"

	// AlertInfoAlertCategoryKOperatingSystem captures enum value "kOperatingSystem"
	AlertInfoAlertCategoryKOperatingSystem string = "kOperatingSystem"

	// AlertInfoAlertCategoryKDataPath captures enum value "kDataPath"
	AlertInfoAlertCategoryKDataPath string = "kDataPath"

	// AlertInfoAlertCategoryKMetadata captures enum value "kMetadata"
	AlertInfoAlertCategoryKMetadata string = "kMetadata"

	// AlertInfoAlertCategoryKIndexing captures enum value "kIndexing"
	AlertInfoAlertCategoryKIndexing string = "kIndexing"

	// AlertInfoAlertCategoryKHelios captures enum value "kHelios"
	AlertInfoAlertCategoryKHelios string = "kHelios"

	// AlertInfoAlertCategoryKAppMarketPlace captures enum value "kAppMarketPlace"
	AlertInfoAlertCategoryKAppMarketPlace string = "kAppMarketPlace"

	// AlertInfoAlertCategoryKSystemService captures enum value "kSystemService"
	AlertInfoAlertCategoryKSystemService string = "kSystemService"

	// AlertInfoAlertCategoryKLicense captures enum value "kLicense"
	AlertInfoAlertCategoryKLicense string = "kLicense"

	// AlertInfoAlertCategoryKSecurity captures enum value "kSecurity"
	AlertInfoAlertCategoryKSecurity string = "kSecurity"

	// AlertInfoAlertCategoryKUpgrade captures enum value "kUpgrade"
	AlertInfoAlertCategoryKUpgrade string = "kUpgrade"

	// AlertInfoAlertCategoryKClusterManagement captures enum value "kClusterManagement"
	AlertInfoAlertCategoryKClusterManagement string = "kClusterManagement"

	// AlertInfoAlertCategoryKAuditLog captures enum value "kAuditLog"
	AlertInfoAlertCategoryKAuditLog string = "kAuditLog"

	// AlertInfoAlertCategoryKNetworking captures enum value "kNetworking"
	AlertInfoAlertCategoryKNetworking string = "kNetworking"

	// AlertInfoAlertCategoryKConfiguration captures enum value "kConfiguration"
	AlertInfoAlertCategoryKConfiguration string = "kConfiguration"

	// AlertInfoAlertCategoryKStorageUsage captures enum value "kStorageUsage"
	AlertInfoAlertCategoryKStorageUsage string = "kStorageUsage"

	// AlertInfoAlertCategoryKFaultTolerance captures enum value "kFaultTolerance"
	AlertInfoAlertCategoryKFaultTolerance string = "kFaultTolerance"

	// AlertInfoAlertCategoryKBackupRestore captures enum value "kBackupRestore"
	AlertInfoAlertCategoryKBackupRestore string = "kBackupRestore"

	// AlertInfoAlertCategoryKArchivalRestore captures enum value "kArchivalRestore"
	AlertInfoAlertCategoryKArchivalRestore string = "kArchivalRestore"

	// AlertInfoAlertCategoryKRemoteReplication captures enum value "kRemoteReplication"
	AlertInfoAlertCategoryKRemoteReplication string = "kRemoteReplication"

	// AlertInfoAlertCategoryKQuota captures enum value "kQuota"
	AlertInfoAlertCategoryKQuota string = "kQuota"

	// AlertInfoAlertCategoryKCDP captures enum value "kCDP"
	AlertInfoAlertCategoryKCDP string = "kCDP"

	// AlertInfoAlertCategoryKViewFailover captures enum value "kViewFailover"
	AlertInfoAlertCategoryKViewFailover string = "kViewFailover"

	// AlertInfoAlertCategoryKDisasterRecovery captures enum value "kDisasterRecovery"
	AlertInfoAlertCategoryKDisasterRecovery string = "kDisasterRecovery"

	// AlertInfoAlertCategoryKStorageDevice captures enum value "kStorageDevice"
	AlertInfoAlertCategoryKStorageDevice string = "kStorageDevice"

	// AlertInfoAlertCategoryKStoragePool captures enum value "kStoragePool"
	AlertInfoAlertCategoryKStoragePool string = "kStoragePool"

	// AlertInfoAlertCategoryKGeneralSoftwareFailure captures enum value "kGeneralSoftwareFailure"
	AlertInfoAlertCategoryKGeneralSoftwareFailure string = "kGeneralSoftwareFailure"

	// AlertInfoAlertCategoryKAgent captures enum value "kAgent"
	AlertInfoAlertCategoryKAgent string = "kAgent"
)

// prop value enum
func (m *AlertInfo) validateAlertCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertInfoTypeAlertCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AlertInfo) validateAlertCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertCategoryEnum("alertCategory", "body", *m.AlertCategory); err != nil {
		return err
	}

	return nil
}

var alertInfoTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCritical","kWarning","kInfo"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertInfoTypeSeverityPropEnum = append(alertInfoTypeSeverityPropEnum, v)
	}
}

const (

	// AlertInfoSeverityKCritical captures enum value "kCritical"
	AlertInfoSeverityKCritical string = "kCritical"

	// AlertInfoSeverityKWarning captures enum value "kWarning"
	AlertInfoSeverityKWarning string = "kWarning"

	// AlertInfoSeverityKInfo captures enum value "kInfo"
	AlertInfoSeverityKInfo string = "kInfo"
)

// prop value enum
func (m *AlertInfo) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertInfoTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AlertInfo) validateSeverity(formats strfmt.Registry) error {
	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", *m.Severity); err != nil {
		return err
	}

	return nil
}

var alertInfoTypeAlertStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kResolved","kOpen","kNote","kSuppressed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertInfoTypeAlertStatePropEnum = append(alertInfoTypeAlertStatePropEnum, v)
	}
}

const (

	// AlertInfoAlertStateKResolved captures enum value "kResolved"
	AlertInfoAlertStateKResolved string = "kResolved"

	// AlertInfoAlertStateKOpen captures enum value "kOpen"
	AlertInfoAlertStateKOpen string = "kOpen"

	// AlertInfoAlertStateKNote captures enum value "kNote"
	AlertInfoAlertStateKNote string = "kNote"

	// AlertInfoAlertStateKSuppressed captures enum value "kSuppressed"
	AlertInfoAlertStateKSuppressed string = "kSuppressed"
)

// prop value enum
func (m *AlertInfo) validateAlertStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertInfoTypeAlertStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AlertInfo) validateAlertState(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertStateEnum("alertState", "body", *m.AlertState); err != nil {
		return err
	}

	return nil
}

func (m *AlertInfo) validatePropertyList(formats strfmt.Registry) error {
	if swag.IsZero(m.PropertyList) { // not required
		return nil
	}

	for i := 0; i < len(m.PropertyList); i++ {
		if swag.IsZero(m.PropertyList[i]) { // not required
			continue
		}

		if m.PropertyList[i] != nil {
			if err := m.PropertyList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("propertyList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("propertyList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AlertInfo) validateResolutionDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.ResolutionDetails) { // not required
		return nil
	}

	if m.ResolutionDetails != nil {
		if err := m.ResolutionDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resolutionDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resolutionDetails")
			}
			return err
		}
	}

	return nil
}

func (m *AlertInfo) validateAlertDocument(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertDocument) { // not required
		return nil
	}

	if m.AlertDocument != nil {
		if err := m.AlertDocument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertDocument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertDocument")
			}
			return err
		}
	}

	return nil
}

var alertInfoTypeAlertTypeBucketPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kHardware","kSoftware","kDataService","kMaintenance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertInfoTypeAlertTypeBucketPropEnum = append(alertInfoTypeAlertTypeBucketPropEnum, v)
	}
}

const (

	// AlertInfoAlertTypeBucketKHardware captures enum value "kHardware"
	AlertInfoAlertTypeBucketKHardware string = "kHardware"

	// AlertInfoAlertTypeBucketKSoftware captures enum value "kSoftware"
	AlertInfoAlertTypeBucketKSoftware string = "kSoftware"

	// AlertInfoAlertTypeBucketKDataService captures enum value "kDataService"
	AlertInfoAlertTypeBucketKDataService string = "kDataService"

	// AlertInfoAlertTypeBucketKMaintenance captures enum value "kMaintenance"
	AlertInfoAlertTypeBucketKMaintenance string = "kMaintenance"
)

// prop value enum
func (m *AlertInfo) validateAlertTypeBucketEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertInfoTypeAlertTypeBucketPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AlertInfo) validateAlertTypeBucket(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertTypeBucket) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertTypeBucketEnum("alertTypeBucket", "body", *m.AlertTypeBucket); err != nil {
		return err
	}

	return nil
}

func (m *AlertInfo) validateVaults(formats strfmt.Registry) error {
	if swag.IsZero(m.Vaults) { // not required
		return nil
	}

	for i := 0; i < len(m.Vaults); i++ {
		if swag.IsZero(m.Vaults[i]) { // not required
			continue
		}

		if m.Vaults[i] != nil {
			if err := m.Vaults[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vaults" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vaults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this alert info based on the context it is used
func (m *AlertInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePropertyList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResolutionDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertDocument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVaults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AlertInfo) contextValidatePropertyList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PropertyList); i++ {

		if m.PropertyList[i] != nil {

			if swag.IsZero(m.PropertyList[i]) { // not required
				return nil
			}

			if err := m.PropertyList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("propertyList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("propertyList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AlertInfo) contextValidateResolutionDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.ResolutionDetails != nil {

		if swag.IsZero(m.ResolutionDetails) { // not required
			return nil
		}

		if err := m.ResolutionDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resolutionDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resolutionDetails")
			}
			return err
		}
	}

	return nil
}

func (m *AlertInfo) contextValidateAlertDocument(ctx context.Context, formats strfmt.Registry) error {

	if m.AlertDocument != nil {

		if swag.IsZero(m.AlertDocument) { // not required
			return nil
		}

		if err := m.AlertDocument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertDocument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertDocument")
			}
			return err
		}
	}

	return nil
}

func (m *AlertInfo) contextValidateVaults(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vaults); i++ {

		if m.Vaults[i] != nil {

			if swag.IsZero(m.Vaults[i]) { // not required
				return nil
			}

			if err := m.Vaults[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vaults" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vaults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AlertInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AlertInfo) UnmarshalBinary(b []byte) error {
	var res AlertInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
