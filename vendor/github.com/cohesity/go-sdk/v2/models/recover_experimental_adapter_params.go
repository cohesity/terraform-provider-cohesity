// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecoverExperimentalAdapterParams Recover Experimental Adapter params.
//
// Specifies the parameters to recover Experimental Adapter objects.
//
// swagger:model RecoverExperimentalAdapterParams
type RecoverExperimentalAdapterParams struct {

	// Specifies the type of experimental adapter restore.
	// Enum: ["RecoverObjects"]
	RestoreType *string `json:"restoreType,omitempty"`

	// Specifies the 'Source Registration ID' of the source where the objects are to be recovered. If this is not specified, the recovery job will recover to the original location.
	RecoverTo *int64 `json:"recoverTo,omitempty"`

	// Specifies the local snapshot ids and other details of the objects to be recovered.
	// Required: true
	Snapshots []*RecoverExperimentalAdapterSnapshotParams `json:"snapshots"`

	// Set to true to overwrite an existing object at the destination. If set to false, and the same object exists at the destination, then recovery will fail for that object.
	Overwrite *bool `json:"overwrite,omitempty"`

	// Workflow parameters to be supplied to all backup workflow tasks. This specifies task configuration such as the time to wait before returning the workflow result, subtasks configuration such as number of subtasks to generate and the depth of the subtask tree, etc.
	WorkflowParams *string `json:"workflowParams,omitempty"`
}

// Validate validates this recover experimental adapter params
func (m *RecoverExperimentalAdapterParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRestoreType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recoverExperimentalAdapterParamsTypeRestoreTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RecoverObjects"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recoverExperimentalAdapterParamsTypeRestoreTypePropEnum = append(recoverExperimentalAdapterParamsTypeRestoreTypePropEnum, v)
	}
}

const (

	// RecoverExperimentalAdapterParamsRestoreTypeRecoverObjects captures enum value "RecoverObjects"
	RecoverExperimentalAdapterParamsRestoreTypeRecoverObjects string = "RecoverObjects"
)

// prop value enum
func (m *RecoverExperimentalAdapterParams) validateRestoreTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recoverExperimentalAdapterParamsTypeRestoreTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *RecoverExperimentalAdapterParams) validateRestoreType(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRestoreTypeEnum("restoreType", "body", *m.RestoreType); err != nil {
		return err
	}

	return nil
}

func (m *RecoverExperimentalAdapterParams) validateSnapshots(formats strfmt.Registry) error {

	if err := validate.Required("snapshots", "body", m.Snapshots); err != nil {
		return err
	}

	for i := 0; i < len(m.Snapshots); i++ {
		if swag.IsZero(m.Snapshots[i]) { // not required
			continue
		}

		if m.Snapshots[i] != nil {
			if err := m.Snapshots[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshots" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshots" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this recover experimental adapter params based on the context it is used
func (m *RecoverExperimentalAdapterParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverExperimentalAdapterParams) contextValidateSnapshots(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Snapshots); i++ {

		if m.Snapshots[i] != nil {

			if swag.IsZero(m.Snapshots[i]) { // not required
				return nil
			}

			if err := m.Snapshots[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshots" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshots" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoverExperimentalAdapterParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoverExperimentalAdapterParams) UnmarshalBinary(b []byte) error {
	var res RecoverExperimentalAdapterParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
