// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PatchParams One of `packageUrl` or `versionName` must be specified.
//
// swagger:model PatchParams
type PatchParams struct {

	// The URL where the package can be downloaded from.
	// Applicable for operations:
	// * `DownloadPatchPackage`
	// * `DownloadUpgradeAndPatchPackages`
	// * `DownloadAndApplyPatch`
	//
	PackageURL *ArtifactURL `json:"packageUrl,omitempty"`

	// Version name of the package if the package is already downloaded.
	// Example: 7.0.1-p1-2023Jul04-cc6d7c5f
	// Applicable for operations:
	// * `ApplyPatch`
	// * `RevertPatch`
	// * `UpgradeAndPatch`
	//
	VersionName string `json:"versionName,omitempty"`

	// Node IDs where patch has to be applied.  If unspecified,
	// patch will be applied on all nodes.
	//
	NodeIds []int64 `json:"nodeIds"`

	// Specifies if healthchecks failure will cause
	// apply patch to be aborted. By default we patch if there are
	// healthchecks failures. Cluster will stop the apply patch and
	// present the failures which need to be resolved before
	// proceeding with apply patch.
	// If set to false, apply patchwill not be aborted on healthchecks
	// failure.
	//
	AbortOnPreChecksFailure *bool `json:"abortOnPreChecksFailure,omitempty"`

	// If set to true, patch will be applied in parallel on all nodes.
	// Applicable for operations:
	// * `ApplyPatch`
	// * `DownloadAndApplyPatch`
	//
	ApplyPatchInParallel *bool `json:"applyPatchInParallel,omitempty"`
}

// Validate validates this patch params
func (m *PatchParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePackageURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchParams) validatePackageURL(formats strfmt.Registry) error {
	if swag.IsZero(m.PackageURL) { // not required
		return nil
	}

	if m.PackageURL != nil {
		if err := m.PackageURL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("packageUrl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("packageUrl")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch params based on the context it is used
func (m *PatchParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePackageURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchParams) contextValidatePackageURL(ctx context.Context, formats strfmt.Registry) error {

	if m.PackageURL != nil {

		if swag.IsZero(m.PackageURL) { // not required
			return nil
		}

		if err := m.PackageURL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("packageUrl")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("packageUrl")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchParams) UnmarshalBinary(b []byte) error {
	var res PatchParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
