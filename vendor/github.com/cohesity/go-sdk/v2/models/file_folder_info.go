// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FileFolderInfo Contents information
//
// Specifies information of the contents (files and folders).
//
// swagger:model FileFolderInfo
type FileFolderInfo struct {

	// Specifies the environment of the object.
	// Enum: ["kVMware","kHyperV","kAzure","kKVM","kAWS","kAcropolis","kGCP","kPhysical","kPhysicalFiles","kIsilon","kNetapp","kGenericNas","kFlashBlade","kElastifile","kGPFS","kPure","kIbmFlashSystem","kNimble","kSQL","kOracle","kExchange","kAD","kView","kO365","kHyperFlex","kKubernetes","kCassandra","kMongoDB","kCouchbase","kHdfs","kHive","kHBase","kSAPHANA","kUDA","kSfdc"]
	Environment *string `json:"environment,omitempty"`

	// Specifies the parameters for Hdfs.
	HdfsParams []*HdfsFileFolderParams `json:"hdfsParams"`

	// Specifies the information needed in order to support pagination. This will not be included for the last page of results.
	PaginationInfo *PaginationInfo `json:"paginationInfo,omitempty"`
}

// Validate validates this file folder info
func (m *FileFolderInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHdfsParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaginationInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var fileFolderInfoTypeEnvironmentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kVMware","kHyperV","kAzure","kKVM","kAWS","kAcropolis","kGCP","kPhysical","kPhysicalFiles","kIsilon","kNetapp","kGenericNas","kFlashBlade","kElastifile","kGPFS","kPure","kIbmFlashSystem","kNimble","kSQL","kOracle","kExchange","kAD","kView","kO365","kHyperFlex","kKubernetes","kCassandra","kMongoDB","kCouchbase","kHdfs","kHive","kHBase","kSAPHANA","kUDA","kSfdc"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		fileFolderInfoTypeEnvironmentPropEnum = append(fileFolderInfoTypeEnvironmentPropEnum, v)
	}
}

const (

	// FileFolderInfoEnvironmentKVMware captures enum value "kVMware"
	FileFolderInfoEnvironmentKVMware string = "kVMware"

	// FileFolderInfoEnvironmentKHyperV captures enum value "kHyperV"
	FileFolderInfoEnvironmentKHyperV string = "kHyperV"

	// FileFolderInfoEnvironmentKAzure captures enum value "kAzure"
	FileFolderInfoEnvironmentKAzure string = "kAzure"

	// FileFolderInfoEnvironmentKKVM captures enum value "kKVM"
	FileFolderInfoEnvironmentKKVM string = "kKVM"

	// FileFolderInfoEnvironmentKAWS captures enum value "kAWS"
	FileFolderInfoEnvironmentKAWS string = "kAWS"

	// FileFolderInfoEnvironmentKAcropolis captures enum value "kAcropolis"
	FileFolderInfoEnvironmentKAcropolis string = "kAcropolis"

	// FileFolderInfoEnvironmentKGCP captures enum value "kGCP"
	FileFolderInfoEnvironmentKGCP string = "kGCP"

	// FileFolderInfoEnvironmentKPhysical captures enum value "kPhysical"
	FileFolderInfoEnvironmentKPhysical string = "kPhysical"

	// FileFolderInfoEnvironmentKPhysicalFiles captures enum value "kPhysicalFiles"
	FileFolderInfoEnvironmentKPhysicalFiles string = "kPhysicalFiles"

	// FileFolderInfoEnvironmentKIsilon captures enum value "kIsilon"
	FileFolderInfoEnvironmentKIsilon string = "kIsilon"

	// FileFolderInfoEnvironmentKNetapp captures enum value "kNetapp"
	FileFolderInfoEnvironmentKNetapp string = "kNetapp"

	// FileFolderInfoEnvironmentKGenericNas captures enum value "kGenericNas"
	FileFolderInfoEnvironmentKGenericNas string = "kGenericNas"

	// FileFolderInfoEnvironmentKFlashBlade captures enum value "kFlashBlade"
	FileFolderInfoEnvironmentKFlashBlade string = "kFlashBlade"

	// FileFolderInfoEnvironmentKElastifile captures enum value "kElastifile"
	FileFolderInfoEnvironmentKElastifile string = "kElastifile"

	// FileFolderInfoEnvironmentKGPFS captures enum value "kGPFS"
	FileFolderInfoEnvironmentKGPFS string = "kGPFS"

	// FileFolderInfoEnvironmentKPure captures enum value "kPure"
	FileFolderInfoEnvironmentKPure string = "kPure"

	// FileFolderInfoEnvironmentKIbmFlashSystem captures enum value "kIbmFlashSystem"
	FileFolderInfoEnvironmentKIbmFlashSystem string = "kIbmFlashSystem"

	// FileFolderInfoEnvironmentKNimble captures enum value "kNimble"
	FileFolderInfoEnvironmentKNimble string = "kNimble"

	// FileFolderInfoEnvironmentKSQL captures enum value "kSQL"
	FileFolderInfoEnvironmentKSQL string = "kSQL"

	// FileFolderInfoEnvironmentKOracle captures enum value "kOracle"
	FileFolderInfoEnvironmentKOracle string = "kOracle"

	// FileFolderInfoEnvironmentKExchange captures enum value "kExchange"
	FileFolderInfoEnvironmentKExchange string = "kExchange"

	// FileFolderInfoEnvironmentKAD captures enum value "kAD"
	FileFolderInfoEnvironmentKAD string = "kAD"

	// FileFolderInfoEnvironmentKView captures enum value "kView"
	FileFolderInfoEnvironmentKView string = "kView"

	// FileFolderInfoEnvironmentKO365 captures enum value "kO365"
	FileFolderInfoEnvironmentKO365 string = "kO365"

	// FileFolderInfoEnvironmentKHyperFlex captures enum value "kHyperFlex"
	FileFolderInfoEnvironmentKHyperFlex string = "kHyperFlex"

	// FileFolderInfoEnvironmentKKubernetes captures enum value "kKubernetes"
	FileFolderInfoEnvironmentKKubernetes string = "kKubernetes"

	// FileFolderInfoEnvironmentKCassandra captures enum value "kCassandra"
	FileFolderInfoEnvironmentKCassandra string = "kCassandra"

	// FileFolderInfoEnvironmentKMongoDB captures enum value "kMongoDB"
	FileFolderInfoEnvironmentKMongoDB string = "kMongoDB"

	// FileFolderInfoEnvironmentKCouchbase captures enum value "kCouchbase"
	FileFolderInfoEnvironmentKCouchbase string = "kCouchbase"

	// FileFolderInfoEnvironmentKHdfs captures enum value "kHdfs"
	FileFolderInfoEnvironmentKHdfs string = "kHdfs"

	// FileFolderInfoEnvironmentKHive captures enum value "kHive"
	FileFolderInfoEnvironmentKHive string = "kHive"

	// FileFolderInfoEnvironmentKHBase captures enum value "kHBase"
	FileFolderInfoEnvironmentKHBase string = "kHBase"

	// FileFolderInfoEnvironmentKSAPHANA captures enum value "kSAPHANA"
	FileFolderInfoEnvironmentKSAPHANA string = "kSAPHANA"

	// FileFolderInfoEnvironmentKUDA captures enum value "kUDA"
	FileFolderInfoEnvironmentKUDA string = "kUDA"

	// FileFolderInfoEnvironmentKSfdc captures enum value "kSfdc"
	FileFolderInfoEnvironmentKSfdc string = "kSfdc"
)

// prop value enum
func (m *FileFolderInfo) validateEnvironmentEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, fileFolderInfoTypeEnvironmentPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FileFolderInfo) validateEnvironment(formats strfmt.Registry) error {
	if swag.IsZero(m.Environment) { // not required
		return nil
	}

	// value enum
	if err := m.validateEnvironmentEnum("environment", "body", *m.Environment); err != nil {
		return err
	}

	return nil
}

func (m *FileFolderInfo) validateHdfsParams(formats strfmt.Registry) error {
	if swag.IsZero(m.HdfsParams) { // not required
		return nil
	}

	for i := 0; i < len(m.HdfsParams); i++ {
		if swag.IsZero(m.HdfsParams[i]) { // not required
			continue
		}

		if m.HdfsParams[i] != nil {
			if err := m.HdfsParams[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hdfsParams" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hdfsParams" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileFolderInfo) validatePaginationInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.PaginationInfo) { // not required
		return nil
	}

	if m.PaginationInfo != nil {
		if err := m.PaginationInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paginationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("paginationInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this file folder info based on the context it is used
func (m *FileFolderInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHdfsParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePaginationInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileFolderInfo) contextValidateHdfsParams(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HdfsParams); i++ {

		if m.HdfsParams[i] != nil {

			if swag.IsZero(m.HdfsParams[i]) { // not required
				return nil
			}

			if err := m.HdfsParams[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hdfsParams" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hdfsParams" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileFolderInfo) contextValidatePaginationInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.PaginationInfo != nil {

		if swag.IsZero(m.PaginationInfo) { // not required
			return nil
		}

		if err := m.PaginationInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paginationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("paginationInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileFolderInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileFolderInfo) UnmarshalBinary(b []byte) error {
	var res FileFolderInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
