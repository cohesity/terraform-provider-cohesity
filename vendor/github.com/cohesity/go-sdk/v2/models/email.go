// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Email Email
//
// Specifies an email or an email folder.
//
// swagger:model Email
type Email struct {

	// Specifies the id of the email object.
	ID *string `json:"id,omitempty"`

	// Specifies the User object info for which this email belongs to.
	UserObjectInfo *ObjectSummary `json:"userObjectInfo,omitempty"`

	// Specify the name of the email folder.
	FolderName *string `json:"folderName,omitempty"`

	// Specifies the id of parent folder the mailbox item.
	ParentFolderID *int64 `json:"parentFolderId,omitempty"`

	// Specifies the path to this mailbox item.
	Path *string `json:"path,omitempty"`

	// Specifies the directory path to this mailbox item.
	DirectoryPath *string `json:"directoryPath,omitempty"`

	// Specifies the Mailbox item type.
	// Enum: ["Email","Folder","Calendar","Contact","Task","Note"]
	Type *string `json:"type,omitempty"`

	// Specifies the subject of this email.
	EmailSubject *string `json:"emailSubject,omitempty"`

	// Specifies whether email has an attachment.
	HasAttachment *bool `json:"hasAttachment,omitempty"`

	// Specifies the sender's email address.
	SenderAddress *string `json:"senderAddress,omitempty"`

	// "Specifies the email addresses of all receipients of this email."
	RecipientAddresses []string `json:"recipientAddresses"`

	// "Specifies the email addresses of all the CC receipients of this
	// email."
	CcRecipientAddresses []string `json:"ccRecipientAddresses"`

	// "Specifies the email addresses of all the BCC receipients of this
	// email."
	BccRecipientAddresses []string `json:"bccRecipientAddresses"`

	// "Specifies the Unix timestamp epoch in seconds at which this
	// email is sent."
	SentTimeSecs *int64 `json:"sentTimeSecs,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this
	// email is received."
	ReceivedTimeSecs *int64 `json:"receivedTimeSecs,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this
	// item is created."
	CreatedTimeSecs *int64 `json:"createdTimeSecs,omitempty"`

	// "Specifies the calendar item organizer's email address."
	OrganizerAddress *string `json:"organizerAddress,omitempty"`

	// "Specifies the email addresses of all required attendees of this
	// calendar item."
	RequiredAttendeesAddresses []string `json:"requiredAttendeesAddresses"`

	// "Specifies the email addresses of all the optional attendees of
	// this calendar item."
	OptionalAttendeesAddresses []string `json:"optionalAttendeesAddresses"`

	// Specifies the contact's first name.
	FirstName *string `json:"firstName,omitempty"`

	// Specifies the contact's last name.
	LastName *string `json:"lastName,omitempty"`

	// Specifies the email addresses of a contact.
	EmailAddresses []string `json:"emailAddresses"`

	// "Specifies the Unix timestamp epoch in seconds at which this
	// item was modified."
	LastModificationTimeSecs *int64 `json:"lastModificationTimeSecs,omitempty"`

	// "Specifies the name of the person who modified this item."
	LastModificationName *string `json:"lastModificationName,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this
	// task item is due."
	TaskDueDateTimeSecs *int64 `json:"taskDueDateTimeSecs,omitempty"`

	// "Specifies the Unix timestamp epoch in seconds at which this
	// task item was completed."
	TaskCompletionDateTimeSecs *int64 `json:"taskCompletionDateTimeSecs,omitempty"`

	// Specifies the task item status type.
	// Enum: ["NotStarted","InProgress","Completed","WaitingOnOthers","Deferred"]
	TaskStatus *string `json:"taskStatus,omitempty"`

	// "Specifies the Protection Group id protecting the mailbox."
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// "Specifies the Protection Group name protecting the mailbox
	// item."
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// "Specifies the Storage Domain id where the backup data of Object
	// is present."
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// "Specify the tenant id to which this email belongs to."
	TenantID *string `json:"tenantId,omitempty"`

	TagObject
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *Email) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		ID *string `json:"id,omitempty"`

		UserObjectInfo *ObjectSummary `json:"userObjectInfo,omitempty"`

		FolderName *string `json:"folderName,omitempty"`

		ParentFolderID *int64 `json:"parentFolderId,omitempty"`

		Path *string `json:"path,omitempty"`

		DirectoryPath *string `json:"directoryPath,omitempty"`

		Type *string `json:"type,omitempty"`

		EmailSubject *string `json:"emailSubject,omitempty"`

		HasAttachment *bool `json:"hasAttachment,omitempty"`

		SenderAddress *string `json:"senderAddress,omitempty"`

		RecipientAddresses []string `json:"recipientAddresses"`

		CcRecipientAddresses []string `json:"ccRecipientAddresses"`

		BccRecipientAddresses []string `json:"bccRecipientAddresses"`

		SentTimeSecs *int64 `json:"sentTimeSecs,omitempty"`

		ReceivedTimeSecs *int64 `json:"receivedTimeSecs,omitempty"`

		CreatedTimeSecs *int64 `json:"createdTimeSecs,omitempty"`

		OrganizerAddress *string `json:"organizerAddress,omitempty"`

		RequiredAttendeesAddresses []string `json:"requiredAttendeesAddresses"`

		OptionalAttendeesAddresses []string `json:"optionalAttendeesAddresses"`

		FirstName *string `json:"firstName,omitempty"`

		LastName *string `json:"lastName,omitempty"`

		EmailAddresses []string `json:"emailAddresses"`

		LastModificationTimeSecs *int64 `json:"lastModificationTimeSecs,omitempty"`

		LastModificationName *string `json:"lastModificationName,omitempty"`

		TaskDueDateTimeSecs *int64 `json:"taskDueDateTimeSecs,omitempty"`

		TaskCompletionDateTimeSecs *int64 `json:"taskCompletionDateTimeSecs,omitempty"`

		TaskStatus *string `json:"taskStatus,omitempty"`

		ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

		ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

		StorageDomainID *int64 `json:"storageDomainId,omitempty"`

		TenantID *string `json:"tenantId,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.ID = dataAO0.ID

	m.UserObjectInfo = dataAO0.UserObjectInfo

	m.FolderName = dataAO0.FolderName

	m.ParentFolderID = dataAO0.ParentFolderID

	m.Path = dataAO0.Path

	m.DirectoryPath = dataAO0.DirectoryPath

	m.Type = dataAO0.Type

	m.EmailSubject = dataAO0.EmailSubject

	m.HasAttachment = dataAO0.HasAttachment

	m.SenderAddress = dataAO0.SenderAddress

	m.RecipientAddresses = dataAO0.RecipientAddresses

	m.CcRecipientAddresses = dataAO0.CcRecipientAddresses

	m.BccRecipientAddresses = dataAO0.BccRecipientAddresses

	m.SentTimeSecs = dataAO0.SentTimeSecs

	m.ReceivedTimeSecs = dataAO0.ReceivedTimeSecs

	m.CreatedTimeSecs = dataAO0.CreatedTimeSecs

	m.OrganizerAddress = dataAO0.OrganizerAddress

	m.RequiredAttendeesAddresses = dataAO0.RequiredAttendeesAddresses

	m.OptionalAttendeesAddresses = dataAO0.OptionalAttendeesAddresses

	m.FirstName = dataAO0.FirstName

	m.LastName = dataAO0.LastName

	m.EmailAddresses = dataAO0.EmailAddresses

	m.LastModificationTimeSecs = dataAO0.LastModificationTimeSecs

	m.LastModificationName = dataAO0.LastModificationName

	m.TaskDueDateTimeSecs = dataAO0.TaskDueDateTimeSecs

	m.TaskCompletionDateTimeSecs = dataAO0.TaskCompletionDateTimeSecs

	m.TaskStatus = dataAO0.TaskStatus

	m.ProtectionGroupID = dataAO0.ProtectionGroupID

	m.ProtectionGroupName = dataAO0.ProtectionGroupName

	m.StorageDomainID = dataAO0.StorageDomainID

	m.TenantID = dataAO0.TenantID

	// AO1
	var aO1 TagObject
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.TagObject = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m Email) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		ID *string `json:"id,omitempty"`

		UserObjectInfo *ObjectSummary `json:"userObjectInfo,omitempty"`

		FolderName *string `json:"folderName,omitempty"`

		ParentFolderID *int64 `json:"parentFolderId,omitempty"`

		Path *string `json:"path,omitempty"`

		DirectoryPath *string `json:"directoryPath,omitempty"`

		Type *string `json:"type,omitempty"`

		EmailSubject *string `json:"emailSubject,omitempty"`

		HasAttachment *bool `json:"hasAttachment,omitempty"`

		SenderAddress *string `json:"senderAddress,omitempty"`

		RecipientAddresses []string `json:"recipientAddresses"`

		CcRecipientAddresses []string `json:"ccRecipientAddresses"`

		BccRecipientAddresses []string `json:"bccRecipientAddresses"`

		SentTimeSecs *int64 `json:"sentTimeSecs,omitempty"`

		ReceivedTimeSecs *int64 `json:"receivedTimeSecs,omitempty"`

		CreatedTimeSecs *int64 `json:"createdTimeSecs,omitempty"`

		OrganizerAddress *string `json:"organizerAddress,omitempty"`

		RequiredAttendeesAddresses []string `json:"requiredAttendeesAddresses"`

		OptionalAttendeesAddresses []string `json:"optionalAttendeesAddresses"`

		FirstName *string `json:"firstName,omitempty"`

		LastName *string `json:"lastName,omitempty"`

		EmailAddresses []string `json:"emailAddresses"`

		LastModificationTimeSecs *int64 `json:"lastModificationTimeSecs,omitempty"`

		LastModificationName *string `json:"lastModificationName,omitempty"`

		TaskDueDateTimeSecs *int64 `json:"taskDueDateTimeSecs,omitempty"`

		TaskCompletionDateTimeSecs *int64 `json:"taskCompletionDateTimeSecs,omitempty"`

		TaskStatus *string `json:"taskStatus,omitempty"`

		ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

		ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

		StorageDomainID *int64 `json:"storageDomainId,omitempty"`

		TenantID *string `json:"tenantId,omitempty"`
	}

	dataAO0.ID = m.ID

	dataAO0.UserObjectInfo = m.UserObjectInfo

	dataAO0.FolderName = m.FolderName

	dataAO0.ParentFolderID = m.ParentFolderID

	dataAO0.Path = m.Path

	dataAO0.DirectoryPath = m.DirectoryPath

	dataAO0.Type = m.Type

	dataAO0.EmailSubject = m.EmailSubject

	dataAO0.HasAttachment = m.HasAttachment

	dataAO0.SenderAddress = m.SenderAddress

	dataAO0.RecipientAddresses = m.RecipientAddresses

	dataAO0.CcRecipientAddresses = m.CcRecipientAddresses

	dataAO0.BccRecipientAddresses = m.BccRecipientAddresses

	dataAO0.SentTimeSecs = m.SentTimeSecs

	dataAO0.ReceivedTimeSecs = m.ReceivedTimeSecs

	dataAO0.CreatedTimeSecs = m.CreatedTimeSecs

	dataAO0.OrganizerAddress = m.OrganizerAddress

	dataAO0.RequiredAttendeesAddresses = m.RequiredAttendeesAddresses

	dataAO0.OptionalAttendeesAddresses = m.OptionalAttendeesAddresses

	dataAO0.FirstName = m.FirstName

	dataAO0.LastName = m.LastName

	dataAO0.EmailAddresses = m.EmailAddresses

	dataAO0.LastModificationTimeSecs = m.LastModificationTimeSecs

	dataAO0.LastModificationName = m.LastModificationName

	dataAO0.TaskDueDateTimeSecs = m.TaskDueDateTimeSecs

	dataAO0.TaskCompletionDateTimeSecs = m.TaskCompletionDateTimeSecs

	dataAO0.TaskStatus = m.TaskStatus

	dataAO0.ProtectionGroupID = m.ProtectionGroupID

	dataAO0.ProtectionGroupName = m.ProtectionGroupName

	dataAO0.StorageDomainID = m.StorageDomainID

	dataAO0.TenantID = m.TenantID

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.TagObject)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this email
func (m *Email) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUserObjectInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskStatus(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with TagObject
	if err := m.TagObject.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Email) validateUserObjectInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.UserObjectInfo) { // not required
		return nil
	}

	if m.UserObjectInfo != nil {
		if err := m.UserObjectInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("userObjectInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("userObjectInfo")
			}
			return err
		}
	}

	return nil
}

var emailTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Email","Folder","Calendar","Contact","Task","Note"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		emailTypeTypePropEnum = append(emailTypeTypePropEnum, v)
	}
}

// property enum
func (m *Email) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, emailTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Email) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var emailTypeTaskStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NotStarted","InProgress","Completed","WaitingOnOthers","Deferred"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		emailTypeTaskStatusPropEnum = append(emailTypeTaskStatusPropEnum, v)
	}
}

// property enum
func (m *Email) validateTaskStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, emailTypeTaskStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Email) validateTaskStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.TaskStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateTaskStatusEnum("taskStatus", "body", *m.TaskStatus); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this email based on the context it is used
func (m *Email) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateUserObjectInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with TagObject
	if err := m.TagObject.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Email) contextValidateUserObjectInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.UserObjectInfo != nil {

		if swag.IsZero(m.UserObjectInfo) { // not required
			return nil
		}

		if err := m.UserObjectInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("userObjectInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("userObjectInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Email) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Email) UnmarshalBinary(b []byte) error {
	var res Email
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
