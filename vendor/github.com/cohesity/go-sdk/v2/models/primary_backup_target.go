// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PrimaryBackupTarget Specifies the primary backup target settings for regular backups. If the backup target field is not specified then backup will be taken locally on the Cohesity cluster.
//
// swagger:model PrimaryBackupTarget
type PrimaryBackupTarget struct {

	// Specifies if the default primary backup target must be used for backups. If this is not specified or set to false, then targets specified in 'archivalTargetSettings' will be used for backups. If the value is specified as true, then default backup target is used internally. This field should only be set in the environment where tenant policy management is enabled and external targets are assigned to tenant when provisioning tenants.
	UseDefaultBackupTarget *bool `json:"useDefaultBackupTarget,omitempty"`

	// Specifies the primary backup location where backups will be stored. If not specified, then default is assumed as local backup on Cohesity cluster.
	// Enum: ["Local","Archival"]
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the archival backup target details. This is applicable only if targetType is set to 'archival'.
	ArchivalTargetSettings *PrimaryArchivalTarget `json:"archivalTargetSettings,omitempty"`
}

// Validate validates this primary backup target
func (m *PrimaryBackupTarget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTargetType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchivalTargetSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var primaryBackupTargetTypeTargetTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Local","Archival"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		primaryBackupTargetTypeTargetTypePropEnum = append(primaryBackupTargetTypeTargetTypePropEnum, v)
	}
}

const (

	// PrimaryBackupTargetTargetTypeLocal captures enum value "Local"
	PrimaryBackupTargetTargetTypeLocal string = "Local"

	// PrimaryBackupTargetTargetTypeArchival captures enum value "Archival"
	PrimaryBackupTargetTargetTypeArchival string = "Archival"
)

// prop value enum
func (m *PrimaryBackupTarget) validateTargetTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, primaryBackupTargetTypeTargetTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PrimaryBackupTarget) validateTargetType(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTargetTypeEnum("targetType", "body", *m.TargetType); err != nil {
		return err
	}

	return nil
}

func (m *PrimaryBackupTarget) validateArchivalTargetSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchivalTargetSettings) { // not required
		return nil
	}

	if m.ArchivalTargetSettings != nil {
		if err := m.ArchivalTargetSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalTargetSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalTargetSettings")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this primary backup target based on the context it is used
func (m *PrimaryBackupTarget) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateArchivalTargetSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrimaryBackupTarget) contextValidateArchivalTargetSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchivalTargetSettings != nil {

		if swag.IsZero(m.ArchivalTargetSettings) { // not required
			return nil
		}

		if err := m.ArchivalTargetSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalTargetSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalTargetSettings")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrimaryBackupTarget) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrimaryBackupTarget) UnmarshalBinary(b []byte) error {
	var res PrimaryBackupTarget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
