// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SmbActiveOpen Specifies an active open of an SMB file, its access and sharing information.
//
// swagger:model SmbActiveOpen
type SmbActiveOpen struct {

	// Specifies the id of the active open.
	OpenID *int64 `json:"openId,omitempty"`

	// Specifies the File Access Type. Following documentation was taken from MSDN.
	// https://msdn.microsoft.com/en-us/library/Cc246802.aspx
	//
	// 'FileReadData' indicates the right to read data from the file or named
	//   pipe.
	// 'FileWriteData' indicates the right to write data into the file or named
	//   pipe beyond the end of the file.
	// 'FileAppendData' indicates the right to append data into the file or named
	//   pipe.
	// 'FileReadEa' indicates the right to read the extended attributes of the
	//   file or named pipe.
	// 'FileWriteEa' indicates the right to write or change the extended
	//   attributes to the file or named pipe.
	// 'FileExecute' indicates the right to delete entries within a directory.
	// 'FileDeleteChild' indicates the right to execute the file.
	// 'FileReadAttributes' indicates the right to read the attributes of the
	//   file.
	// 'FileWriteAttributes' indicates the right to change the attributes of the
	//   file.
	// 'Delete' indicates the right to delete the file.
	// 'ReadControl' indicates the right to read the security descriptor for the
	//   file or named pipe.
	// 'WriteDac' indicates the right to change the discretionary access control
	//   list (DACL) in the security descriptor for the file or named pipe. For
	//   the DACL data structure, see ACL in [MS-DTYP].
	// 'WriteOwner' indicates the right to change the owner in the security
	//   descriptor for the file or named pipe.
	// 'Synchronize' is used only by SMB2 clients.
	// 'AccessSystemSecurity' indicates the right to read or change the system
	//   access control list (SACL) in the security descriptor for the file or
	//   named pipe. For the SACL data structure, see ACL in [MS-DTYP].<42>
	// 'MaximumAllowed' indicates that the client is requesting an open to the
	//   file with the highest level of access the client has on this file.
	//   If no access is granted for the client on this file, the server MUST
	//   fail the open with STATUS_ACCESS_DENIED.
	// 'GenericAll' indicates a request for all the access flags that are
	//   previously listed except MaximumAllowed and AccessSystemSecurity.
	// 'GenericExecute' indicates a request for the following combination of
	//   access flags listed above:
	//   FileReadAttributes| FileExecute| Synchronize| ReadControl.
	// 'GenericWrite' indicates a request for the following combination of
	//   access flags listed above:
	//   FileWriteData| FileAppendData| FileWriteAttributes| FileWriteEa|
	//   Synchronize| ReadControl.
	// 'GenericRead' indicates a request for the following combination of
	//   access flags listed above:
	//   FileReadData| FileReadAttributes| FileReadEa| Synchronize|
	//   ReadControl.
	AccessInfoList []string `json:"accessInfoList"`

	// Specifies whether access privilege of others if they're allowed to read/write/delete.
	AccessPrivilege []string `json:"accessPrivilege"`
}

// Validate validates this smb active open
func (m *SmbActiveOpen) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessInfoList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessPrivilege(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var smbActiveOpenAccessInfoListItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FileReadData","FileWriteData","FileAppendData","FileReadEa","FileWriteEa","FileExecute","FileDeleteChild","FileReadAttributes","FileWriteAttributes","Delete","ReadControl","WriteDac","WriteOwner","Synchronize","AccessSystemSecurity","MaximumAllowed","GenericAll","GenericExecute","GenericWrite","GenericRead"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbActiveOpenAccessInfoListItemsEnum = append(smbActiveOpenAccessInfoListItemsEnum, v)
	}
}

func (m *SmbActiveOpen) validateAccessInfoListItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbActiveOpenAccessInfoListItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbActiveOpen) validateAccessInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.AccessInfoList); i++ {

		// value enum
		if err := m.validateAccessInfoListItemsEnum("accessInfoList"+"."+strconv.Itoa(i), "body", m.AccessInfoList[i]); err != nil {
			return err
		}

	}

	return nil
}

var smbActiveOpenAccessPrivilegeItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Read","Write","Delete"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbActiveOpenAccessPrivilegeItemsEnum = append(smbActiveOpenAccessPrivilegeItemsEnum, v)
	}
}

func (m *SmbActiveOpen) validateAccessPrivilegeItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbActiveOpenAccessPrivilegeItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbActiveOpen) validateAccessPrivilege(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessPrivilege) { // not required
		return nil
	}

	for i := 0; i < len(m.AccessPrivilege); i++ {

		// value enum
		if err := m.validateAccessPrivilegeItemsEnum("accessPrivilege"+"."+strconv.Itoa(i), "body", m.AccessPrivilege[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this smb active open based on context it is used
func (m *SmbActiveOpen) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SmbActiveOpen) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SmbActiveOpen) UnmarshalBinary(b []byte) error {
	var res SmbActiveOpen
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
