// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterSWUpdateHistoryEvent Represents an event of cluster upgrade/patch
//
// swagger:model ClusterSWUpdateHistoryEvent
type ClusterSWUpdateHistoryEvent struct {

	// Name of the package version.
	// Example: '6.6.0d_u6_release-20210714_0fad884e',
	//   '7.0.1_release-20230623_ddbb8c79' for upgrade packages,
	// '6.8.1-p1s1-2023Jun26-221b8a5c' for patch packages
	//
	VersionName *string `json:"versionName,omitempty"`

	// Release date of the package.
	// Format: date-time
	ReleaseDate *strfmt.DateTime `json:"releaseDate,omitempty"`

	// Release version of the package.
	// Examples:
	// For upgrade package: '6.6.0d_u6', '7.0.'
	// For patch package - '6.8.1-p1s1'
	//
	ReleaseVersion string `json:"releaseVersion,omitempty"`

	// Type of the package
	// Enum: ["Upgrade","Patch"]
	PackageType string `json:"packageType,omitempty"`

	// Sub-type of package - Security Patch or Product Patch
	// Enum: ["SecurityPatch","ProductPatch"]
	PackageSubType *string `json:"packageSubType,omitempty"`

	// Type of operation.
	//
	// Enum: ["DownloadUpgradePackage","DownloadPatchPackage","DownloadUpgradeAndPatchPackages","DownloadAndUpgrade","DownloadAndApplyPatch","DownloadAndUpgradeWithPatch","Upgrade","ApplyPatch","RevertPatch","UpgradeAndPatch","AssessSoftwareUpdate","AbortApplyPatch","AbortUpgrade"]
	OperationType string `json:"operationType,omitempty"`

	// Latest Unix epoch timestamp (in seconds) when the upgrade/patch
	// was done - will contain the value from the node that got updated last.
	//
	EventTimestampSecs *int64 `json:"eventTimestampSecs,omitempty"`

	// node history
	NodeHistory []*ClusterSWUpdateNodeHistoryEvent `json:"nodeHistory,omitempty"`
}

// Validate validates this cluster s w update history event
func (m *ClusterSWUpdateHistoryEvent) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateReleaseDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackageSubType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeHistory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterSWUpdateHistoryEvent) validateReleaseDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ReleaseDate) { // not required
		return nil
	}

	if err := validate.FormatOf("releaseDate", "body", "date-time", m.ReleaseDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var clusterSWUpdateHistoryEventTypePackageTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Upgrade","Patch"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterSWUpdateHistoryEventTypePackageTypePropEnum = append(clusterSWUpdateHistoryEventTypePackageTypePropEnum, v)
	}
}

const (

	// ClusterSWUpdateHistoryEventPackageTypeUpgrade captures enum value "Upgrade"
	ClusterSWUpdateHistoryEventPackageTypeUpgrade string = "Upgrade"

	// ClusterSWUpdateHistoryEventPackageTypePatch captures enum value "Patch"
	ClusterSWUpdateHistoryEventPackageTypePatch string = "Patch"
)

// prop value enum
func (m *ClusterSWUpdateHistoryEvent) validatePackageTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterSWUpdateHistoryEventTypePackageTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterSWUpdateHistoryEvent) validatePackageType(formats strfmt.Registry) error {
	if swag.IsZero(m.PackageType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePackageTypeEnum("packageType", "body", m.PackageType); err != nil {
		return err
	}

	return nil
}

var clusterSWUpdateHistoryEventTypePackageSubTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SecurityPatch","ProductPatch"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterSWUpdateHistoryEventTypePackageSubTypePropEnum = append(clusterSWUpdateHistoryEventTypePackageSubTypePropEnum, v)
	}
}

const (

	// ClusterSWUpdateHistoryEventPackageSubTypeSecurityPatch captures enum value "SecurityPatch"
	ClusterSWUpdateHistoryEventPackageSubTypeSecurityPatch string = "SecurityPatch"

	// ClusterSWUpdateHistoryEventPackageSubTypeProductPatch captures enum value "ProductPatch"
	ClusterSWUpdateHistoryEventPackageSubTypeProductPatch string = "ProductPatch"
)

// prop value enum
func (m *ClusterSWUpdateHistoryEvent) validatePackageSubTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterSWUpdateHistoryEventTypePackageSubTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterSWUpdateHistoryEvent) validatePackageSubType(formats strfmt.Registry) error {
	if swag.IsZero(m.PackageSubType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePackageSubTypeEnum("packageSubType", "body", *m.PackageSubType); err != nil {
		return err
	}

	return nil
}

var clusterSWUpdateHistoryEventTypeOperationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DownloadUpgradePackage","DownloadPatchPackage","DownloadUpgradeAndPatchPackages","DownloadAndUpgrade","DownloadAndApplyPatch","DownloadAndUpgradeWithPatch","Upgrade","ApplyPatch","RevertPatch","UpgradeAndPatch","AssessSoftwareUpdate","AbortApplyPatch","AbortUpgrade"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterSWUpdateHistoryEventTypeOperationTypePropEnum = append(clusterSWUpdateHistoryEventTypeOperationTypePropEnum, v)
	}
}

const (

	// ClusterSWUpdateHistoryEventOperationTypeDownloadUpgradePackage captures enum value "DownloadUpgradePackage"
	ClusterSWUpdateHistoryEventOperationTypeDownloadUpgradePackage string = "DownloadUpgradePackage"

	// ClusterSWUpdateHistoryEventOperationTypeDownloadPatchPackage captures enum value "DownloadPatchPackage"
	ClusterSWUpdateHistoryEventOperationTypeDownloadPatchPackage string = "DownloadPatchPackage"

	// ClusterSWUpdateHistoryEventOperationTypeDownloadUpgradeAndPatchPackages captures enum value "DownloadUpgradeAndPatchPackages"
	ClusterSWUpdateHistoryEventOperationTypeDownloadUpgradeAndPatchPackages string = "DownloadUpgradeAndPatchPackages"

	// ClusterSWUpdateHistoryEventOperationTypeDownloadAndUpgrade captures enum value "DownloadAndUpgrade"
	ClusterSWUpdateHistoryEventOperationTypeDownloadAndUpgrade string = "DownloadAndUpgrade"

	// ClusterSWUpdateHistoryEventOperationTypeDownloadAndApplyPatch captures enum value "DownloadAndApplyPatch"
	ClusterSWUpdateHistoryEventOperationTypeDownloadAndApplyPatch string = "DownloadAndApplyPatch"

	// ClusterSWUpdateHistoryEventOperationTypeDownloadAndUpgradeWithPatch captures enum value "DownloadAndUpgradeWithPatch"
	ClusterSWUpdateHistoryEventOperationTypeDownloadAndUpgradeWithPatch string = "DownloadAndUpgradeWithPatch"

	// ClusterSWUpdateHistoryEventOperationTypeUpgrade captures enum value "Upgrade"
	ClusterSWUpdateHistoryEventOperationTypeUpgrade string = "Upgrade"

	// ClusterSWUpdateHistoryEventOperationTypeApplyPatch captures enum value "ApplyPatch"
	ClusterSWUpdateHistoryEventOperationTypeApplyPatch string = "ApplyPatch"

	// ClusterSWUpdateHistoryEventOperationTypeRevertPatch captures enum value "RevertPatch"
	ClusterSWUpdateHistoryEventOperationTypeRevertPatch string = "RevertPatch"

	// ClusterSWUpdateHistoryEventOperationTypeUpgradeAndPatch captures enum value "UpgradeAndPatch"
	ClusterSWUpdateHistoryEventOperationTypeUpgradeAndPatch string = "UpgradeAndPatch"

	// ClusterSWUpdateHistoryEventOperationTypeAssessSoftwareUpdate captures enum value "AssessSoftwareUpdate"
	ClusterSWUpdateHistoryEventOperationTypeAssessSoftwareUpdate string = "AssessSoftwareUpdate"

	// ClusterSWUpdateHistoryEventOperationTypeAbortApplyPatch captures enum value "AbortApplyPatch"
	ClusterSWUpdateHistoryEventOperationTypeAbortApplyPatch string = "AbortApplyPatch"

	// ClusterSWUpdateHistoryEventOperationTypeAbortUpgrade captures enum value "AbortUpgrade"
	ClusterSWUpdateHistoryEventOperationTypeAbortUpgrade string = "AbortUpgrade"
)

// prop value enum
func (m *ClusterSWUpdateHistoryEvent) validateOperationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterSWUpdateHistoryEventTypeOperationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterSWUpdateHistoryEvent) validateOperationType(formats strfmt.Registry) error {
	if swag.IsZero(m.OperationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationTypeEnum("operationType", "body", m.OperationType); err != nil {
		return err
	}

	return nil
}

func (m *ClusterSWUpdateHistoryEvent) validateNodeHistory(formats strfmt.Registry) error {
	if swag.IsZero(m.NodeHistory) { // not required
		return nil
	}

	for i := 0; i < len(m.NodeHistory); i++ {
		if swag.IsZero(m.NodeHistory[i]) { // not required
			continue
		}

		if m.NodeHistory[i] != nil {
			if err := m.NodeHistory[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodeHistory" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodeHistory" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster s w update history event based on the context it is used
func (m *ClusterSWUpdateHistoryEvent) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNodeHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterSWUpdateHistoryEvent) contextValidateNodeHistory(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NodeHistory); i++ {

		if m.NodeHistory[i] != nil {

			if swag.IsZero(m.NodeHistory[i]) { // not required
				return nil
			}

			if err := m.NodeHistory[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodeHistory" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodeHistory" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterSWUpdateHistoryEvent) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterSWUpdateHistoryEvent) UnmarshalBinary(b []byte) error {
	var res ClusterSWUpdateHistoryEvent
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
