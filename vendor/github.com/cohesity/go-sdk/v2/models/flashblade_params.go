// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FlashbladeParams Specifies the information related to Registered Pure Flashblade.
//
// swagger:model FlashbladeParams
type FlashbladeParams struct {

	// Specifies the parameters to register a VMware Protection Source.
	RegistrationParams *FlashBladeRegistrationInfo `json:"registrationParams,omitempty"`

	// Specifies uuid of the pure flashblade server.
	// Read Only: true
	UUID *string `json:"uuid,omitempty"`

	// Specifies list of data vips that are assigned to cohesity cluster to create nfs share mountpoints.
	// Min Items: 1
	AssignedDataVips []string `json:"assignedDataVips"`

	// Specifies the capacity in bytes assigned on pure flashblade for remote storage usage on cohesity cluster.
	AssignedCapacityBytes *int64 `json:"assignedCapacityBytes,omitempty"`

	// If true, cohesity cluster uses all available capacity on pure flashblade for remote storage.
	IsDedicatedStorage *bool `json:"isDedicatedStorage,omitempty"`

	// Available data vips configured on pure flashblade.
	// Read Only: true
	AvailableDataVips []*string `json:"availableDataVips"`

	// Available capacity on pure flashblade.
	// Read Only: true
	AvailableCapacity *int64 `json:"availableCapacity,omitempty"`

	// Number of new file systems created on pure flashblade when assignedCapacityBytes is updated.
	// Read Only: true
	CreatedFileSystemCount *int64 `json:"createdFileSystemCount,omitempty"`

	// Number of file systems that are updated on pure flashblade when assignedCapacityBytes is updated.
	// Read Only: true
	UpdatedFileSystemCount *int64 `json:"updatedFileSystemCount,omitempty"`

	// Software OS and version running on pure flashblade
	// Read Only: true
	SoftwareOsVersion *string `json:"softwareOsVersion,omitempty"`

	// Name of the pure flashblade specified on pure storage.
	// Read Only: true
	Name *string `json:"name,omitempty"`

	// Total capacity of pure flashblade.
	// Read Only: true
	TotalCapacity *int64 `json:"totalCapacity,omitempty"`
}

// Validate validates this flashblade params
func (m *FlashbladeParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRegistrationParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssignedDataVips(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlashbladeParams) validateRegistrationParams(formats strfmt.Registry) error {
	if swag.IsZero(m.RegistrationParams) { // not required
		return nil
	}

	if m.RegistrationParams != nil {
		if err := m.RegistrationParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registrationParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registrationParams")
			}
			return err
		}
	}

	return nil
}

func (m *FlashbladeParams) validateAssignedDataVips(formats strfmt.Registry) error {
	if swag.IsZero(m.AssignedDataVips) { // not required
		return nil
	}

	iAssignedDataVipsSize := int64(len(m.AssignedDataVips))

	if err := validate.MinItems("assignedDataVips", "body", iAssignedDataVipsSize, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this flashblade params based on the context it is used
func (m *FlashbladeParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRegistrationParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAvailableDataVips(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAvailableCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedFileSystemCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdatedFileSystemCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftwareOsVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTotalCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FlashbladeParams) contextValidateRegistrationParams(ctx context.Context, formats strfmt.Registry) error {

	if m.RegistrationParams != nil {

		if swag.IsZero(m.RegistrationParams) { // not required
			return nil
		}

		if err := m.RegistrationParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registrationParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registrationParams")
			}
			return err
		}
	}

	return nil
}

func (m *FlashbladeParams) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateAvailableDataVips(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "availableDataVips", "body", []*string(m.AvailableDataVips)); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateAvailableCapacity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "availableCapacity", "body", m.AvailableCapacity); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateCreatedFileSystemCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdFileSystemCount", "body", m.CreatedFileSystemCount); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateUpdatedFileSystemCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "updatedFileSystemCount", "body", m.UpdatedFileSystemCount); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateSoftwareOsVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "softwareOsVersion", "body", m.SoftwareOsVersion); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *FlashbladeParams) contextValidateTotalCapacity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "totalCapacity", "body", m.TotalCapacity); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FlashbladeParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FlashbladeParams) UnmarshalBinary(b []byte) error {
	var res FlashbladeParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
