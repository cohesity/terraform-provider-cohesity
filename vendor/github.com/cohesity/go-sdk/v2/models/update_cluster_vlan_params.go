// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateClusterVlanParams Parameters to update vlan on the cluster.
//
// swagger:model UpdateClusterVlanParams
type UpdateClusterVlanParams struct {

	// Allow vlan to be used by all tenants without explicit assignment. Set to true only when the vlan is not assigned to any tenant.
	AllTenantAccess *bool `json:"allTenantAccess,omitempty"`

	// Vlan IP addresses for apps.
	AppIps []string `json:"appIps"`

	// Description of the vlan.
	Description *string `json:"description,omitempty"`

	// Set to true to enable ECMP in the vlan.
	EcmpEnabled *bool `json:"ecmpEnabled,omitempty"`

	// Type of IP addresses. The default value is Ipv4.
	// Enum: ["Ipv4","Ipv6"]
	IPAddressesType *string `json:"ipAddressesType,omitempty"`

	// Subnet gateway of the vlan. This can be Ipv4 or Ipv6 gateway based on the IP addresses type.
	Gateway *string `json:"gateway,omitempty"`

	// IPv6 or IPv6 subnet in CIDR format i.e ip-address/prefix. Examples: IPv4 subnet'192.168.0.101/24', '10.10.1.32/27'. IPv6 subnet '3005:1231:2006:0025::0/96', 3005:1231:2006:0025::0/128
	Subnet *string `json:"subnet,omitempty"`

	// Tenant id to assign vlan to a tenant.
	TenantID *string `json:"tenantId,omitempty"`

	// Name of the Vlan.
	VlanName *string `json:"vlanName,omitempty"`

	// MTU of the vlan.
	Mtu *int32 `json:"mtu,omitempty"`

	// Vlan IP addresses, only one of ips or ipRanges parameters should be given.
	Ips []string `json:"ips"`

	// Vlan IP address ranges, only one of ips or ipRanges parameters should be given.
	IPRanges []*IPRange `json:"ipRanges"`

	// FQDN of the vlan.
	Fqdn *string `json:"fqdn,omitempty"`

	// IP pools from the vlan ip addresses, the IPs in a pool goes together. One IP from each pool forms a VIP group.
	IPPools []*IPPool `json:"ipPools"`

	// DNS delegation zones of the vlan.
	DNSDelegationZones []*DNSDelegationZone `json:"dnsDelegationZones"`
}

// Validate validates this update cluster vlan params
func (m *UpdateClusterVlanParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIPAddressesType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPRanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPPools(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSDelegationZones(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var updateClusterVlanParamsTypeIPAddressesTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Ipv4","Ipv6"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateClusterVlanParamsTypeIPAddressesTypePropEnum = append(updateClusterVlanParamsTypeIPAddressesTypePropEnum, v)
	}
}

const (

	// UpdateClusterVlanParamsIPAddressesTypeIPV4 captures enum value "Ipv4"
	UpdateClusterVlanParamsIPAddressesTypeIPV4 string = "Ipv4"

	// UpdateClusterVlanParamsIPAddressesTypeIPV6 captures enum value "Ipv6"
	UpdateClusterVlanParamsIPAddressesTypeIPV6 string = "Ipv6"
)

// prop value enum
func (m *UpdateClusterVlanParams) validateIPAddressesTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateClusterVlanParamsTypeIPAddressesTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateClusterVlanParams) validateIPAddressesType(formats strfmt.Registry) error {
	if swag.IsZero(m.IPAddressesType) { // not required
		return nil
	}

	// value enum
	if err := m.validateIPAddressesTypeEnum("ipAddressesType", "body", *m.IPAddressesType); err != nil {
		return err
	}

	return nil
}

func (m *UpdateClusterVlanParams) validateIPRanges(formats strfmt.Registry) error {
	if swag.IsZero(m.IPRanges) { // not required
		return nil
	}

	for i := 0; i < len(m.IPRanges); i++ {
		if swag.IsZero(m.IPRanges[i]) { // not required
			continue
		}

		if m.IPRanges[i] != nil {
			if err := m.IPRanges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ipRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ipRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateClusterVlanParams) validateIPPools(formats strfmt.Registry) error {
	if swag.IsZero(m.IPPools) { // not required
		return nil
	}

	for i := 0; i < len(m.IPPools); i++ {
		if swag.IsZero(m.IPPools[i]) { // not required
			continue
		}

		if m.IPPools[i] != nil {
			if err := m.IPPools[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ipPools" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ipPools" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateClusterVlanParams) validateDNSDelegationZones(formats strfmt.Registry) error {
	if swag.IsZero(m.DNSDelegationZones) { // not required
		return nil
	}

	for i := 0; i < len(m.DNSDelegationZones); i++ {
		if swag.IsZero(m.DNSDelegationZones[i]) { // not required
			continue
		}

		if m.DNSDelegationZones[i] != nil {
			if err := m.DNSDelegationZones[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dnsDelegationZones" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dnsDelegationZones" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this update cluster vlan params based on the context it is used
func (m *UpdateClusterVlanParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIPRanges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPPools(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDNSDelegationZones(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateClusterVlanParams) contextValidateIPRanges(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IPRanges); i++ {

		if m.IPRanges[i] != nil {

			if swag.IsZero(m.IPRanges[i]) { // not required
				return nil
			}

			if err := m.IPRanges[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ipRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ipRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateClusterVlanParams) contextValidateIPPools(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IPPools); i++ {

		if m.IPPools[i] != nil {

			if swag.IsZero(m.IPPools[i]) { // not required
				return nil
			}

			if err := m.IPPools[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ipPools" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ipPools" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateClusterVlanParams) contextValidateDNSDelegationZones(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DNSDelegationZones); i++ {

		if m.DNSDelegationZones[i] != nil {

			if swag.IsZero(m.DNSDelegationZones[i]) { // not required
				return nil
			}

			if err := m.DNSDelegationZones[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dnsDelegationZones" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dnsDelegationZones" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdateClusterVlanParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateClusterVlanParams) UnmarshalBinary(b []byte) error {
	var res UpdateClusterVlanParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
