// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// KubernetesSourceRegistrationParams Specifies the parameters to register a Kubernetes source.
//
// swagger:model KubernetesSourceRegistrationParams
type KubernetesSourceRegistrationParams struct {

	// Specifies the endpoint of Kubernetes source.
	// Required: true
	Endpoint *string `json:"endpoint"`

	// Specifies the bearer token or private key of Kubernetes source.
	// Required: true
	ClientPrivateKey *string `json:"clientPrivateKey"`

	// Specifies the distribution type of Kubernetes source.
	// Required: true
	// Enum: ["kOpenshift","kMainline","kVMwareTanzu","kRancher","kEKS","kGKE","kAKS","kIKS","kROKS"]
	KubernetesDistribution *string `json:"kubernetesDistribution"`

	// Specifies the datamover image location of Kubernetes source.
	// Required: true
	DataMoverImageLocation *string `json:"dataMoverImageLocation"`

	// Specifies the velero image location of the Kubernetes source.
	VeleroImageLocation *string `json:"veleroImageLocation,omitempty"`

	// Specifies the velero AWS plugin image location of the Kubernetes source.
	VeleroAwsPluginImageLocation *string `json:"veleroAwsPluginImageLocation,omitempty"`

	// Specifies the initial container image location of Kubernetes source.
	InitContainerImageLocation *string `json:"initContainerImageLocation,omitempty"`

	// Specifies the data mover service type of Kubernetes source.
	// Enum: ["kNodePort","kLoadBalancer","kClusterIp"]
	DatamoverServiceType *string `json:"datamoverServiceType,omitempty"`

	// Specifies the service annotation object of Kubernetes source.
	ServiceAnnotations []*KubernetesServiceAnnotationObject `json:"serviceAnnotations"`

	// Specifies the type of kubernetes source
	// Enum: ["kCluster","kNamespace","kService","kPVC","kPersistentVolumeClaim","kPersistentVolume","kLabel"]
	KubernetesType *string `json:"kubernetesType,omitempty"`

	// Specifies the velero open shift plugin image for the Kubernetes source.
	VeleroOpenshiftPluginImageLocation *string `json:"veleroOpenshiftPluginImageLocation,omitempty"`

	// Specifies the default VLAN parameters to be used for performing the
	// backup/restore of this entity.
	DefaultVlanParams *VlanParams `json:"defaultVlanParams,omitempty"`

	// Specifies VLAN information provided during registration.
	VlanInfoVec []*KubernetesVlanInfo `json:"vlanInfoVec"`

	// auto protect config
	AutoProtectConfig *KubernetesAutoProtectConfig `json:"autoProtectConfig,omitempty"`

	// Specifies resource label to be applied on cohesity resources.
	ResourceLabels []*KubernetesLabelObject `json:"resourceLabels"`

	// Specifies resource annotations to be applied on cohesity resources.
	ResourceAnnotations []*KubernetesLabelObject `json:"resourceAnnotations"`

	// Specifies the SAN field for agent certificate.
	SanFields []string `json:"sanFields"`

	// Specifies the priority class name for cohesity resources.
	PriorityClassName *string `json:"priorityClassName,omitempty"`
}

// Validate validates this kubernetes source registration params
func (m *KubernetesSourceRegistrationParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndpoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientPrivateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKubernetesDistribution(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataMoverImageLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatamoverServiceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceAnnotations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKubernetesType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultVlanParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlanInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoProtectConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceAnnotations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *KubernetesSourceRegistrationParams) validateEndpoint(formats strfmt.Registry) error {

	if err := validate.Required("endpoint", "body", m.Endpoint); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateClientPrivateKey(formats strfmt.Registry) error {

	if err := validate.Required("clientPrivateKey", "body", m.ClientPrivateKey); err != nil {
		return err
	}

	return nil
}

var kubernetesSourceRegistrationParamsTypeKubernetesDistributionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kOpenshift","kMainline","kVMwareTanzu","kRancher","kEKS","kGKE","kAKS","kIKS","kROKS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		kubernetesSourceRegistrationParamsTypeKubernetesDistributionPropEnum = append(kubernetesSourceRegistrationParamsTypeKubernetesDistributionPropEnum, v)
	}
}

const (

	// KubernetesSourceRegistrationParamsKubernetesDistributionKOpenshift captures enum value "kOpenshift"
	KubernetesSourceRegistrationParamsKubernetesDistributionKOpenshift string = "kOpenshift"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKMainline captures enum value "kMainline"
	KubernetesSourceRegistrationParamsKubernetesDistributionKMainline string = "kMainline"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKVMwareTanzu captures enum value "kVMwareTanzu"
	KubernetesSourceRegistrationParamsKubernetesDistributionKVMwareTanzu string = "kVMwareTanzu"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKRancher captures enum value "kRancher"
	KubernetesSourceRegistrationParamsKubernetesDistributionKRancher string = "kRancher"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKEKS captures enum value "kEKS"
	KubernetesSourceRegistrationParamsKubernetesDistributionKEKS string = "kEKS"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKGKE captures enum value "kGKE"
	KubernetesSourceRegistrationParamsKubernetesDistributionKGKE string = "kGKE"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKAKS captures enum value "kAKS"
	KubernetesSourceRegistrationParamsKubernetesDistributionKAKS string = "kAKS"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKIKS captures enum value "kIKS"
	KubernetesSourceRegistrationParamsKubernetesDistributionKIKS string = "kIKS"

	// KubernetesSourceRegistrationParamsKubernetesDistributionKROKS captures enum value "kROKS"
	KubernetesSourceRegistrationParamsKubernetesDistributionKROKS string = "kROKS"
)

// prop value enum
func (m *KubernetesSourceRegistrationParams) validateKubernetesDistributionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, kubernetesSourceRegistrationParamsTypeKubernetesDistributionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *KubernetesSourceRegistrationParams) validateKubernetesDistribution(formats strfmt.Registry) error {

	if err := validate.Required("kubernetesDistribution", "body", m.KubernetesDistribution); err != nil {
		return err
	}

	// value enum
	if err := m.validateKubernetesDistributionEnum("kubernetesDistribution", "body", *m.KubernetesDistribution); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateDataMoverImageLocation(formats strfmt.Registry) error {

	if err := validate.Required("dataMoverImageLocation", "body", m.DataMoverImageLocation); err != nil {
		return err
	}

	return nil
}

var kubernetesSourceRegistrationParamsTypeDatamoverServiceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNodePort","kLoadBalancer","kClusterIp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		kubernetesSourceRegistrationParamsTypeDatamoverServiceTypePropEnum = append(kubernetesSourceRegistrationParamsTypeDatamoverServiceTypePropEnum, v)
	}
}

const (

	// KubernetesSourceRegistrationParamsDatamoverServiceTypeKNodePort captures enum value "kNodePort"
	KubernetesSourceRegistrationParamsDatamoverServiceTypeKNodePort string = "kNodePort"

	// KubernetesSourceRegistrationParamsDatamoverServiceTypeKLoadBalancer captures enum value "kLoadBalancer"
	KubernetesSourceRegistrationParamsDatamoverServiceTypeKLoadBalancer string = "kLoadBalancer"

	// KubernetesSourceRegistrationParamsDatamoverServiceTypeKClusterIP captures enum value "kClusterIp"
	KubernetesSourceRegistrationParamsDatamoverServiceTypeKClusterIP string = "kClusterIp"
)

// prop value enum
func (m *KubernetesSourceRegistrationParams) validateDatamoverServiceTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, kubernetesSourceRegistrationParamsTypeDatamoverServiceTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *KubernetesSourceRegistrationParams) validateDatamoverServiceType(formats strfmt.Registry) error {
	if swag.IsZero(m.DatamoverServiceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDatamoverServiceTypeEnum("datamoverServiceType", "body", *m.DatamoverServiceType); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateServiceAnnotations(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceAnnotations) { // not required
		return nil
	}

	for i := 0; i < len(m.ServiceAnnotations); i++ {
		if swag.IsZero(m.ServiceAnnotations[i]) { // not required
			continue
		}

		if m.ServiceAnnotations[i] != nil {
			if err := m.ServiceAnnotations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var kubernetesSourceRegistrationParamsTypeKubernetesTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCluster","kNamespace","kService","kPVC","kPersistentVolumeClaim","kPersistentVolume","kLabel"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		kubernetesSourceRegistrationParamsTypeKubernetesTypePropEnum = append(kubernetesSourceRegistrationParamsTypeKubernetesTypePropEnum, v)
	}
}

const (

	// KubernetesSourceRegistrationParamsKubernetesTypeKCluster captures enum value "kCluster"
	KubernetesSourceRegistrationParamsKubernetesTypeKCluster string = "kCluster"

	// KubernetesSourceRegistrationParamsKubernetesTypeKNamespace captures enum value "kNamespace"
	KubernetesSourceRegistrationParamsKubernetesTypeKNamespace string = "kNamespace"

	// KubernetesSourceRegistrationParamsKubernetesTypeKService captures enum value "kService"
	KubernetesSourceRegistrationParamsKubernetesTypeKService string = "kService"

	// KubernetesSourceRegistrationParamsKubernetesTypeKPVC captures enum value "kPVC"
	KubernetesSourceRegistrationParamsKubernetesTypeKPVC string = "kPVC"

	// KubernetesSourceRegistrationParamsKubernetesTypeKPersistentVolumeClaim captures enum value "kPersistentVolumeClaim"
	KubernetesSourceRegistrationParamsKubernetesTypeKPersistentVolumeClaim string = "kPersistentVolumeClaim"

	// KubernetesSourceRegistrationParamsKubernetesTypeKPersistentVolume captures enum value "kPersistentVolume"
	KubernetesSourceRegistrationParamsKubernetesTypeKPersistentVolume string = "kPersistentVolume"

	// KubernetesSourceRegistrationParamsKubernetesTypeKLabel captures enum value "kLabel"
	KubernetesSourceRegistrationParamsKubernetesTypeKLabel string = "kLabel"
)

// prop value enum
func (m *KubernetesSourceRegistrationParams) validateKubernetesTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, kubernetesSourceRegistrationParamsTypeKubernetesTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *KubernetesSourceRegistrationParams) validateKubernetesType(formats strfmt.Registry) error {
	if swag.IsZero(m.KubernetesType) { // not required
		return nil
	}

	// value enum
	if err := m.validateKubernetesTypeEnum("kubernetesType", "body", *m.KubernetesType); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateDefaultVlanParams(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultVlanParams) { // not required
		return nil
	}

	if m.DefaultVlanParams != nil {
		if err := m.DefaultVlanParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultVlanParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultVlanParams")
			}
			return err
		}
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateVlanInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.VlanInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.VlanInfoVec); i++ {
		if swag.IsZero(m.VlanInfoVec[i]) { // not required
			continue
		}

		if m.VlanInfoVec[i] != nil {
			if err := m.VlanInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateAutoProtectConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoProtectConfig) { // not required
		return nil
	}

	if m.AutoProtectConfig != nil {
		if err := m.AutoProtectConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoProtectConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoProtectConfig")
			}
			return err
		}
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateResourceLabels(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceLabels) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceLabels); i++ {
		if swag.IsZero(m.ResourceLabels[i]) { // not required
			continue
		}

		if m.ResourceLabels[i] != nil {
			if err := m.ResourceLabels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceLabels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceLabels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) validateResourceAnnotations(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceAnnotations) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceAnnotations); i++ {
		if swag.IsZero(m.ResourceAnnotations[i]) { // not required
			continue
		}

		if m.ResourceAnnotations[i] != nil {
			if err := m.ResourceAnnotations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this kubernetes source registration params based on the context it is used
func (m *KubernetesSourceRegistrationParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateServiceAnnotations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultVlanParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVlanInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoProtectConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceAnnotations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *KubernetesSourceRegistrationParams) contextValidateServiceAnnotations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServiceAnnotations); i++ {

		if m.ServiceAnnotations[i] != nil {

			if swag.IsZero(m.ServiceAnnotations[i]) { // not required
				return nil
			}

			if err := m.ServiceAnnotations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) contextValidateDefaultVlanParams(ctx context.Context, formats strfmt.Registry) error {

	if m.DefaultVlanParams != nil {

		if swag.IsZero(m.DefaultVlanParams) { // not required
			return nil
		}

		if err := m.DefaultVlanParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultVlanParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultVlanParams")
			}
			return err
		}
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) contextValidateVlanInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VlanInfoVec); i++ {

		if m.VlanInfoVec[i] != nil {

			if swag.IsZero(m.VlanInfoVec[i]) { // not required
				return nil
			}

			if err := m.VlanInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) contextValidateAutoProtectConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoProtectConfig != nil {

		if swag.IsZero(m.AutoProtectConfig) { // not required
			return nil
		}

		if err := m.AutoProtectConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoProtectConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoProtectConfig")
			}
			return err
		}
	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) contextValidateResourceLabels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceLabels); i++ {

		if m.ResourceLabels[i] != nil {

			if swag.IsZero(m.ResourceLabels[i]) { // not required
				return nil
			}

			if err := m.ResourceLabels[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceLabels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceLabels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesSourceRegistrationParams) contextValidateResourceAnnotations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceAnnotations); i++ {

		if m.ResourceAnnotations[i] != nil {

			if swag.IsZero(m.ResourceAnnotations[i]) { // not required
				return nil
			}

			if err := m.ResourceAnnotations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resourceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resourceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *KubernetesSourceRegistrationParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *KubernetesSourceRegistrationParams) UnmarshalBinary(b []byte) error {
	var res KubernetesSourceRegistrationParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
