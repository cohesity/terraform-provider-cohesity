// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterUpradeParams Specifies the parameters to upgrade the software on the cluster.
//
// swagger:model ClusterUpradeParams
type ClusterUpradeParams struct {

	// The operation type. 'Upgrade' indicates to upgrade the software on the cluster. 'UploadPackageAndUpgrade' indicates to first upload the package using the url where package is hosted and then upgrade the cluster.
	// Required: true
	// Enum: ["Upgrade","UploadPackageAndUpgrade"]
	Type *string `json:"type"`

	// Version name of the package. Example: 6.3.1h_release-20210714_0fad884e. This is required when the operation type is 'Upgrade'
	VersionName string `json:"versionName,omitempty"`

	// The URL where the package is hosted. This is required when the operation type is 'UploadPackageAndUpgrade'
	URL string `json:"url,omitempty"`

	// Specifies if pre upgrade healthchecks failure will cause upgrade to be aborted. By default we abort upgrade if there are healthchecks failures .Cluster will stop the upgrade.and present the failures which need to be resolved before proceeding with upgrade. If set to false upgrade will not be aborted on healthchecks failure.
	AbortUpgradeOnChecksFailure *bool `json:"abortUpgradeOnChecksFailure,omitempty"`
}

// Validate validates this cluster uprade params
func (m *ClusterUpradeParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterUpradeParamsTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Upgrade","UploadPackageAndUpgrade"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterUpradeParamsTypeTypePropEnum = append(clusterUpradeParamsTypeTypePropEnum, v)
	}
}

const (

	// ClusterUpradeParamsTypeUpgrade captures enum value "Upgrade"
	ClusterUpradeParamsTypeUpgrade string = "Upgrade"

	// ClusterUpradeParamsTypeUploadPackageAndUpgrade captures enum value "UploadPackageAndUpgrade"
	ClusterUpradeParamsTypeUploadPackageAndUpgrade string = "UploadPackageAndUpgrade"
)

// prop value enum
func (m *ClusterUpradeParams) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterUpradeParamsTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterUpradeParams) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cluster uprade params based on context it is used
func (m *ClusterUpradeParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ClusterUpradeParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterUpradeParams) UnmarshalBinary(b []byte) error {
	var res ClusterUpradeParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
