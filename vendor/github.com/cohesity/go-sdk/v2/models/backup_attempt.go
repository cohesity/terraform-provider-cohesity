// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BackupAttempt Attempt information for an object.
//
// Specifies a backup attempt for an object.
//
// swagger:model BackupAttempt
type BackupAttempt struct {

	// Specifies the start time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the time at which the backup task was admitted to run in Unix epoch Timestamp(in microseconds) for an object.
	AdmittedTimeUsecs *int64 `json:"admittedTimeUsecs,omitempty"`

	// Specifies the time when gatekeeper permit is granted to the backup task. If the backup task is rescheduled due to errors, the field is updated to the time when permit is granted again.
	PermitGrantTimeUsecs *int64 `json:"permitGrantTimeUsecs,omitempty"`

	// Specifies the duration between the startTime and when gatekeeper permit is granted to the backup task. If the backup task is rescheduled due to errors, the field is updated considering the time when permit is granted again. Queue duration = PermitGrantTimeUsecs - StartTimeUsecs
	QueueDurationUsecs *int64 `json:"queueDurationUsecs,omitempty"`

	// Specifies the time at which the source snapshot was taken in Unix epoch Timestamp(in microseconds) for an object.
	SnapshotCreationTimeUsecs *int64 `json:"snapshotCreationTimeUsecs,omitempty"`

	// Status of the attempt for an object. 'Running' indicates that the run is still running. 'Canceled' indicates that the run has been canceled. 'Canceling' indicates that the run is in the process of being canceled. 'Paused' indicates that the ongoing run has been paused. 'Pausing' indicates that the ongoing run is in the process of being paused. 'Resuming' indicates that the already paused run is in the process of being running again. 'Failed' indicates that the run has failed. 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening. 'Succeeded' indicates that the run has finished successfully. 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages. 'Skipped' indicates that the run was skipped.
	// Enum: ["Accepted","Running","Canceled","Canceling","Failed","Missed","Succeeded","SucceededWithWarning","OnHold","Finalizing","Skipped","LegalHold","Paused"]
	Status *string `json:"status,omitempty"`

	// Statistics about backup data for an object.
	Stats *BackupDataStats `json:"stats,omitempty"`

	// Progress monitor task for an object..
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// A message about the error if encountered while performing backup.
	Message *string `json:"message,omitempty"`
}

// Validate validates this backup attempt
func (m *BackupAttempt) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var backupAttemptTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Accepted","Running","Canceled","Canceling","Failed","Missed","Succeeded","SucceededWithWarning","OnHold","Finalizing","Skipped","LegalHold","Paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupAttemptTypeStatusPropEnum = append(backupAttemptTypeStatusPropEnum, v)
	}
}

const (

	// BackupAttemptStatusAccepted captures enum value "Accepted"
	BackupAttemptStatusAccepted string = "Accepted"

	// BackupAttemptStatusRunning captures enum value "Running"
	BackupAttemptStatusRunning string = "Running"

	// BackupAttemptStatusCanceled captures enum value "Canceled"
	BackupAttemptStatusCanceled string = "Canceled"

	// BackupAttemptStatusCanceling captures enum value "Canceling"
	BackupAttemptStatusCanceling string = "Canceling"

	// BackupAttemptStatusFailed captures enum value "Failed"
	BackupAttemptStatusFailed string = "Failed"

	// BackupAttemptStatusMissed captures enum value "Missed"
	BackupAttemptStatusMissed string = "Missed"

	// BackupAttemptStatusSucceeded captures enum value "Succeeded"
	BackupAttemptStatusSucceeded string = "Succeeded"

	// BackupAttemptStatusSucceededWithWarning captures enum value "SucceededWithWarning"
	BackupAttemptStatusSucceededWithWarning string = "SucceededWithWarning"

	// BackupAttemptStatusOnHold captures enum value "OnHold"
	BackupAttemptStatusOnHold string = "OnHold"

	// BackupAttemptStatusFinalizing captures enum value "Finalizing"
	BackupAttemptStatusFinalizing string = "Finalizing"

	// BackupAttemptStatusSkipped captures enum value "Skipped"
	BackupAttemptStatusSkipped string = "Skipped"

	// BackupAttemptStatusLegalHold captures enum value "LegalHold"
	BackupAttemptStatusLegalHold string = "LegalHold"

	// BackupAttemptStatusPaused captures enum value "Paused"
	BackupAttemptStatusPaused string = "Paused"
)

// prop value enum
func (m *BackupAttempt) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupAttemptTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupAttempt) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *BackupAttempt) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup attempt based on the context it is used
func (m *BackupAttempt) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupAttempt) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if swag.IsZero(m.Stats) { // not required
			return nil
		}

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupAttempt) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupAttempt) UnmarshalBinary(b []byte) error {
	var res BackupAttempt
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
