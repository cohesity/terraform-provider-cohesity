// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SnapshotInfo Snapshot information for an object.
//
// Snapshot info for an object.
//
// swagger:model SnapshotInfo
type SnapshotInfo struct {

	// Snapshot id for a successful snapshot. This field will not be set if the Protection Group Run has no successful attempt.
	SnapshotID *string `json:"snapshotId,omitempty"`

	// Status of snapshot.
	// Enum: ["kInProgress","kSuccessful","kFailed","kWaitingForNextAttempt","kWarning","kCurrentAttemptPaused","kCurrentAttemptResuming","kCurrentAttemptPausing","kWaitingForOlderBackupRun","kSkipped"]
	Status *string `json:"status,omitempty"`

	// A message decribing the status. This will be populated currently only for kWaitingForOlderBackupRun status.
	StatusMessage *string `json:"statusMessage,omitempty"`

	// Specifies the start time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the end time of attempt in Unix epoch Timestamp(in microseconds) for an object.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the time at which the backup task was admitted to run in Unix epoch Timestamp(in microseconds) for an object.
	AdmittedTimeUsecs *int64 `json:"admittedTimeUsecs,omitempty"`

	// Specifies the time when gatekeeper permit is granted to the backup task. If the backup task is rescheduled due to errors, the field is updated to the time when permit is granted again.
	PermitGrantTimeUsecs *int64 `json:"permitGrantTimeUsecs,omitempty"`

	// Specifies the duration between the startTime and when gatekeeper permit is granted to the backup task. If the backup task is rescheduled due to errors, the field is updated considering the time when permit is granted again. Queue duration = PermitGrantTimeUsecs - StartTimeUsecs
	QueueDurationUsecs *int64 `json:"queueDurationUsecs,omitempty"`

	// Specifies the time at which the source snapshot was taken in Unix epoch Timestamp(in microseconds) for an object.
	SnapshotCreationTimeUsecs *int64 `json:"snapshotCreationTimeUsecs,omitempty"`

	// Statistics about backup data for an object.
	Stats *BackupDataStats `json:"stats,omitempty"`

	// Progress monitor task for backup of the object.
	ProgressTaskID *string `json:"progressTaskId,omitempty"`

	// Progress monitor task for the indexing of documents in an object.
	IndexingTaskID *string `json:"indexingTaskId,omitempty"`

	// Stats task for an object.
	StatsTaskID *string `json:"statsTaskId,omitempty"`

	// Specifies a list of warning messages.
	Warnings []string `json:"warnings"`

	// Specifies whether the snapshot is deleted manually.
	IsManuallyDeleted *bool `json:"isManuallyDeleted,omitempty"`

	// Specifies the expiry time of attempt in Unix epoch Timestamp (in microseconds) for an object.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// The total number of file and directory entities visited in this backup. Only applicable to file based backups.
	TotalFileCount *int64 `json:"totalFileCount,omitempty"`

	// The total number of file and directory entities that are backed up in this run. Only applicable to file based backups.
	BackupFileCount *int64 `json:"backupFileCount,omitempty"`

	// Specifies the dataLock constraints for the snapshot info.
	DataLockConstraints *DataLockConstraints `json:"dataLockConstraints,omitempty"`
}

// Validate validates this snapshot info
func (m *SnapshotInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLockConstraints(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var snapshotInfoTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kInProgress","kSuccessful","kFailed","kWaitingForNextAttempt","kWarning","kCurrentAttemptPaused","kCurrentAttemptResuming","kCurrentAttemptPausing","kWaitingForOlderBackupRun","kSkipped"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		snapshotInfoTypeStatusPropEnum = append(snapshotInfoTypeStatusPropEnum, v)
	}
}

const (

	// SnapshotInfoStatusKInProgress captures enum value "kInProgress"
	SnapshotInfoStatusKInProgress string = "kInProgress"

	// SnapshotInfoStatusKSuccessful captures enum value "kSuccessful"
	SnapshotInfoStatusKSuccessful string = "kSuccessful"

	// SnapshotInfoStatusKFailed captures enum value "kFailed"
	SnapshotInfoStatusKFailed string = "kFailed"

	// SnapshotInfoStatusKWaitingForNextAttempt captures enum value "kWaitingForNextAttempt"
	SnapshotInfoStatusKWaitingForNextAttempt string = "kWaitingForNextAttempt"

	// SnapshotInfoStatusKWarning captures enum value "kWarning"
	SnapshotInfoStatusKWarning string = "kWarning"

	// SnapshotInfoStatusKCurrentAttemptPaused captures enum value "kCurrentAttemptPaused"
	SnapshotInfoStatusKCurrentAttemptPaused string = "kCurrentAttemptPaused"

	// SnapshotInfoStatusKCurrentAttemptResuming captures enum value "kCurrentAttemptResuming"
	SnapshotInfoStatusKCurrentAttemptResuming string = "kCurrentAttemptResuming"

	// SnapshotInfoStatusKCurrentAttemptPausing captures enum value "kCurrentAttemptPausing"
	SnapshotInfoStatusKCurrentAttemptPausing string = "kCurrentAttemptPausing"

	// SnapshotInfoStatusKWaitingForOlderBackupRun captures enum value "kWaitingForOlderBackupRun"
	SnapshotInfoStatusKWaitingForOlderBackupRun string = "kWaitingForOlderBackupRun"

	// SnapshotInfoStatusKSkipped captures enum value "kSkipped"
	SnapshotInfoStatusKSkipped string = "kSkipped"
)

// prop value enum
func (m *SnapshotInfo) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, snapshotInfoTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SnapshotInfo) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotInfo) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *SnapshotInfo) validateDataLockConstraints(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLockConstraints) { // not required
		return nil
	}

	if m.DataLockConstraints != nil {
		if err := m.DataLockConstraints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConstraints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConstraints")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this snapshot info based on the context it is used
func (m *SnapshotInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataLockConstraints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapshotInfo) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if swag.IsZero(m.Stats) { // not required
			return nil
		}

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *SnapshotInfo) contextValidateDataLockConstraints(ctx context.Context, formats strfmt.Registry) error {

	if m.DataLockConstraints != nil {

		if swag.IsZero(m.DataLockConstraints) { // not required
			return nil
		}

		if err := m.DataLockConstraints.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConstraints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConstraints")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapshotInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapshotInfo) UnmarshalBinary(b []byte) error {
	var res SnapshotInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
