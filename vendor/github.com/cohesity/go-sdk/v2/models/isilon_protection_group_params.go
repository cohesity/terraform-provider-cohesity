// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IsilonProtectionGroupParams Specifies the parameters which are specific to Isilon related Protection Groups.
//
// swagger:model IsilonProtectionGroupParams
type IsilonProtectionGroupParams struct {

	// Specifies the objects to be included in the Protection Group.
	// Required: true
	// Min Items: 1
	// Unique: true
	Objects []*IsilonProtectionGroupObjectParams `json:"objects"`

	// Specifies whether or not to store the snapshots in this run directly in an Archive Target instead of on the Cluster. If this is set to true, the associated policy must have exactly one Archive Target associated with it and the policy must be set up to archive after every run. Also, a Storage Domain cannot be specified. Default behavior is 'false'.
	DirectCloudArchive *bool `json:"directCloudArchive,omitempty"`

	// Specifies whether or not to enable native format for direct archive job. This field is set to true if native format should be used for archiving.
	NativeFormat *bool `json:"nativeFormat,omitempty"`

	// Specifies the fields required to enable indexing of the protected objects such as files and directories.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies the preferred protocol to use if this device supports multiple protocols.
	// Enum: ["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]
	Protocol *string `json:"protocol,omitempty"`

	// Specifies whether or not the Protection Group should continue regardless of whether or not an error was encountered during protection group run.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Specifies whether the protection group should use encryption while backup or not.
	EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

	// Optional config that enables file locking for this view. It cannot be disabled during the edit of a view, if it has been enabled during the creation of the view. Also, it cannot be enabled if it was disabled during the creation of the view.
	FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

	// Specifies file paths to include or exclude.
	FileFilters *FileFilteringPolicy `json:"fileFilters,omitempty"`

	// Specify whether to use the Isilon Changelist API to directly discover changed files/directories for faster incremental backup. Cohesity will keep an extra snapshot which will be deleted by the next successful backup.
	UseChangelist *bool `json:"useChangelist,omitempty"`

	// Specifies the id of the parent of the objects.
	// Read Only: true
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies the name of the parent of the objects.
	// Read Only: true
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the pre script and post script to run before and after the protection group.
	PrePostScript *HostBasedBackupScriptParams `json:"prePostScript,omitempty"`

	// Specifies the source snapshots to be taken even if there is a pending run in a protection group.
	ContinuousSnapshots *ContinuousSnapshotParams `json:"continuousSnapshots,omitempty"`

	// Specifies the list of IP addresses that are allowed or denied at the job level. Allowed IPs and Denied IPs cannot be used together.
	FilterIPConfig *FilterIPConfig `json:"filterIpConfig,omitempty"`

	// Specifies the source throttling parameters to be used during full or incremental backup of the NAS source.
	ThrottlingConfig *NasThrottlingConfig `json:"throttlingConfig,omitempty"`

	// Specifies if the Isilon source permissions should be modified internally to allow backups.
	ModifySourcePermissions *bool `json:"modifySourcePermissions,omitempty"`
}

// Validate validates this isilon protection group params
func (m *IsilonProtectionGroupParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateObjects(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileLockConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrePostScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContinuousSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilterIPConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThrottlingConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IsilonProtectionGroupParams) validateObjects(formats strfmt.Registry) error {

	if err := validate.Required("objects", "body", m.Objects); err != nil {
		return err
	}

	iObjectsSize := int64(len(m.Objects))

	if err := validate.MinItems("objects", "body", iObjectsSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("objects", "body", m.Objects); err != nil {
		return err
	}

	for i := 0; i < len(m.Objects); i++ {
		if swag.IsZero(m.Objects[i]) { // not required
			continue
		}

		if m.Objects[i] != nil {
			if err := m.Objects[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IsilonProtectionGroupParams) validateIndexingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IndexingPolicy) { // not required
		return nil
	}

	if m.IndexingPolicy != nil {
		if err := m.IndexingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

var isilonProtectionGroupParamsTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		isilonProtectionGroupParamsTypeProtocolPropEnum = append(isilonProtectionGroupParamsTypeProtocolPropEnum, v)
	}
}

const (

	// IsilonProtectionGroupParamsProtocolKNoProtocol captures enum value "kNoProtocol"
	IsilonProtectionGroupParamsProtocolKNoProtocol string = "kNoProtocol"

	// IsilonProtectionGroupParamsProtocolKNfs3 captures enum value "kNfs3"
	IsilonProtectionGroupParamsProtocolKNfs3 string = "kNfs3"

	// IsilonProtectionGroupParamsProtocolKNfs41 captures enum value "kNfs4_1"
	IsilonProtectionGroupParamsProtocolKNfs41 string = "kNfs4_1"

	// IsilonProtectionGroupParamsProtocolKCifs1 captures enum value "kCifs1"
	IsilonProtectionGroupParamsProtocolKCifs1 string = "kCifs1"

	// IsilonProtectionGroupParamsProtocolKCifs2 captures enum value "kCifs2"
	IsilonProtectionGroupParamsProtocolKCifs2 string = "kCifs2"

	// IsilonProtectionGroupParamsProtocolKCifs3 captures enum value "kCifs3"
	IsilonProtectionGroupParamsProtocolKCifs3 string = "kCifs3"
)

// prop value enum
func (m *IsilonProtectionGroupParams) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, isilonProtectionGroupParamsTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *IsilonProtectionGroupParams) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *IsilonProtectionGroupParams) validateFileLockConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FileLockConfig) { // not required
		return nil
	}

	if m.FileLockConfig != nil {
		if err := m.FileLockConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) validateFileFilters(formats strfmt.Registry) error {
	if swag.IsZero(m.FileFilters) { // not required
		return nil
	}

	if m.FileFilters != nil {
		if err := m.FileFilters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileFilters")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) validatePrePostScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PrePostScript) { // not required
		return nil
	}

	if m.PrePostScript != nil {
		if err := m.PrePostScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prePostScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("prePostScript")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) validateContinuousSnapshots(formats strfmt.Registry) error {
	if swag.IsZero(m.ContinuousSnapshots) { // not required
		return nil
	}

	if m.ContinuousSnapshots != nil {
		if err := m.ContinuousSnapshots.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("continuousSnapshots")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("continuousSnapshots")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) validateFilterIPConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FilterIPConfig) { // not required
		return nil
	}

	if m.FilterIPConfig != nil {
		if err := m.FilterIPConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) validateThrottlingConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ThrottlingConfig) { // not required
		return nil
	}

	if m.ThrottlingConfig != nil {
		if err := m.ThrottlingConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this isilon protection group params based on the context it is used
func (m *IsilonProtectionGroupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateObjects(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIndexingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileLockConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrePostScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContinuousSnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilterIPConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThrottlingConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateObjects(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Objects); i++ {

		if m.Objects[i] != nil {

			if swag.IsZero(m.Objects[i]) { // not required
				return nil
			}

			if err := m.Objects[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateIndexingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.IndexingPolicy != nil {

		if swag.IsZero(m.IndexingPolicy) { // not required
			return nil
		}

		if err := m.IndexingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateFileLockConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FileLockConfig != nil {

		if swag.IsZero(m.FileLockConfig) { // not required
			return nil
		}

		if err := m.FileLockConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateFileFilters(ctx context.Context, formats strfmt.Registry) error {

	if m.FileFilters != nil {

		if swag.IsZero(m.FileFilters) { // not required
			return nil
		}

		if err := m.FileFilters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileFilters")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateSourceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceId", "body", m.SourceID); err != nil {
		return err
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateSourceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceName", "body", m.SourceName); err != nil {
		return err
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidatePrePostScript(ctx context.Context, formats strfmt.Registry) error {

	if m.PrePostScript != nil {

		if swag.IsZero(m.PrePostScript) { // not required
			return nil
		}

		if err := m.PrePostScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prePostScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("prePostScript")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateContinuousSnapshots(ctx context.Context, formats strfmt.Registry) error {

	if m.ContinuousSnapshots != nil {

		if swag.IsZero(m.ContinuousSnapshots) { // not required
			return nil
		}

		if err := m.ContinuousSnapshots.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("continuousSnapshots")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("continuousSnapshots")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateFilterIPConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FilterIPConfig != nil {

		if swag.IsZero(m.FilterIPConfig) { // not required
			return nil
		}

		if err := m.FilterIPConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *IsilonProtectionGroupParams) contextValidateThrottlingConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ThrottlingConfig != nil {

		if swag.IsZero(m.ThrottlingConfig) { // not required
			return nil
		}

		if err := m.ThrottlingConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IsilonProtectionGroupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IsilonProtectionGroupParams) UnmarshalBinary(b []byte) error {
	var res IsilonProtectionGroupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
