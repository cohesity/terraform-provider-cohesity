// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HyperVProtectionGroupParams HyperV Protection Group Request Params.
//
// Specifies the parameters which are specific to HyperV related Protection Groups.
//
// swagger:model HyperVProtectionGroupParams
type HyperVProtectionGroupParams struct {

	// Specifies the Protection Group type. If not specified, then backup method is auto determined. Specifying RCT will forcibly use RCT backup for all VMs in this Protection Group. Available only for VMs with hardware version 8.0 and above, but is more efficient. Specifying VSS will forcibly use VSS backup for all VMs in this Protection Group. Available for VMs with hardware version 5.0 and above, but is slower than RCT backup.
	// Enum: ["kAuto","kRCT","kVSS"]
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies the objects to be included in the Protection Group.
	// Unique: true
	Objects []*HyperVProtectionGroupObjectParams `json:"objects"`

	// Specifies the list of IDs of the objects to not be protected by this Protection Group. This can be used to ignore specific objects under a parent object which has been included for protection.
	ExcludeObjectIds []*int64 `json:"excludeObjectIds"`

	// Array of Array of VM Tag Ids that Specify VMs to Protect. Optionally specify a list of VMs to protect by listing Protection Source ids of VM Tags in this two dimensional array. Using this two dimensional array of Tag ids, the Cluster generates a list of VMs to protect which are derived from intersections of the inner arrays and union of the outer array, as shown by the following example. To protect only 'Eng' VMs in the East and all the VMs in the West, specify the following tag id array: [ [1101, 2221], [3031] ], where 1101 is the 'Eng' VM Tag id, 2221 is the 'East' VM Tag id and 3031 is the 'West' VM Tag id. The inner array [1101, 2221] produces a list of VMs that are both tagged with 'Eng' and 'East' (an intersection). The outer array combines the list from the inner array with list of VMs tagged with 'West' (a union). The list of resulting VMs are protected by this Protection Group.
	VMTagIds [][]int64 `json:"vmTagIds"`

	// Array of Arrays of VM Tag Ids that Specify VMs to Exclude. Optionally specify a list of VMs to exclude from protecting by listing Protection Source ids of VM Tags in this two dimensional array. Using this two dimensional array of Tag ids, the Cluster generates a list of VMs to exclude from protecting, which are derived from intersections of the inner arrays and union of the outer array, as shown by the following example. For example a Datacenter is selected to be protected but you want to exclude all the 'Former Employees' VMs in the East and West but keep all the VMs for 'Former Employees' in the South which are also stored in this Datacenter, by specifying the following tag id array: [ [1000, 2221], [1000, 3031] ], where 1000 is the 'Former Employee' VM Tag id, 2221 is the 'East' VM Tag id and 3031 is the 'West' VM Tag id. The first inner array [1000, 2221] produces a list of VMs that are both tagged with 'Former Employees' and 'East' (an intersection). The second inner array [1000, 3031] produces a list of VMs that are both tagged with 'Former Employees' and 'West' (an intersection). The outer array combines the list of VMs from the two inner arrays. The list of resulting VMs are excluded from being protected this Job.
	ExcludeVMTagIds [][]int64 `json:"excludeVmTagIds"`

	// Specifies whether or not to move the workload to the cloud.
	CloudMigration *bool `json:"cloudMigration,omitempty"`

	// Specifies the id of the parent of the objects.
	// Read Only: true
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies the name of the parent of the objects.
	// Read Only: true
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies a global list of disks to be excluded for the all the VMs part of the protection group.
	GlobalExcludeDisks []*HyperVDiskInfo `json:"globalExcludeDisks"`

	// Specifies a global list of disks to be included for the all the VMs part of the protection group.
	GlobalIncludeDisks []*HyperVDiskInfo `json:"globalIncludeDisks"`

	CommonHyperVProtectionParams
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *HyperVProtectionGroupParams) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		ProtectionType *string `json:"protectionType,omitempty"`

		Objects []*HyperVProtectionGroupObjectParams `json:"objects"`

		ExcludeObjectIds []*int64 `json:"excludeObjectIds"`

		VMTagIds [][]int64 `json:"vmTagIds"`

		ExcludeVMTagIds [][]int64 `json:"excludeVmTagIds"`

		CloudMigration *bool `json:"cloudMigration,omitempty"`

		SourceID *int64 `json:"sourceId,omitempty"`

		SourceName *string `json:"sourceName,omitempty"`

		GlobalExcludeDisks []*HyperVDiskInfo `json:"globalExcludeDisks"`

		GlobalIncludeDisks []*HyperVDiskInfo `json:"globalIncludeDisks"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.ProtectionType = dataAO0.ProtectionType

	m.Objects = dataAO0.Objects

	m.ExcludeObjectIds = dataAO0.ExcludeObjectIds

	m.VMTagIds = dataAO0.VMTagIds

	m.ExcludeVMTagIds = dataAO0.ExcludeVMTagIds

	m.CloudMigration = dataAO0.CloudMigration

	m.SourceID = dataAO0.SourceID

	m.SourceName = dataAO0.SourceName

	m.GlobalExcludeDisks = dataAO0.GlobalExcludeDisks

	m.GlobalIncludeDisks = dataAO0.GlobalIncludeDisks

	// AO1
	var aO1 CommonHyperVProtectionParams
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.CommonHyperVProtectionParams = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m HyperVProtectionGroupParams) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		ProtectionType *string `json:"protectionType,omitempty"`

		Objects []*HyperVProtectionGroupObjectParams `json:"objects"`

		ExcludeObjectIds []*int64 `json:"excludeObjectIds"`

		VMTagIds [][]int64 `json:"vmTagIds"`

		ExcludeVMTagIds [][]int64 `json:"excludeVmTagIds"`

		CloudMigration *bool `json:"cloudMigration,omitempty"`

		SourceID *int64 `json:"sourceId,omitempty"`

		SourceName *string `json:"sourceName,omitempty"`

		GlobalExcludeDisks []*HyperVDiskInfo `json:"globalExcludeDisks"`

		GlobalIncludeDisks []*HyperVDiskInfo `json:"globalIncludeDisks"`
	}

	dataAO0.ProtectionType = m.ProtectionType

	dataAO0.Objects = m.Objects

	dataAO0.ExcludeObjectIds = m.ExcludeObjectIds

	dataAO0.VMTagIds = m.VMTagIds

	dataAO0.ExcludeVMTagIds = m.ExcludeVMTagIds

	dataAO0.CloudMigration = m.CloudMigration

	dataAO0.SourceID = m.SourceID

	dataAO0.SourceName = m.SourceName

	dataAO0.GlobalExcludeDisks = m.GlobalExcludeDisks

	dataAO0.GlobalIncludeDisks = m.GlobalIncludeDisks

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.CommonHyperVProtectionParams)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this hyper v protection group params
func (m *HyperVProtectionGroupParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjects(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalExcludeDisks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalIncludeDisks(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with CommonHyperVProtectionParams
	if err := m.CommonHyperVProtectionParams.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var hyperVProtectionGroupParamsTypeProtectionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAuto","kRCT","kVSS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hyperVProtectionGroupParamsTypeProtectionTypePropEnum = append(hyperVProtectionGroupParamsTypeProtectionTypePropEnum, v)
	}
}

// property enum
func (m *HyperVProtectionGroupParams) validateProtectionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, hyperVProtectionGroupParamsTypeProtectionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HyperVProtectionGroupParams) validateProtectionType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionTypeEnum("protectionType", "body", *m.ProtectionType); err != nil {
		return err
	}

	return nil
}

func (m *HyperVProtectionGroupParams) validateObjects(formats strfmt.Registry) error {

	if swag.IsZero(m.Objects) { // not required
		return nil
	}

	if err := validate.UniqueItems("objects", "body", m.Objects); err != nil {
		return err
	}

	for i := 0; i < len(m.Objects); i++ {
		if swag.IsZero(m.Objects[i]) { // not required
			continue
		}

		if m.Objects[i] != nil {
			if err := m.Objects[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HyperVProtectionGroupParams) validateGlobalExcludeDisks(formats strfmt.Registry) error {

	if swag.IsZero(m.GlobalExcludeDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.GlobalExcludeDisks); i++ {
		if swag.IsZero(m.GlobalExcludeDisks[i]) { // not required
			continue
		}

		if m.GlobalExcludeDisks[i] != nil {
			if err := m.GlobalExcludeDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HyperVProtectionGroupParams) validateGlobalIncludeDisks(formats strfmt.Registry) error {

	if swag.IsZero(m.GlobalIncludeDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.GlobalIncludeDisks); i++ {
		if swag.IsZero(m.GlobalIncludeDisks[i]) { // not required
			continue
		}

		if m.GlobalIncludeDisks[i] != nil {
			if err := m.GlobalIncludeDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this hyper v protection group params based on the context it is used
func (m *HyperVProtectionGroupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateObjects(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlobalExcludeDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlobalIncludeDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with CommonHyperVProtectionParams
	if err := m.CommonHyperVProtectionParams.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HyperVProtectionGroupParams) contextValidateObjects(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Objects); i++ {

		if m.Objects[i] != nil {

			if swag.IsZero(m.Objects[i]) { // not required
				return nil
			}

			if err := m.Objects[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HyperVProtectionGroupParams) contextValidateSourceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceId", "body", m.SourceID); err != nil {
		return err
	}

	return nil
}

func (m *HyperVProtectionGroupParams) contextValidateSourceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceName", "body", m.SourceName); err != nil {
		return err
	}

	return nil
}

func (m *HyperVProtectionGroupParams) contextValidateGlobalExcludeDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GlobalExcludeDisks); i++ {

		if m.GlobalExcludeDisks[i] != nil {

			if swag.IsZero(m.GlobalExcludeDisks[i]) { // not required
				return nil
			}

			if err := m.GlobalExcludeDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalExcludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HyperVProtectionGroupParams) contextValidateGlobalIncludeDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GlobalIncludeDisks); i++ {

		if m.GlobalIncludeDisks[i] != nil {

			if swag.IsZero(m.GlobalIncludeDisks[i]) { // not required
				return nil
			}

			if err := m.GlobalIncludeDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("globalIncludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *HyperVProtectionGroupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HyperVProtectionGroupParams) UnmarshalBinary(b []byte) error {
	var res HyperVProtectionGroupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
