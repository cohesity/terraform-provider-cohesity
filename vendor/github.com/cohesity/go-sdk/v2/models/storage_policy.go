// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StoragePolicy Storage Policy
//
// Specifies the storage policy of a Storage Domain.
//
// swagger:model StoragePolicy
type StoragePolicy struct {

	// Specifies the time in seconds when deduplication and compression of the Storage Domain starts.
	DeduplicationCompressionDelaySecs *int32 `json:"deduplicationCompressionDelaySecs,omitempty"`

	// Specifies the encryption type for a Storage Domain.
	// Enum: ["None","Strong","Weak"]
	EncryptionType *string `json:"encryptionType,omitempty"`

	// Specifies the encryption mode for a Storage Domain.
	// Enum: ["CBC","GCM"]
	AesEncryptionMode *string `json:"aesEncryptionMode,omitempty"`

	// Specifies the vault id assigned for cloud spill for a Storage Domain.
	CloudSpillVaultID *int64 `json:"cloudSpillVaultId,omitempty"`

	// Specifies the number of disk failures to tolerate for a Storage Domain. By default, this field is 1 for cluster with three or more nodes. If erasure coding is enabled, this field will be the same as numCodedStripes.
	NumDiskFailuresTolerated *int32 `json:"numDiskFailuresTolerated,omitempty"`

	// Specifies the number of node failures to tolerate for a Storage Domain. By default this field is replication factor minus 1 for replication chunk files and is the same as numCodedStripes for erasure coding chunk files.
	NumNodeFailuresTolerated *int32 `json:"numNodeFailuresTolerated,omitempty"`

	// Specifies whether app marker detection is enabled. When enabled, app markers will be removed from data and put in separate chunks.
	AppMarkerDetectionEnabled *bool `json:"appMarkerDetectionEnabled,omitempty"`

	// Specifies compression settings for a Storage Domain.
	CompressionParams *CompressionParams `json:"compressionParams,omitempty"`

	// Specifies deduplication settings for a Storage Domain.
	DeduplicationParams *DeduplicationParams `json:"deduplicationParams,omitempty"`

	// Specifies the erasure coding parameters for a Storage Domain.
	ErasureCodingParams *ErasureCodingParams `json:"erasureCodingParams,omitempty"`
}

// Validate validates this storage policy
func (m *StoragePolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEncryptionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAesEncryptionMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompressionParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeduplicationParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErasureCodingParams(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var storagePolicyTypeEncryptionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Strong","Weak"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storagePolicyTypeEncryptionTypePropEnum = append(storagePolicyTypeEncryptionTypePropEnum, v)
	}
}

const (

	// StoragePolicyEncryptionTypeNone captures enum value "None"
	StoragePolicyEncryptionTypeNone string = "None"

	// StoragePolicyEncryptionTypeStrong captures enum value "Strong"
	StoragePolicyEncryptionTypeStrong string = "Strong"

	// StoragePolicyEncryptionTypeWeak captures enum value "Weak"
	StoragePolicyEncryptionTypeWeak string = "Weak"
)

// prop value enum
func (m *StoragePolicy) validateEncryptionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storagePolicyTypeEncryptionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *StoragePolicy) validateEncryptionType(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateEncryptionTypeEnum("encryptionType", "body", *m.EncryptionType); err != nil {
		return err
	}

	return nil
}

var storagePolicyTypeAesEncryptionModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CBC","GCM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storagePolicyTypeAesEncryptionModePropEnum = append(storagePolicyTypeAesEncryptionModePropEnum, v)
	}
}

const (

	// StoragePolicyAesEncryptionModeCBC captures enum value "CBC"
	StoragePolicyAesEncryptionModeCBC string = "CBC"

	// StoragePolicyAesEncryptionModeGCM captures enum value "GCM"
	StoragePolicyAesEncryptionModeGCM string = "GCM"
)

// prop value enum
func (m *StoragePolicy) validateAesEncryptionModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storagePolicyTypeAesEncryptionModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *StoragePolicy) validateAesEncryptionMode(formats strfmt.Registry) error {
	if swag.IsZero(m.AesEncryptionMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateAesEncryptionModeEnum("aesEncryptionMode", "body", *m.AesEncryptionMode); err != nil {
		return err
	}

	return nil
}

func (m *StoragePolicy) validateCompressionParams(formats strfmt.Registry) error {
	if swag.IsZero(m.CompressionParams) { // not required
		return nil
	}

	if m.CompressionParams != nil {
		if err := m.CompressionParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("compressionParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("compressionParams")
			}
			return err
		}
	}

	return nil
}

func (m *StoragePolicy) validateDeduplicationParams(formats strfmt.Registry) error {
	if swag.IsZero(m.DeduplicationParams) { // not required
		return nil
	}

	if m.DeduplicationParams != nil {
		if err := m.DeduplicationParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deduplicationParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("deduplicationParams")
			}
			return err
		}
	}

	return nil
}

func (m *StoragePolicy) validateErasureCodingParams(formats strfmt.Registry) error {
	if swag.IsZero(m.ErasureCodingParams) { // not required
		return nil
	}

	if m.ErasureCodingParams != nil {
		if err := m.ErasureCodingParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("erasureCodingParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("erasureCodingParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this storage policy based on the context it is used
func (m *StoragePolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCompressionParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeduplicationParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateErasureCodingParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StoragePolicy) contextValidateCompressionParams(ctx context.Context, formats strfmt.Registry) error {

	if m.CompressionParams != nil {

		if swag.IsZero(m.CompressionParams) { // not required
			return nil
		}

		if err := m.CompressionParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("compressionParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("compressionParams")
			}
			return err
		}
	}

	return nil
}

func (m *StoragePolicy) contextValidateDeduplicationParams(ctx context.Context, formats strfmt.Registry) error {

	if m.DeduplicationParams != nil {

		if swag.IsZero(m.DeduplicationParams) { // not required
			return nil
		}

		if err := m.DeduplicationParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deduplicationParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("deduplicationParams")
			}
			return err
		}
	}

	return nil
}

func (m *StoragePolicy) contextValidateErasureCodingParams(ctx context.Context, formats strfmt.Registry) error {

	if m.ErasureCodingParams != nil {

		if swag.IsZero(m.ErasureCodingParams) { // not required
			return nil
		}

		if err := m.ErasureCodingParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("erasureCodingParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("erasureCodingParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StoragePolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StoragePolicy) UnmarshalBinary(b []byte) error {
	var res StoragePolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
