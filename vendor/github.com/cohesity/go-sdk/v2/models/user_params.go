// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserParams Specifies a User.
//
// swagger:model UserParams
type UserParams struct {

	// Specifies the sid of the User.
	// Read Only: true
	Sid *string `json:"sid,omitempty"`

	// Specifies the username.
	// Read Only: true
	Username string `json:"username,omitempty"`

	// Specifies the domain of the user. For active directories, this is the fully qualified domain name (FQDN). It is 'LOCAL' for local users on the Cohesity Cluster. A user is uniquely identified by combination of the username and the domain.
	// Read Only: true
	Domain string `json:"domain,omitempty"`

	// Specifies the epoch time in milliseconds when the user account was created.
	// Read Only: true
	CreatedTimeMsecs *int64 `json:"createdTimeMsecs,omitempty"`

	// Specifies the epoch time in milliseconds when the user account was last modified.
	// Read Only: true
	LastUpdatedTimeMsecs *int64 `json:"lastUpdatedTimeMsecs,omitempty"`

	// Specifies the epoch time in milliseconds when the user last logged in successfully.
	// Read Only: true
	LastLoginTimeMsecs *int64 `json:"lastLoginTimeMsecs,omitempty"`

	// Specifies if the user must change password.
	// Read Only: true
	ForcePasswordChange *bool `json:"forcePasswordChange,omitempty"`

	// Specifies the primary group of the User. Primary group is used for file access.
	// Read Only: true
	PrimaryGroup *string `json:"primaryGroup,omitempty"`

	// Specifies additional groups the User may belong to.
	// Read Only: true
	OtherGroups []string `json:"otherGroups,omitempty"`

	// Specifies the tenant id of the User.
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies the reason for locking the User.
	// Read Only: true
	// Enum: ["NotLocked","FailedLoginAttempts","LockedByAdmin","Inactivity","OtherReasons"]
	LockedReason *string `json:"lockedReason,omitempty"`

	// Specifies the LOCAL user properties. This field is required when adding a new LOCAL Cohesity User.
	LocalUserParams *LocalUserResponseParams `json:"localUserParams,omitempty"`

	// Specifies the S3 Account parameters of the User.
	// Read Only: true
	S3AccountParams *S3AccountParams `json:"s3AccountParams,omitempty"`

	CommonUpdatableUserParams
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *UserParams) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		Sid *string `json:"sid,omitempty"`

		Username string `json:"username,omitempty"`

		Domain string `json:"domain,omitempty"`

		CreatedTimeMsecs *int64 `json:"createdTimeMsecs,omitempty"`

		LastUpdatedTimeMsecs *int64 `json:"lastUpdatedTimeMsecs,omitempty"`

		LastLoginTimeMsecs *int64 `json:"lastLoginTimeMsecs,omitempty"`

		ForcePasswordChange *bool `json:"forcePasswordChange,omitempty"`

		PrimaryGroup *string `json:"primaryGroup,omitempty"`

		OtherGroups []string `json:"otherGroups,omitempty"`

		TenantID *string `json:"tenantId,omitempty"`

		LockedReason *string `json:"lockedReason,omitempty"`

		LocalUserParams *LocalUserResponseParams `json:"localUserParams,omitempty"`

		S3AccountParams *S3AccountParams `json:"s3AccountParams,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.Sid = dataAO0.Sid

	m.Username = dataAO0.Username

	m.Domain = dataAO0.Domain

	m.CreatedTimeMsecs = dataAO0.CreatedTimeMsecs

	m.LastUpdatedTimeMsecs = dataAO0.LastUpdatedTimeMsecs

	m.LastLoginTimeMsecs = dataAO0.LastLoginTimeMsecs

	m.ForcePasswordChange = dataAO0.ForcePasswordChange

	m.PrimaryGroup = dataAO0.PrimaryGroup

	m.OtherGroups = dataAO0.OtherGroups

	m.TenantID = dataAO0.TenantID

	m.LockedReason = dataAO0.LockedReason

	m.LocalUserParams = dataAO0.LocalUserParams

	m.S3AccountParams = dataAO0.S3AccountParams

	// AO1
	var aO1 CommonUpdatableUserParams
	if err := swag.ReadJSON(raw, &aO1); err != nil {
		return err
	}
	m.CommonUpdatableUserParams = aO1

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m UserParams) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	var dataAO0 struct {
		Sid *string `json:"sid,omitempty"`

		Username string `json:"username,omitempty"`

		Domain string `json:"domain,omitempty"`

		CreatedTimeMsecs *int64 `json:"createdTimeMsecs,omitempty"`

		LastUpdatedTimeMsecs *int64 `json:"lastUpdatedTimeMsecs,omitempty"`

		LastLoginTimeMsecs *int64 `json:"lastLoginTimeMsecs,omitempty"`

		ForcePasswordChange *bool `json:"forcePasswordChange,omitempty"`

		PrimaryGroup *string `json:"primaryGroup,omitempty"`

		OtherGroups []string `json:"otherGroups,omitempty"`

		TenantID *string `json:"tenantId,omitempty"`

		LockedReason *string `json:"lockedReason,omitempty"`

		LocalUserParams *LocalUserResponseParams `json:"localUserParams,omitempty"`

		S3AccountParams *S3AccountParams `json:"s3AccountParams,omitempty"`
	}

	dataAO0.Sid = m.Sid

	dataAO0.Username = m.Username

	dataAO0.Domain = m.Domain

	dataAO0.CreatedTimeMsecs = m.CreatedTimeMsecs

	dataAO0.LastUpdatedTimeMsecs = m.LastUpdatedTimeMsecs

	dataAO0.LastLoginTimeMsecs = m.LastLoginTimeMsecs

	dataAO0.ForcePasswordChange = m.ForcePasswordChange

	dataAO0.PrimaryGroup = m.PrimaryGroup

	dataAO0.OtherGroups = m.OtherGroups

	dataAO0.TenantID = m.TenantID

	dataAO0.LockedReason = m.LockedReason

	dataAO0.LocalUserParams = m.LocalUserParams

	dataAO0.S3AccountParams = m.S3AccountParams

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	aO1, err := swag.WriteJSON(m.CommonUpdatableUserParams)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this user params
func (m *UserParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLockedReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalUserParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3AccountParams(formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with CommonUpdatableUserParams
	if err := m.CommonUpdatableUserParams.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var userParamsTypeLockedReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NotLocked","FailedLoginAttempts","LockedByAdmin","Inactivity","OtherReasons"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userParamsTypeLockedReasonPropEnum = append(userParamsTypeLockedReasonPropEnum, v)
	}
}

// property enum
func (m *UserParams) validateLockedReasonEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userParamsTypeLockedReasonPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserParams) validateLockedReason(formats strfmt.Registry) error {

	if swag.IsZero(m.LockedReason) { // not required
		return nil
	}

	// value enum
	if err := m.validateLockedReasonEnum("lockedReason", "body", *m.LockedReason); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) validateLocalUserParams(formats strfmt.Registry) error {

	if swag.IsZero(m.LocalUserParams) { // not required
		return nil
	}

	if m.LocalUserParams != nil {
		if err := m.LocalUserParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localUserParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localUserParams")
			}
			return err
		}
	}

	return nil
}

func (m *UserParams) validateS3AccountParams(formats strfmt.Registry) error {

	if swag.IsZero(m.S3AccountParams) { // not required
		return nil
	}

	if m.S3AccountParams != nil {
		if err := m.S3AccountParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3AccountParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3AccountParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this user params based on the context it is used
func (m *UserParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsername(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDomain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedTimeMsecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastUpdatedTimeMsecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastLoginTimeMsecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateForcePasswordChange(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimaryGroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOtherGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLockedReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalUserParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3AccountParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	// validation for a type composition with CommonUpdatableUserParams
	if err := m.CommonUpdatableUserParams.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserParams) contextValidateSid(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sid", "body", m.Sid); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateUsername(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "username", "body", string(m.Username)); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateDomain(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "domain", "body", string(m.Domain)); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateCreatedTimeMsecs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "createdTimeMsecs", "body", m.CreatedTimeMsecs); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateLastUpdatedTimeMsecs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastUpdatedTimeMsecs", "body", m.LastUpdatedTimeMsecs); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateLastLoginTimeMsecs(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastLoginTimeMsecs", "body", m.LastLoginTimeMsecs); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateForcePasswordChange(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "forcePasswordChange", "body", m.ForcePasswordChange); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidatePrimaryGroup(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "primaryGroup", "body", m.PrimaryGroup); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateOtherGroups(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "otherGroups", "body", []string(m.OtherGroups)); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateLockedReason(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lockedReason", "body", m.LockedReason); err != nil {
		return err
	}

	return nil
}

func (m *UserParams) contextValidateLocalUserParams(ctx context.Context, formats strfmt.Registry) error {

	if m.LocalUserParams != nil {

		if swag.IsZero(m.LocalUserParams) { // not required
			return nil
		}

		if err := m.LocalUserParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localUserParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localUserParams")
			}
			return err
		}
	}

	return nil
}

func (m *UserParams) contextValidateS3AccountParams(ctx context.Context, formats strfmt.Registry) error {

	if m.S3AccountParams != nil {

		if swag.IsZero(m.S3AccountParams) { // not required
			return nil
		}

		if err := m.S3AccountParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3AccountParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3AccountParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserParams) UnmarshalBinary(b []byte) error {
	var res UserParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
