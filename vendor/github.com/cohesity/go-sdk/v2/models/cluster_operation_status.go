// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterOperationStatus Specifies the cluster operation status.
//
// swagger:model ClusterOperationStatus
type ClusterOperationStatus struct {

	// Specifies the ID of the cluster.
	ClusterID int64 `json:"clusterId,omitempty"`

	// Specifies the incarnation id of the cluster.
	ClusterIncarnationID int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the type of cluster operation.
	// * `Destroy` indicates cluster destroy operation.
	// * `Create` indicates cluster create operation.
	// * `NodeAddition` indicates the operation to add nodes to the cluster.
	// * `NodeRemoval` indicates a node removal operation.
	// *  Operation types related to software update are detailed in
	//   [UpdateClusterSoftware](#tag/Platform/operation/UpdateClusterSoftware).
	//
	// Enum: ["Destroy","Create","NodeAddition","NodeRemoval","DownloadUpgradePackage","DownloadPatchPackage","DownloadUpgradeAndPatchPackages","DownloadAndUpgrade","DownloadAndApplyPatch","DownloadAndUpgradeWithPatch","Upgrade","ApplyPatch","RevertPatch","UpgradeAndPatch","AssessSoftwareUpdate","AbortApplyPatch","AbortUpgrade"]
	OperationType string `json:"operationType,omitempty"`

	// Specifies the operation Id of cluster operation.
	//
	OperationID string `json:"operationId,omitempty"`

	// Specifies an approximate completion percentage for
	// the operation.
	//
	Percentage int32 `json:"percentage,omitempty"`

	// Specifies unix epoch start time of operation.
	StartTimeSeconds *int64 `json:"startTimeSeconds,omitempty"`

	// Specifies unix epoch finish time of operation.
	FinishTimeSeconds *int64 `json:"finishTimeSeconds,omitempty"`

	// Specifies an estimated number of seconds until the
	// operation is complete.
	//
	TimeRemainingSeconds int64 `json:"timeRemainingSeconds,omitempty"`

	// Specifies the status of the operation.
	// * 'Success' indicates the operation is successful.
	// * 'Failed' indicates the operation failed due to an error.
	// * 'InProgress' indicates the operation is in progress.
	//
	// Enum: ["InProgress","Success","Failed","Paused","PartiallyCompleted","Canceled","CancelPending","Skipped","Error"]
	Status string `json:"status,omitempty"`

	// Specifies the list of events that took place during the operation.
	//
	Events []*OperationEvents `json:"events,omitempty"`

	// Specifies the status of operation on the cluster nodes.
	NodesOperationStatus []*ClusterNodeOperationStatus `json:"nodesOperationStatus,omitempty"`

	// Specifies the result of running assessment on the cluster nodes.
	NodesAssessmentResults []*NodeAssessmentResults `json:"nodesAssessmentResults,omitempty"`

	// Specifies the attributes of the operation to
	// provide more context for the operation.
	// For example: Use name 'kPackageNameAttribute' and
	// value '7.0.1-p1-2023Jul04-cc6d7c5f' to indicate package being
	// installed when operation type involves installation of package
	// such as 'Upgrade' or 'Patch'.
	// Attribute list will differ based on the type of operation.
	//
	Attributes []*ClusterOperationAttribute `json:"attributes"`

	// Specifies the error message for the operation.
	ErrorMessage string `json:"errorMessage,omitempty"`
}

// Validate validates this cluster operation status
func (m *ClusterOperationStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOperationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodesOperationStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodesAssessmentResults(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterOperationStatusTypeOperationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Destroy","Create","NodeAddition","NodeRemoval","DownloadUpgradePackage","DownloadPatchPackage","DownloadUpgradeAndPatchPackages","DownloadAndUpgrade","DownloadAndApplyPatch","DownloadAndUpgradeWithPatch","Upgrade","ApplyPatch","RevertPatch","UpgradeAndPatch","AssessSoftwareUpdate","AbortApplyPatch","AbortUpgrade"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterOperationStatusTypeOperationTypePropEnum = append(clusterOperationStatusTypeOperationTypePropEnum, v)
	}
}

const (

	// ClusterOperationStatusOperationTypeDestroy captures enum value "Destroy"
	ClusterOperationStatusOperationTypeDestroy string = "Destroy"

	// ClusterOperationStatusOperationTypeCreate captures enum value "Create"
	ClusterOperationStatusOperationTypeCreate string = "Create"

	// ClusterOperationStatusOperationTypeNodeAddition captures enum value "NodeAddition"
	ClusterOperationStatusOperationTypeNodeAddition string = "NodeAddition"

	// ClusterOperationStatusOperationTypeNodeRemoval captures enum value "NodeRemoval"
	ClusterOperationStatusOperationTypeNodeRemoval string = "NodeRemoval"

	// ClusterOperationStatusOperationTypeDownloadUpgradePackage captures enum value "DownloadUpgradePackage"
	ClusterOperationStatusOperationTypeDownloadUpgradePackage string = "DownloadUpgradePackage"

	// ClusterOperationStatusOperationTypeDownloadPatchPackage captures enum value "DownloadPatchPackage"
	ClusterOperationStatusOperationTypeDownloadPatchPackage string = "DownloadPatchPackage"

	// ClusterOperationStatusOperationTypeDownloadUpgradeAndPatchPackages captures enum value "DownloadUpgradeAndPatchPackages"
	ClusterOperationStatusOperationTypeDownloadUpgradeAndPatchPackages string = "DownloadUpgradeAndPatchPackages"

	// ClusterOperationStatusOperationTypeDownloadAndUpgrade captures enum value "DownloadAndUpgrade"
	ClusterOperationStatusOperationTypeDownloadAndUpgrade string = "DownloadAndUpgrade"

	// ClusterOperationStatusOperationTypeDownloadAndApplyPatch captures enum value "DownloadAndApplyPatch"
	ClusterOperationStatusOperationTypeDownloadAndApplyPatch string = "DownloadAndApplyPatch"

	// ClusterOperationStatusOperationTypeDownloadAndUpgradeWithPatch captures enum value "DownloadAndUpgradeWithPatch"
	ClusterOperationStatusOperationTypeDownloadAndUpgradeWithPatch string = "DownloadAndUpgradeWithPatch"

	// ClusterOperationStatusOperationTypeUpgrade captures enum value "Upgrade"
	ClusterOperationStatusOperationTypeUpgrade string = "Upgrade"

	// ClusterOperationStatusOperationTypeApplyPatch captures enum value "ApplyPatch"
	ClusterOperationStatusOperationTypeApplyPatch string = "ApplyPatch"

	// ClusterOperationStatusOperationTypeRevertPatch captures enum value "RevertPatch"
	ClusterOperationStatusOperationTypeRevertPatch string = "RevertPatch"

	// ClusterOperationStatusOperationTypeUpgradeAndPatch captures enum value "UpgradeAndPatch"
	ClusterOperationStatusOperationTypeUpgradeAndPatch string = "UpgradeAndPatch"

	// ClusterOperationStatusOperationTypeAssessSoftwareUpdate captures enum value "AssessSoftwareUpdate"
	ClusterOperationStatusOperationTypeAssessSoftwareUpdate string = "AssessSoftwareUpdate"

	// ClusterOperationStatusOperationTypeAbortApplyPatch captures enum value "AbortApplyPatch"
	ClusterOperationStatusOperationTypeAbortApplyPatch string = "AbortApplyPatch"

	// ClusterOperationStatusOperationTypeAbortUpgrade captures enum value "AbortUpgrade"
	ClusterOperationStatusOperationTypeAbortUpgrade string = "AbortUpgrade"
)

// prop value enum
func (m *ClusterOperationStatus) validateOperationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterOperationStatusTypeOperationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterOperationStatus) validateOperationType(formats strfmt.Registry) error {
	if swag.IsZero(m.OperationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationTypeEnum("operationType", "body", m.OperationType); err != nil {
		return err
	}

	return nil
}

var clusterOperationStatusTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["InProgress","Success","Failed","Paused","PartiallyCompleted","Canceled","CancelPending","Skipped","Error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterOperationStatusTypeStatusPropEnum = append(clusterOperationStatusTypeStatusPropEnum, v)
	}
}

const (

	// ClusterOperationStatusStatusInProgress captures enum value "InProgress"
	ClusterOperationStatusStatusInProgress string = "InProgress"

	// ClusterOperationStatusStatusSuccess captures enum value "Success"
	ClusterOperationStatusStatusSuccess string = "Success"

	// ClusterOperationStatusStatusFailed captures enum value "Failed"
	ClusterOperationStatusStatusFailed string = "Failed"

	// ClusterOperationStatusStatusPaused captures enum value "Paused"
	ClusterOperationStatusStatusPaused string = "Paused"

	// ClusterOperationStatusStatusPartiallyCompleted captures enum value "PartiallyCompleted"
	ClusterOperationStatusStatusPartiallyCompleted string = "PartiallyCompleted"

	// ClusterOperationStatusStatusCanceled captures enum value "Canceled"
	ClusterOperationStatusStatusCanceled string = "Canceled"

	// ClusterOperationStatusStatusCancelPending captures enum value "CancelPending"
	ClusterOperationStatusStatusCancelPending string = "CancelPending"

	// ClusterOperationStatusStatusSkipped captures enum value "Skipped"
	ClusterOperationStatusStatusSkipped string = "Skipped"

	// ClusterOperationStatusStatusError captures enum value "Error"
	ClusterOperationStatusStatusError string = "Error"
)

// prop value enum
func (m *ClusterOperationStatus) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterOperationStatusTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterOperationStatus) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterOperationStatus) validateEvents(formats strfmt.Registry) error {
	if swag.IsZero(m.Events) { // not required
		return nil
	}

	for i := 0; i < len(m.Events); i++ {
		if swag.IsZero(m.Events[i]) { // not required
			continue
		}

		if m.Events[i] != nil {
			if err := m.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) validateNodesOperationStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.NodesOperationStatus) { // not required
		return nil
	}

	for i := 0; i < len(m.NodesOperationStatus); i++ {
		if swag.IsZero(m.NodesOperationStatus[i]) { // not required
			continue
		}

		if m.NodesOperationStatus[i] != nil {
			if err := m.NodesOperationStatus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) validateNodesAssessmentResults(formats strfmt.Registry) error {
	if swag.IsZero(m.NodesAssessmentResults) { // not required
		return nil
	}

	for i := 0; i < len(m.NodesAssessmentResults); i++ {
		if swag.IsZero(m.NodesAssessmentResults[i]) { // not required
			continue
		}

		if m.NodesAssessmentResults[i] != nil {
			if err := m.NodesAssessmentResults[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodesAssessmentResults" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodesAssessmentResults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) validateAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	for i := 0; i < len(m.Attributes); i++ {
		if swag.IsZero(m.Attributes[i]) { // not required
			continue
		}

		if m.Attributes[i] != nil {
			if err := m.Attributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster operation status based on the context it is used
func (m *ClusterOperationStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNodesOperationStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNodesAssessmentResults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterOperationStatus) contextValidateEvents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Events); i++ {

		if m.Events[i] != nil {

			if swag.IsZero(m.Events[i]) { // not required
				return nil
			}

			if err := m.Events[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) contextValidateNodesOperationStatus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NodesOperationStatus); i++ {

		if m.NodesOperationStatus[i] != nil {

			if swag.IsZero(m.NodesOperationStatus[i]) { // not required
				return nil
			}

			if err := m.NodesOperationStatus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) contextValidateNodesAssessmentResults(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NodesAssessmentResults); i++ {

		if m.NodesAssessmentResults[i] != nil {

			if swag.IsZero(m.NodesAssessmentResults[i]) { // not required
				return nil
			}

			if err := m.NodesAssessmentResults[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodesAssessmentResults" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodesAssessmentResults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Attributes); i++ {

		if m.Attributes[i] != nil {

			if swag.IsZero(m.Attributes[i]) { // not required
				return nil
			}

			if err := m.Attributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterOperationStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterOperationStatus) UnmarshalBinary(b []byte) error {
	var res ClusterOperationStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
