// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Disk Disk details
//
// Specifies the details of a disk that belongs to a node.
//
// swagger:model Disk
type Disk struct {

	// Specifies id to uniquely identify a disk.
	ID *int64 `json:"id,omitempty"`

	// Specifies serial number of disk.
	SerialNumber *string `json:"serialNumber,omitempty"`

	// Specifies capacity of disk in bytes.
	CapacityInBytes *int64 `json:"capacityInBytes,omitempty"`

	// Specifies product model of disk.
	Model *string `json:"model,omitempty"`

	// Specifies node id of the node that this disk belong to.
	NodeID *int64 `json:"nodeId,omitempty"`

	// Specifies status of the disk.
	// Enum: ["Online","Offline","Removing","OkToRemove","Blacklist","New","Empty","Unknown","Activating"]
	Status string `json:"status,omitempty"`

	// Specifies type of the disk.
	// Enum: ["SystemDisk","BootDisk","DataDisk","NvmeSsdDisk","SataSsdDisk","HddDisk","Unknown"]
	Type string `json:"type,omitempty"`

	// Specifies location of the disk in node.
	Location *string `json:"location,omitempty"`

	// Specifies disk encryption state.
	// Enum: ["Activating","Active","NotInCluster","KeyRotating","Locked","Unknown","NotSupported"]
	EncryptionStatus string `json:"encryptionStatus,omitempty"`

	// Specifies SSD used percentage.
	SsdUsedPercentage *int32 `json:"ssdUsedPercentage,omitempty"`

	// Specifies SSD usage level as Normal, Warning or Critical.
	// Enum: ["Normal","Warning","Critical"]
	SsdUsageLevel *string `json:"ssdUsageLevel,omitempty"`

	// Specifies the removal reason of the disk.
	RemovalReason *string `json:"removalReason,omitempty"`

	// Specifies the services that are not ACKed after disk is marked for removal.
	ServicesNotAcked *string `json:"servicesNotAcked,omitempty"`

	// Specifies the services not ACKed yet for removal of this entity.
	ServicesNotAckedList []string `json:"servicesNotAckedList"`

	// Specifies the services already ACKed for removal of this entity.
	ServicesAckedList []string `json:"servicesAckedList"`

	// Specifies the overall progress percentage in removing the Disk.
	ProgressPercentage *int32 `json:"progressPercentage,omitempty"`

	// Specifies the total duration in seconds left to remove the Disk.
	TimeRemaining *int64 `json:"timeRemaining,omitempty"`

	// Specifies the removal progress details for services that are not acked yet.
	RemovalProgressList []*ComponentRemovalProgress `json:"removalProgressList"`

	// Specifies the Unix epoch timestamp (in seconds) when the Disk was marked for removal.
	RemovalTimestampSecs *int64 `json:"removalTimestampSecs,omitempty"`

	// Specifies the last run time of the pre-checks execution in Unix epoch timestamp (in seconds).
	PrecheckTimestampSecs *int64 `json:"precheckTimestampSecs,omitempty"`

	// Specifies the pre-check validations results.
	ValidationChecks []*PreCheckValidation `json:"validationChecks"`
}

// Validate validates this disk
func (m *Disk) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSsdUsageLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalProgressList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationChecks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var diskTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Online","Offline","Removing","OkToRemove","Blacklist","New","Empty","Unknown","Activating"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeStatusPropEnum = append(diskTypeStatusPropEnum, v)
	}
}

const (

	// DiskStatusOnline captures enum value "Online"
	DiskStatusOnline string = "Online"

	// DiskStatusOffline captures enum value "Offline"
	DiskStatusOffline string = "Offline"

	// DiskStatusRemoving captures enum value "Removing"
	DiskStatusRemoving string = "Removing"

	// DiskStatusOkToRemove captures enum value "OkToRemove"
	DiskStatusOkToRemove string = "OkToRemove"

	// DiskStatusBlacklist captures enum value "Blacklist"
	DiskStatusBlacklist string = "Blacklist"

	// DiskStatusNew captures enum value "New"
	DiskStatusNew string = "New"

	// DiskStatusEmpty captures enum value "Empty"
	DiskStatusEmpty string = "Empty"

	// DiskStatusUnknown captures enum value "Unknown"
	DiskStatusUnknown string = "Unknown"

	// DiskStatusActivating captures enum value "Activating"
	DiskStatusActivating string = "Activating"
)

// prop value enum
func (m *Disk) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

var diskTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SystemDisk","BootDisk","DataDisk","NvmeSsdDisk","SataSsdDisk","HddDisk","Unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeTypePropEnum = append(diskTypeTypePropEnum, v)
	}
}

const (

	// DiskTypeSystemDisk captures enum value "SystemDisk"
	DiskTypeSystemDisk string = "SystemDisk"

	// DiskTypeBootDisk captures enum value "BootDisk"
	DiskTypeBootDisk string = "BootDisk"

	// DiskTypeDataDisk captures enum value "DataDisk"
	DiskTypeDataDisk string = "DataDisk"

	// DiskTypeNvmeSsdDisk captures enum value "NvmeSsdDisk"
	DiskTypeNvmeSsdDisk string = "NvmeSsdDisk"

	// DiskTypeSataSsdDisk captures enum value "SataSsdDisk"
	DiskTypeSataSsdDisk string = "SataSsdDisk"

	// DiskTypeHddDisk captures enum value "HddDisk"
	DiskTypeHddDisk string = "HddDisk"

	// DiskTypeUnknown captures enum value "Unknown"
	DiskTypeUnknown string = "Unknown"
)

// prop value enum
func (m *Disk) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

var diskTypeEncryptionStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Activating","Active","NotInCluster","KeyRotating","Locked","Unknown","NotSupported"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeEncryptionStatusPropEnum = append(diskTypeEncryptionStatusPropEnum, v)
	}
}

const (

	// DiskEncryptionStatusActivating captures enum value "Activating"
	DiskEncryptionStatusActivating string = "Activating"

	// DiskEncryptionStatusActive captures enum value "Active"
	DiskEncryptionStatusActive string = "Active"

	// DiskEncryptionStatusNotInCluster captures enum value "NotInCluster"
	DiskEncryptionStatusNotInCluster string = "NotInCluster"

	// DiskEncryptionStatusKeyRotating captures enum value "KeyRotating"
	DiskEncryptionStatusKeyRotating string = "KeyRotating"

	// DiskEncryptionStatusLocked captures enum value "Locked"
	DiskEncryptionStatusLocked string = "Locked"

	// DiskEncryptionStatusUnknown captures enum value "Unknown"
	DiskEncryptionStatusUnknown string = "Unknown"

	// DiskEncryptionStatusNotSupported captures enum value "NotSupported"
	DiskEncryptionStatusNotSupported string = "NotSupported"
)

// prop value enum
func (m *Disk) validateEncryptionStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeEncryptionStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateEncryptionStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateEncryptionStatusEnum("encryptionStatus", "body", m.EncryptionStatus); err != nil {
		return err
	}

	return nil
}

var diskTypeSsdUsageLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Normal","Warning","Critical"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeSsdUsageLevelPropEnum = append(diskTypeSsdUsageLevelPropEnum, v)
	}
}

const (

	// DiskSsdUsageLevelNormal captures enum value "Normal"
	DiskSsdUsageLevelNormal string = "Normal"

	// DiskSsdUsageLevelWarning captures enum value "Warning"
	DiskSsdUsageLevelWarning string = "Warning"

	// DiskSsdUsageLevelCritical captures enum value "Critical"
	DiskSsdUsageLevelCritical string = "Critical"
)

// prop value enum
func (m *Disk) validateSsdUsageLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeSsdUsageLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateSsdUsageLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.SsdUsageLevel) { // not required
		return nil
	}

	// value enum
	if err := m.validateSsdUsageLevelEnum("ssdUsageLevel", "body", *m.SsdUsageLevel); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateRemovalProgressList(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalProgressList) { // not required
		return nil
	}

	for i := 0; i < len(m.RemovalProgressList); i++ {
		if swag.IsZero(m.RemovalProgressList[i]) { // not required
			continue
		}

		if m.RemovalProgressList[i] != nil {
			if err := m.RemovalProgressList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) validateValidationChecks(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationChecks) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationChecks); i++ {
		if swag.IsZero(m.ValidationChecks[i]) { // not required
			continue
		}

		if m.ValidationChecks[i] != nil {
			if err := m.ValidationChecks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this disk based on the context it is used
func (m *Disk) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRemovalProgressList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidationChecks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) contextValidateRemovalProgressList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RemovalProgressList); i++ {

		if m.RemovalProgressList[i] != nil {

			if swag.IsZero(m.RemovalProgressList[i]) { // not required
				return nil
			}

			if err := m.RemovalProgressList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) contextValidateValidationChecks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ValidationChecks); i++ {

		if m.ValidationChecks[i] != nil {

			if swag.IsZero(m.ValidationChecks[i]) { // not required
				return nil
			}

			if err := m.ValidationChecks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Disk) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Disk) UnmarshalBinary(b []byte) error {
	var res Disk
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
