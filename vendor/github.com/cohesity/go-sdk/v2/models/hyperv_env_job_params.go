// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HypervEnvJobParams Specifies job parameters applicable for all 'kHyperV' Environment type Protection Sources in a Protection Job.
//
// swagger:model HypervEnvJobParams
type HypervEnvJobParams struct {

	// If true, takes a crash-consistent snapshot when app-consistent snapshot fails. Otherwise, the snapshot attempt is marked failed.
	FallbackToCrashConsistent *bool `json:"fallbackToCrashConsistent,omitempty"`

	// Specifies the Protection Group type. If not specified, then backup method is auto determined. Specifying RCT will forcibly use RCT backup for all VMs in this Protection Group. Available only for VMs with hardware version 8.0 and above, but is more efficient. Specifying VSS will forcibly use VSS backup for all VMs in this Protection Group. Available for VMs with hardware version 5.0 and above, but is slower than RCT backup.
	// Enum: ["kAuto","kRCT","kVSS"]
	ProtectionType *string `json:"protectionType,omitempty"`

	// Specifies a list of disks to exclude from being protected for the object/vm.
	ExcludeDisks []*HyperVDiskInfo `json:"excludeDisks"`

	// Specifies a list of disks to included in the protection for the object/vm.
	IncludeDisks []*HyperVDiskInfo `json:"includeDisks"`
}

// Validate validates this hyperv env job params
func (m *HypervEnvJobParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProtectionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeDisks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIncludeDisks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var hypervEnvJobParamsTypeProtectionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAuto","kRCT","kVSS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hypervEnvJobParamsTypeProtectionTypePropEnum = append(hypervEnvJobParamsTypeProtectionTypePropEnum, v)
	}
}

const (

	// HypervEnvJobParamsProtectionTypeKAuto captures enum value "kAuto"
	HypervEnvJobParamsProtectionTypeKAuto string = "kAuto"

	// HypervEnvJobParamsProtectionTypeKRCT captures enum value "kRCT"
	HypervEnvJobParamsProtectionTypeKRCT string = "kRCT"

	// HypervEnvJobParamsProtectionTypeKVSS captures enum value "kVSS"
	HypervEnvJobParamsProtectionTypeKVSS string = "kVSS"
)

// prop value enum
func (m *HypervEnvJobParams) validateProtectionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, hypervEnvJobParamsTypeProtectionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HypervEnvJobParams) validateProtectionType(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtectionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtectionTypeEnum("protectionType", "body", *m.ProtectionType); err != nil {
		return err
	}

	return nil
}

func (m *HypervEnvJobParams) validateExcludeDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludeDisks); i++ {
		if swag.IsZero(m.ExcludeDisks[i]) { // not required
			continue
		}

		if m.ExcludeDisks[i] != nil {
			if err := m.ExcludeDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HypervEnvJobParams) validateIncludeDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.IncludeDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.IncludeDisks); i++ {
		if swag.IsZero(m.IncludeDisks[i]) { // not required
			continue
		}

		if m.IncludeDisks[i] != nil {
			if err := m.IncludeDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("includeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("includeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this hyperv env job params based on the context it is used
func (m *HypervEnvJobParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExcludeDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIncludeDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HypervEnvJobParams) contextValidateExcludeDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludeDisks); i++ {

		if m.ExcludeDisks[i] != nil {

			if swag.IsZero(m.ExcludeDisks[i]) { // not required
				return nil
			}

			if err := m.ExcludeDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HypervEnvJobParams) contextValidateIncludeDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IncludeDisks); i++ {

		if m.IncludeDisks[i] != nil {

			if swag.IsZero(m.IncludeDisks[i]) { // not required
				return nil
			}

			if err := m.IncludeDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("includeDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("includeDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *HypervEnvJobParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HypervEnvJobParams) UnmarshalBinary(b []byte) error {
	var res HypervEnvJobParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
