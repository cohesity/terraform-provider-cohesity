// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataSourceConnection Data-Source Connection
//
// Specifies all the properties of the data-source connection. A connection is specified by an ID that's guaranteed to be unique. A connection is associated with exactly one tenant. A connection can be thought of as a subset of its tenant's connectors and can contain 0 or more connectors within it. A connector can only be associated with one connection at max at a given time.
//
// swagger:model DataSourceConnection
type DataSourceConnection struct {

	// Specifies the unique ID of the connection.
	// Required: true
	ConnectionID string `json:"connectionId"`

	// Specifies the name of the connection. For a given tenant, different connections can't have the same name. However, two (or more) different tenants can each have a connection with the same name.
	// Required: true
	ConnectionName *string `json:"connectionName"`

	// Specifies the IDs of the connectors in this connection.
	// Read Only: true
	ConnectorIds []string `json:"connectorIds"`

	// Specifies a token that can be used to register a connector against this connection
	// Read Only: true
	RegistrationToken *string `json:"registrationToken,omitempty"`

	// Specifies the connector ID that is currently in upgrade.
	// Read Only: true
	UpgradingConnectorID *string `json:"upgradingConnectorId,omitempty"`

	// Specifies the tenant ID of the connection.
	// Read Only: true
	TenantID string `json:"tenantId,omitempty"`

	// Specifies connectivity status information for the data-source connection. Specifically, it denotes whether any connector corresponding to this connection is connected or not. In addition, latest of all the last connected times of the connectors belonging to this connection is also provided.
	// Read Only: true
	ConnectivityStatus *ConnectionConnectivityStatus `json:"connectivityStatus,omitempty"`
}

// Validate validates this data source connection
func (m *DataSourceConnection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConnectionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectivityStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataSourceConnection) validateConnectionID(formats strfmt.Registry) error {

	if err := validate.RequiredString("connectionId", "body", m.ConnectionID); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnection) validateConnectionName(formats strfmt.Registry) error {

	if err := validate.Required("connectionName", "body", m.ConnectionName); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnection) validateConnectivityStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ConnectivityStatus) { // not required
		return nil
	}

	if m.ConnectivityStatus != nil {
		if err := m.ConnectivityStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connectivityStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connectivityStatus")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this data source connection based on the context it is used
func (m *DataSourceConnection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConnectorIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegistrationToken(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpgradingConnectorID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenantID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnectivityStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataSourceConnection) contextValidateConnectorIds(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "connectorIds", "body", []string(m.ConnectorIds)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnection) contextValidateRegistrationToken(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "registrationToken", "body", m.RegistrationToken); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnection) contextValidateUpgradingConnectorID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "upgradingConnectorId", "body", m.UpgradingConnectorID); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnection) contextValidateTenantID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenantId", "body", string(m.TenantID)); err != nil {
		return err
	}

	return nil
}

func (m *DataSourceConnection) contextValidateConnectivityStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.ConnectivityStatus != nil {

		if swag.IsZero(m.ConnectivityStatus) { // not required
			return nil
		}

		if err := m.ConnectivityStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connectivityStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("connectivityStatus")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DataSourceConnection) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataSourceConnection) UnmarshalBinary(b []byte) error {
	var res DataSourceConnection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
