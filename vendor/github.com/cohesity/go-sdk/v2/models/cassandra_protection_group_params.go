// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CassandraProtectionGroupParams Specifies the parameters for Cassandra Protection Group.
//
// swagger:model CassandraProtectionGroupParams
type CassandraProtectionGroupParams struct {
	NoSQLProtectionGroupParams

	// Only the specified data centers will be considered while taking backup. The keyspaces having replication strategy 'Simple' can be backed up only if all the datacenters for the cassandra cluster are specified. For any keyspace having replication strategy as 'Network', all the associated data centers should be specified.
	DataCenters []string `json:"dataCenters"`

	// Specifies the type of job for Cassandra. If true, only log backup job will be scheduled for the source. This requires a policy with log Backup option enabled.
	IsLogBackup *bool `json:"isLogBackup,omitempty"`

	// Specifies whether this ia a system keyspace backup job.
	IsSystemKeyspaceBackup *bool `json:"isSystemKeyspaceBackup,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *CassandraProtectionGroupParams) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 NoSQLProtectionGroupParams
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.NoSQLProtectionGroupParams = aO0

	// AO1
	var dataAO1 struct {
		DataCenters []string `json:"dataCenters"`

		IsLogBackup *bool `json:"isLogBackup,omitempty"`

		IsSystemKeyspaceBackup *bool `json:"isSystemKeyspaceBackup,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.DataCenters = dataAO1.DataCenters

	m.IsLogBackup = dataAO1.IsLogBackup

	m.IsSystemKeyspaceBackup = dataAO1.IsSystemKeyspaceBackup

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m CassandraProtectionGroupParams) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.NoSQLProtectionGroupParams)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		DataCenters []string `json:"dataCenters"`

		IsLogBackup *bool `json:"isLogBackup,omitempty"`

		IsSystemKeyspaceBackup *bool `json:"isSystemKeyspaceBackup,omitempty"`
	}

	dataAO1.DataCenters = m.DataCenters

	dataAO1.IsLogBackup = m.IsLogBackup

	dataAO1.IsSystemKeyspaceBackup = m.IsSystemKeyspaceBackup

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this cassandra protection group params
func (m *CassandraProtectionGroupParams) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with NoSQLProtectionGroupParams
	if err := m.NoSQLProtectionGroupParams.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validate this cassandra protection group params based on the context it is used
func (m *CassandraProtectionGroupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with NoSQLProtectionGroupParams
	if err := m.NoSQLProtectionGroupParams.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *CassandraProtectionGroupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CassandraProtectionGroupParams) UnmarshalBinary(b []byte) error {
	var res CassandraProtectionGroupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
