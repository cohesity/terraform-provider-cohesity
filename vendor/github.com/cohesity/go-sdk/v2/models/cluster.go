// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster Create Cluster Response.
//
// Specifies the cluster details.
//
// swagger:model Cluster
type Cluster struct {

	// Specifies the cluster id of the new cluster.
	// Read Only: true
	ID *int64 `json:"id,omitempty"`

	// Specifies the incarnation id of the new cluster.
	// Read Only: true
	IncarnationID *int64 `json:"incarnationId,omitempty"`

	// Name of the new cluster.
	Name *string `json:"name,omitempty"`

	// Description of the cluster.
	Description *string `json:"description,omitempty"`

	// Specifies the type of the new cluster.
	// Read Only: true
	// Enum: ["Physical","Virtual","Cloud","Rigel","Cohesion","Unknown","HeliosOnPremVM"]
	Type *string `json:"type,omitempty"`

	// Specifies the size of the cloud platforms.
	// Read Only: true
	// Enum: ["Small","Medium","Large","XLarge","NextGen"]
	ClusterSize *string `json:"clusterSize,omitempty"`

	// Specifies the local tenant id. Only applicable on Helios.
	// Read Only: true
	LocalTenantID *string `json:"localTenantId,omitempty"`

	// Specifies the globally unique tenant id. Only applicable on Helios.
	// Read Only: true
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies the region id on which this cluster is present. Only applicable on Helios for DMaaS clusters.
	// Read Only: true
	RegionID *string `json:"regionId,omitempty"`

	// Specifies the Rigel specific parameters.
	RigelClusterParams *RigelClusterConfigParams `json:"rigelClusterParams,omitempty"`

	// cohesion cluster params
	CohesionClusterParams *CohesionClusterConfigParams `json:"cohesionClusterParams,omitempty"`

	// Software version of the new cluster.
	// Read Only: true
	SwVersion *string `json:"swVersion,omitempty"`

	// Network config of the new cluster.
	NetworkConfig *ClusterCreateNetworkConfig `json:"networkConfig,omitempty"`

	// Specifies the proxy to use for external HTTP traffic.
	ProxyServerConfig *ClusterProxyServerConfig `json:"proxyServerConfig,omitempty"`

	// Specifies whether or not encryption is enabled. If encryption is enabled, all data on the Cluster will be encrypted.
	// Read Only: true
	EnableEncryption *bool `json:"enableEncryption,omitempty"`

	// Specifies the Global Settings for SmartFiles.
	ViewsGlobalSettings *ViewsGlobalSettings `json:"viewsGlobalSettings,omitempty"`

	// Specifies the File Services audit log configuration.
	FileServicesAuditLogConfig *AuditLogConfig `json:"fileServicesAuditLogConfig,omitempty"`

	// cluster audit log config
	ClusterAuditLogConfig *ClusterAuditLogConfig `json:"clusterAuditLogConfig,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRigelClusterParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCohesionClusterParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProxyServerConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewsGlobalSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileServicesAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Physical","Virtual","Cloud","Rigel","Cohesion","Unknown","HeliosOnPremVM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeTypePropEnum = append(clusterTypeTypePropEnum, v)
	}
}

const (

	// ClusterTypePhysical captures enum value "Physical"
	ClusterTypePhysical string = "Physical"

	// ClusterTypeVirtual captures enum value "Virtual"
	ClusterTypeVirtual string = "Virtual"

	// ClusterTypeCloud captures enum value "Cloud"
	ClusterTypeCloud string = "Cloud"

	// ClusterTypeRigel captures enum value "Rigel"
	ClusterTypeRigel string = "Rigel"

	// ClusterTypeCohesion captures enum value "Cohesion"
	ClusterTypeCohesion string = "Cohesion"

	// ClusterTypeUnknown captures enum value "Unknown"
	ClusterTypeUnknown string = "Unknown"

	// ClusterTypeHeliosOnPremVM captures enum value "HeliosOnPremVM"
	ClusterTypeHeliosOnPremVM string = "HeliosOnPremVM"
)

// prop value enum
func (m *Cluster) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var clusterTypeClusterSizePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Small","Medium","Large","XLarge","NextGen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeClusterSizePropEnum = append(clusterTypeClusterSizePropEnum, v)
	}
}

const (

	// ClusterClusterSizeSmall captures enum value "Small"
	ClusterClusterSizeSmall string = "Small"

	// ClusterClusterSizeMedium captures enum value "Medium"
	ClusterClusterSizeMedium string = "Medium"

	// ClusterClusterSizeLarge captures enum value "Large"
	ClusterClusterSizeLarge string = "Large"

	// ClusterClusterSizeXLarge captures enum value "XLarge"
	ClusterClusterSizeXLarge string = "XLarge"

	// ClusterClusterSizeNextGen captures enum value "NextGen"
	ClusterClusterSizeNextGen string = "NextGen"
)

// prop value enum
func (m *Cluster) validateClusterSizeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeClusterSizePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateClusterSize(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterSize) { // not required
		return nil
	}

	// value enum
	if err := m.validateClusterSizeEnum("clusterSize", "body", *m.ClusterSize); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateRigelClusterParams(formats strfmt.Registry) error {
	if swag.IsZero(m.RigelClusterParams) { // not required
		return nil
	}

	if m.RigelClusterParams != nil {
		if err := m.RigelClusterParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rigelClusterParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rigelClusterParams")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateCohesionClusterParams(formats strfmt.Registry) error {
	if swag.IsZero(m.CohesionClusterParams) { // not required
		return nil
	}

	if m.CohesionClusterParams != nil {
		if err := m.CohesionClusterParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cohesionClusterParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cohesionClusterParams")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateNetworkConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkConfig) { // not required
		return nil
	}

	if m.NetworkConfig != nil {
		if err := m.NetworkConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("networkConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("networkConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateProxyServerConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ProxyServerConfig) { // not required
		return nil
	}

	if m.ProxyServerConfig != nil {
		if err := m.ProxyServerConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxyServerConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxyServerConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateViewsGlobalSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.ViewsGlobalSettings) { // not required
		return nil
	}

	if m.ViewsGlobalSettings != nil {
		if err := m.ViewsGlobalSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewsGlobalSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("viewsGlobalSettings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateFileServicesAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FileServicesAuditLogConfig) { // not required
		return nil
	}

	if m.FileServicesAuditLogConfig != nil {
		if err := m.FileServicesAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileServicesAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileServicesAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateClusterAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterAuditLogConfig) { // not required
		return nil
	}

	if m.ClusterAuditLogConfig != nil {
		if err := m.ClusterAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIncarnationID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterSize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalTenantID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenantID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegionID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRigelClusterParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCohesionClusterParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSwVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProxyServerConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnableEncryption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViewsGlobalSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileServicesAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateIncarnationID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "incarnationId", "body", m.IncarnationID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateClusterSize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterSize", "body", m.ClusterSize); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateLocalTenantID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "localTenantId", "body", m.LocalTenantID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateTenantID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenantId", "body", m.TenantID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateRegionID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "regionId", "body", m.RegionID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateRigelClusterParams(ctx context.Context, formats strfmt.Registry) error {

	if m.RigelClusterParams != nil {

		if swag.IsZero(m.RigelClusterParams) { // not required
			return nil
		}

		if err := m.RigelClusterParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rigelClusterParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rigelClusterParams")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateCohesionClusterParams(ctx context.Context, formats strfmt.Registry) error {

	if m.CohesionClusterParams != nil {

		if swag.IsZero(m.CohesionClusterParams) { // not required
			return nil
		}

		if err := m.CohesionClusterParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cohesionClusterParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cohesionClusterParams")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSwVersion(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "swVersion", "body", m.SwVersion); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateNetworkConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkConfig != nil {

		if swag.IsZero(m.NetworkConfig) { // not required
			return nil
		}

		if err := m.NetworkConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("networkConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("networkConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateProxyServerConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ProxyServerConfig != nil {

		if swag.IsZero(m.ProxyServerConfig) { // not required
			return nil
		}

		if err := m.ProxyServerConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("proxyServerConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("proxyServerConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateEnableEncryption(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "enableEncryption", "body", m.EnableEncryption); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) contextValidateViewsGlobalSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.ViewsGlobalSettings != nil {

		if swag.IsZero(m.ViewsGlobalSettings) { // not required
			return nil
		}

		if err := m.ViewsGlobalSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewsGlobalSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("viewsGlobalSettings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateFileServicesAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FileServicesAuditLogConfig != nil {

		if swag.IsZero(m.FileServicesAuditLogConfig) { // not required
			return nil
		}

		if err := m.FileServicesAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileServicesAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileServicesAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateClusterAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterAuditLogConfig != nil {

		if swag.IsZero(m.ClusterAuditLogConfig) { // not required
			return nil
		}

		if err := m.ClusterAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
