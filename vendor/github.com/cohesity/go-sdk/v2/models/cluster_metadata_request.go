// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterMetadataRequest Cluster Metadata Request.
//
// Specifies the cluster metadata request details.
//
// swagger:model ClusterMetadataRequest
type ClusterMetadataRequest struct {

	// Specifies the metadata for various authentication methods that can be used to validate the cluster access.
	// Required: true
	AuthenticationMethods *ClusterAuthMethodsMetadata `json:"authenticationMethods"`

	// Specifies the list of custom properties associated with the cluster. API caller can choose to set the following properties using provided key and value fields. The input values must always be in the string format and each key must be unique.
	CustomProperties []*ClusterCustomMetadata `json:"customProperties"`

	// Specifies the SLA related metadata specific to the cluster.
	SLA *ClusterSLAMetadata `json:"sla,omitempty"`

	// Specifies the docs related metadata specific to the cluster. This metadata mainly consists of any external hyperlinks to service provider's documentation.
	Docs []*ClusterDocsMetadata `json:"docs"`
}

// Validate validates this cluster metadata request
func (m *ClusterMetadataRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthenticationMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSLA(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetadataRequest) validateAuthenticationMethods(formats strfmt.Registry) error {

	if err := validate.Required("authenticationMethods", "body", m.AuthenticationMethods); err != nil {
		return err
	}

	if m.AuthenticationMethods != nil {
		if err := m.AuthenticationMethods.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authenticationMethods")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authenticationMethods")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetadataRequest) validateCustomProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomProperties) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomProperties); i++ {
		if swag.IsZero(m.CustomProperties[i]) { // not required
			continue
		}

		if m.CustomProperties[i] != nil {
			if err := m.CustomProperties[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customProperties" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("customProperties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetadataRequest) validateSLA(formats strfmt.Registry) error {
	if swag.IsZero(m.SLA) { // not required
		return nil
	}

	if m.SLA != nil {
		if err := m.SLA.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sla")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sla")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetadataRequest) validateDocs(formats strfmt.Registry) error {
	if swag.IsZero(m.Docs) { // not required
		return nil
	}

	for i := 0; i < len(m.Docs); i++ {
		if swag.IsZero(m.Docs[i]) { // not required
			continue
		}

		if m.Docs[i] != nil {
			if err := m.Docs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("docs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("docs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster metadata request based on the context it is used
func (m *ClusterMetadataRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAuthenticationMethods(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSLA(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDocs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterMetadataRequest) contextValidateAuthenticationMethods(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthenticationMethods != nil {

		if err := m.AuthenticationMethods.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authenticationMethods")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("authenticationMethods")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetadataRequest) contextValidateCustomProperties(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CustomProperties); i++ {

		if m.CustomProperties[i] != nil {

			if swag.IsZero(m.CustomProperties[i]) { // not required
				return nil
			}

			if err := m.CustomProperties[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customProperties" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("customProperties" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterMetadataRequest) contextValidateSLA(ctx context.Context, formats strfmt.Registry) error {

	if m.SLA != nil {

		if swag.IsZero(m.SLA) { // not required
			return nil
		}

		if err := m.SLA.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sla")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sla")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterMetadataRequest) contextValidateDocs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Docs); i++ {

		if m.Docs[i] != nil {

			if swag.IsZero(m.Docs[i]) { // not required
				return nil
			}

			if err := m.Docs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("docs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("docs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterMetadataRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterMetadataRequest) UnmarshalBinary(b []byte) error {
	var res ClusterMetadataRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
