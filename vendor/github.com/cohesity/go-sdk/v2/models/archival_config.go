// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ArchivalConfig Archival Target Configuration
//
// Specifies settings for copying Snapshots External Targets (such as AWS or Tape). This also specifies the retention policy that should be applied to Snapshots after they have been copied to the specified target.
//
// swagger:model ArchivalConfig
type ArchivalConfig struct {
	CommonTargetConfiguration

	// Specifies the Archival target to copy the Snapshots to.
	// Required: true
	TargetID *int64 `json:"targetId"`

	// Specifies the Archival target name where Snapshots are copied.
	// Read Only: true
	TargetName *string `json:"targetName,omitempty"`

	// Specifies the Archival target type where Snapshots are copied.
	// Read Only: true
	// Enum: ["Tape","Cloud","Nas"]
	TargetType *string `json:"targetType,omitempty"`

	// Specifies the tier settings that will be applied to given target. If provided target is of type 'cloud', then only tiering can be applied. The respective cloud platform details need to be provided here.
	TierSettings *TierLevelSettings `json:"tierSettings,omitempty"`

	// Specifies additional retention policies that should be applied to the archived backup. Archived backup snapshot will be retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []*ExtendedRetentionPolicy `json:"extendedRetention"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ArchivalConfig) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 CommonTargetConfiguration
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.CommonTargetConfiguration = aO0

	// AO1
	var dataAO1 struct {
		TargetID *int64 `json:"targetId"`

		TargetName *string `json:"targetName,omitempty"`

		TargetType *string `json:"targetType,omitempty"`

		TierSettings *TierLevelSettings `json:"tierSettings,omitempty"`

		ExtendedRetention []*ExtendedRetentionPolicy `json:"extendedRetention"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.TargetID = dataAO1.TargetID

	m.TargetName = dataAO1.TargetName

	m.TargetType = dataAO1.TargetType

	m.TierSettings = dataAO1.TierSettings

	m.ExtendedRetention = dataAO1.ExtendedRetention

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ArchivalConfig) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.CommonTargetConfiguration)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		TargetID *int64 `json:"targetId"`

		TargetName *string `json:"targetName,omitempty"`

		TargetType *string `json:"targetType,omitempty"`

		TierSettings *TierLevelSettings `json:"tierSettings,omitempty"`

		ExtendedRetention []*ExtendedRetentionPolicy `json:"extendedRetention"`
	}

	dataAO1.TargetID = m.TargetID

	dataAO1.TargetName = m.TargetName

	dataAO1.TargetType = m.TargetType

	dataAO1.TierSettings = m.TierSettings

	dataAO1.ExtendedRetention = m.ExtendedRetention

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this archival config
func (m *ArchivalConfig) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with CommonTargetConfiguration
	if err := m.CommonTargetConfiguration.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTierSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtendedRetention(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ArchivalConfig) validateTargetID(formats strfmt.Registry) error {

	if err := validate.Required("targetId", "body", m.TargetID); err != nil {
		return err
	}

	return nil
}

var archivalConfigTypeTargetTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Tape","Cloud","Nas"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		archivalConfigTypeTargetTypePropEnum = append(archivalConfigTypeTargetTypePropEnum, v)
	}
}

// property enum
func (m *ArchivalConfig) validateTargetTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, archivalConfigTypeTargetTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ArchivalConfig) validateTargetType(formats strfmt.Registry) error {

	if swag.IsZero(m.TargetType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTargetTypeEnum("targetType", "body", *m.TargetType); err != nil {
		return err
	}

	return nil
}

func (m *ArchivalConfig) validateTierSettings(formats strfmt.Registry) error {

	if swag.IsZero(m.TierSettings) { // not required
		return nil
	}

	if m.TierSettings != nil {
		if err := m.TierSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tierSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tierSettings")
			}
			return err
		}
	}

	return nil
}

func (m *ArchivalConfig) validateExtendedRetention(formats strfmt.Registry) error {

	if swag.IsZero(m.ExtendedRetention) { // not required
		return nil
	}

	for i := 0; i < len(m.ExtendedRetention); i++ {
		if swag.IsZero(m.ExtendedRetention[i]) { // not required
			continue
		}

		if m.ExtendedRetention[i] != nil {
			if err := m.ExtendedRetention[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this archival config based on the context it is used
func (m *ArchivalConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with CommonTargetConfiguration
	if err := m.CommonTargetConfiguration.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTierSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtendedRetention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ArchivalConfig) contextValidateTargetName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetName", "body", m.TargetName); err != nil {
		return err
	}

	return nil
}

func (m *ArchivalConfig) contextValidateTargetType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "targetType", "body", m.TargetType); err != nil {
		return err
	}

	return nil
}

func (m *ArchivalConfig) contextValidateTierSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.TierSettings != nil {

		if swag.IsZero(m.TierSettings) { // not required
			return nil
		}

		if err := m.TierSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tierSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tierSettings")
			}
			return err
		}
	}

	return nil
}

func (m *ArchivalConfig) contextValidateExtendedRetention(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExtendedRetention); i++ {

		if m.ExtendedRetention[i] != nil {

			if swag.IsZero(m.ExtendedRetention[i]) { // not required
				return nil
			}

			if err := m.ExtendedRetention[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ArchivalConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ArchivalConfig) UnmarshalBinary(b []byte) error {
	var res ArchivalConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
