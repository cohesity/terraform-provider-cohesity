// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ObjectProtectionRunInfo Object Protection Run Info.
//
// Specifies the run info for a run protecting an object.
//
// swagger:model ObjectProtectionRunInfo
type ObjectProtectionRunInfo struct {

	// Specifies the ID of the protection run.
	RunID *string `json:"runId,omitempty"`

	// Type of Protection run. 'kRegular' indicates an incremental (CBT) backup. Incremental backups utilizing CBT (if supported) are captured of the target protection objects. The first run of a kRegular schedule captures all the blocks. 'kFull' indicates a full (no CBT) backup. A complete backup (all blocks) of the target protection objects are always captured and Change Block Tracking (CBT) is not utilized. 'kLog' indicates a Database Log backup. Capture the database transaction logs to allow rolling back to a specific point in time. 'kSystem' indicates system volume backup. It produces an image for bare metal recovery.
	// Enum: ["kRegular","kFull","kLog","kSystem","kHydrateCDP","kStorageArraySnapshot"]
	RunType *string `json:"runType,omitempty"`

	// Indicated if SLA has been violated for this run.
	IsSLAViolated *bool `json:"isSlaViolated,omitempty"`

	// ProtectionGroupId to which this run belongs. This will only be populated if the object is protected by a protection group.
	ProtectionGroupID *string `json:"protectionGroupId,omitempty"`

	// Name of the Protection Group to which this run belongs. This will only be populated if the object is protected by a protection group.
	ProtectionGroupName *string `json:"protectionGroupName,omitempty"`

	// Specifies if snapshots for this run has been deleted.
	IsLocalSnapshotsDeleted *bool `json:"isLocalSnapshotsDeleted,omitempty"`

	// Specifies if this protection run is a replication run.
	IsReplicationRun *bool `json:"isReplicationRun,omitempty"`

	// Specifies whether the run is a CAD run if cloud archive direct feature is enabled. If this field is true, the primary backup copy will only be available at the given archived location.
	IsCloudArchivalDirect *bool `json:"isCloudArchivalDirect,omitempty"`

	// Specifies the unique id of the Protection Policy associated with the Protection Run. The Policy provides retry settings Protection Schedules, Priority, SLA, etc.
	PolicyID *string `json:"policyId,omitempty"`

	// Specifies Specifies the name of the Protection Policy.
	PolicyName *string `json:"policyName,omitempty"`

	// Specifies the Storage Domain (View Box) ID where this Protection Run writes data.
	StorageDomainID *int64 `json:"storageDomainId,omitempty"`

	// Specifies the list of tenants that have permissions for this protection group run.
	Permissions []*Tenant `json:"permissions"`

	// Specifies the information of the primary cluster if this run is a replication run.
	OriginClusterIdentifier *ClusterIdentifier `json:"originClusterIdentifier,omitempty"`

	// ProtectionGroupId to which this run belongs on the primary cluster if this run is a replication run.
	OriginProtectionGroupID *string `json:"originProtectionGroupId,omitempty"`

	// Information about local snapshot run for this object.
	LocalSnapshotInfo *BackupRun `json:"localSnapshotInfo,omitempty"`

	// Information about snapshot run on the original cluster. This only applies to replication run.
	OriginalBackupInfo *BackupRun `json:"originalBackupInfo,omitempty"`

	// Information about replication run for this object.
	ReplicationInfo *ReplicationRun `json:"replicationInfo,omitempty"`

	// Information about archival run for this object.
	ArchivalInfo *ArchivalRun `json:"archivalInfo,omitempty"`

	// Information about Cloud Spin run for this object.
	CloudSpinInfo *CloudSpinRun `json:"cloudSpinInfo,omitempty"`

	// Information about onprem deploy run for this object.
	OnPremDeployInfo *OnPremDeployRun `json:"onPremDeployInfo,omitempty"`

	// Specifies if object's snapshot is on legal hold.
	OnLegalHold *bool `json:"onLegalHold,omitempty"`

	// Specifies WORM retention type for the local backeup. When a WORM retention type is specified, the snapshots of the Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time, the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason. <br>'Administrative' implies WORM retention is set for administrative purposes.
	// Enum: ["Compliance","Administrative"]
	DataLock *string `json:"dataLock,omitempty"`

	// Specifies a label with which this run is created. Only applicable for user triggered protect now action.
	RunLabel *string `json:"runLabel,omitempty"`
}

// Validate validates this object protection run info
func (m *ObjectProtectionRunInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRunType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginClusterIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalSnapshotInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalBackupInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicationInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchivalInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudSpinInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnPremDeployInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLock(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var objectProtectionRunInfoTypeRunTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kRegular","kFull","kLog","kSystem","kHydrateCDP","kStorageArraySnapshot"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objectProtectionRunInfoTypeRunTypePropEnum = append(objectProtectionRunInfoTypeRunTypePropEnum, v)
	}
}

const (

	// ObjectProtectionRunInfoRunTypeKRegular captures enum value "kRegular"
	ObjectProtectionRunInfoRunTypeKRegular string = "kRegular"

	// ObjectProtectionRunInfoRunTypeKFull captures enum value "kFull"
	ObjectProtectionRunInfoRunTypeKFull string = "kFull"

	// ObjectProtectionRunInfoRunTypeKLog captures enum value "kLog"
	ObjectProtectionRunInfoRunTypeKLog string = "kLog"

	// ObjectProtectionRunInfoRunTypeKSystem captures enum value "kSystem"
	ObjectProtectionRunInfoRunTypeKSystem string = "kSystem"

	// ObjectProtectionRunInfoRunTypeKHydrateCDP captures enum value "kHydrateCDP"
	ObjectProtectionRunInfoRunTypeKHydrateCDP string = "kHydrateCDP"

	// ObjectProtectionRunInfoRunTypeKStorageArraySnapshot captures enum value "kStorageArraySnapshot"
	ObjectProtectionRunInfoRunTypeKStorageArraySnapshot string = "kStorageArraySnapshot"
)

// prop value enum
func (m *ObjectProtectionRunInfo) validateRunTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objectProtectionRunInfoTypeRunTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjectProtectionRunInfo) validateRunType(formats strfmt.Registry) error {
	if swag.IsZero(m.RunType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRunTypeEnum("runType", "body", *m.RunType); err != nil {
		return err
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validatePermissions(formats strfmt.Registry) error {
	if swag.IsZero(m.Permissions) { // not required
		return nil
	}

	for i := 0; i < len(m.Permissions); i++ {
		if swag.IsZero(m.Permissions[i]) { // not required
			continue
		}

		if m.Permissions[i] != nil {
			if err := m.Permissions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("permissions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("permissions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateOriginClusterIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginClusterIdentifier) { // not required
		return nil
	}

	if m.OriginClusterIdentifier != nil {
		if err := m.OriginClusterIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originClusterIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("originClusterIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateLocalSnapshotInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalSnapshotInfo) { // not required
		return nil
	}

	if m.LocalSnapshotInfo != nil {
		if err := m.LocalSnapshotInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateOriginalBackupInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginalBackupInfo) { // not required
		return nil
	}

	if m.OriginalBackupInfo != nil {
		if err := m.OriginalBackupInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originalBackupInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("originalBackupInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateReplicationInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicationInfo) { // not required
		return nil
	}

	if m.ReplicationInfo != nil {
		if err := m.ReplicationInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicationInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateArchivalInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchivalInfo) { // not required
		return nil
	}

	if m.ArchivalInfo != nil {
		if err := m.ArchivalInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateCloudSpinInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudSpinInfo) { // not required
		return nil
	}

	if m.CloudSpinInfo != nil {
		if err := m.CloudSpinInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudSpinInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudSpinInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) validateOnPremDeployInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.OnPremDeployInfo) { // not required
		return nil
	}

	if m.OnPremDeployInfo != nil {
		if err := m.OnPremDeployInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onPremDeployInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("onPremDeployInfo")
			}
			return err
		}
	}

	return nil
}

var objectProtectionRunInfoTypeDataLockPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Compliance","Administrative"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		objectProtectionRunInfoTypeDataLockPropEnum = append(objectProtectionRunInfoTypeDataLockPropEnum, v)
	}
}

const (

	// ObjectProtectionRunInfoDataLockCompliance captures enum value "Compliance"
	ObjectProtectionRunInfoDataLockCompliance string = "Compliance"

	// ObjectProtectionRunInfoDataLockAdministrative captures enum value "Administrative"
	ObjectProtectionRunInfoDataLockAdministrative string = "Administrative"
)

// prop value enum
func (m *ObjectProtectionRunInfo) validateDataLockEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, objectProtectionRunInfoTypeDataLockPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ObjectProtectionRunInfo) validateDataLock(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLock) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataLockEnum("dataLock", "body", *m.DataLock); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this object protection run info based on the context it is used
func (m *ObjectProtectionRunInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePermissions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginClusterIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalSnapshotInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginalBackupInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicationInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchivalInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudSpinInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOnPremDeployInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectProtectionRunInfo) contextValidatePermissions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Permissions); i++ {

		if m.Permissions[i] != nil {

			if swag.IsZero(m.Permissions[i]) { // not required
				return nil
			}

			if err := m.Permissions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("permissions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("permissions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateOriginClusterIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginClusterIdentifier != nil {

		if swag.IsZero(m.OriginClusterIdentifier) { // not required
			return nil
		}

		if err := m.OriginClusterIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originClusterIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("originClusterIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateLocalSnapshotInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.LocalSnapshotInfo != nil {

		if swag.IsZero(m.LocalSnapshotInfo) { // not required
			return nil
		}

		if err := m.LocalSnapshotInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateOriginalBackupInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginalBackupInfo != nil {

		if swag.IsZero(m.OriginalBackupInfo) { // not required
			return nil
		}

		if err := m.OriginalBackupInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originalBackupInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("originalBackupInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateReplicationInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicationInfo != nil {

		if swag.IsZero(m.ReplicationInfo) { // not required
			return nil
		}

		if err := m.ReplicationInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicationInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateArchivalInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchivalInfo != nil {

		if swag.IsZero(m.ArchivalInfo) { // not required
			return nil
		}

		if err := m.ArchivalInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateCloudSpinInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudSpinInfo != nil {

		if swag.IsZero(m.CloudSpinInfo) { // not required
			return nil
		}

		if err := m.CloudSpinInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudSpinInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudSpinInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectProtectionRunInfo) contextValidateOnPremDeployInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.OnPremDeployInfo != nil {

		if swag.IsZero(m.OnPremDeployInfo) { // not required
			return nil
		}

		if err := m.OnPremDeployInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onPremDeployInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("onPremDeployInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ObjectProtectionRunInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ObjectProtectionRunInfo) UnmarshalBinary(b []byte) error {
	var res ObjectProtectionRunInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
