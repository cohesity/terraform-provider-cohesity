// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PhysicalSourceRegistrationParams Register physical sever request parameters.
//
// Specifies parameters to register physical server.
//
// swagger:model PhysicalSourceRegistrationParams
type PhysicalSourceRegistrationParams struct {

	// Specifies the endpoint IPaddress, URL or hostname of the physical host.
	// Required: true
	Endpoint *string `json:"endpoint"`

	// The agent running on a physical host will fail the registration if it is already registered as part of another cluster. By setting this option to true, agent can be forced to register with the current cluster.
	ForceRegister *bool `json:"forceRegister,omitempty"`

	// Specifies the type of host.
	// Enum: ["kLinux","kWindows","kAix","kSolaris","kSapHana","kOther","kHPUX","kVOS"]
	HostType *string `json:"hostType,omitempty"`

	// Specifies the type of physical server.
	// Enum: ["kGroup","kHost","kWindowsCluster","kOracleRACCluster","kOracleAPCluster","kUnixCluster"]
	PhysicalType *string `json:"physicalType,omitempty"`

	// Specifies the list of applications to be registered with Physical Source.
	Applications []string `json:"applications"`
}

// Validate validates this physical source registration params
func (m *PhysicalSourceRegistrationParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndpoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApplications(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PhysicalSourceRegistrationParams) validateEndpoint(formats strfmt.Registry) error {

	if err := validate.Required("endpoint", "body", m.Endpoint); err != nil {
		return err
	}

	return nil
}

var physicalSourceRegistrationParamsTypeHostTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLinux","kWindows","kAix","kSolaris","kSapHana","kOther","kHPUX","kVOS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		physicalSourceRegistrationParamsTypeHostTypePropEnum = append(physicalSourceRegistrationParamsTypeHostTypePropEnum, v)
	}
}

const (

	// PhysicalSourceRegistrationParamsHostTypeKLinux captures enum value "kLinux"
	PhysicalSourceRegistrationParamsHostTypeKLinux string = "kLinux"

	// PhysicalSourceRegistrationParamsHostTypeKWindows captures enum value "kWindows"
	PhysicalSourceRegistrationParamsHostTypeKWindows string = "kWindows"

	// PhysicalSourceRegistrationParamsHostTypeKAix captures enum value "kAix"
	PhysicalSourceRegistrationParamsHostTypeKAix string = "kAix"

	// PhysicalSourceRegistrationParamsHostTypeKSolaris captures enum value "kSolaris"
	PhysicalSourceRegistrationParamsHostTypeKSolaris string = "kSolaris"

	// PhysicalSourceRegistrationParamsHostTypeKSapHana captures enum value "kSapHana"
	PhysicalSourceRegistrationParamsHostTypeKSapHana string = "kSapHana"

	// PhysicalSourceRegistrationParamsHostTypeKOther captures enum value "kOther"
	PhysicalSourceRegistrationParamsHostTypeKOther string = "kOther"

	// PhysicalSourceRegistrationParamsHostTypeKHPUX captures enum value "kHPUX"
	PhysicalSourceRegistrationParamsHostTypeKHPUX string = "kHPUX"

	// PhysicalSourceRegistrationParamsHostTypeKVOS captures enum value "kVOS"
	PhysicalSourceRegistrationParamsHostTypeKVOS string = "kVOS"
)

// prop value enum
func (m *PhysicalSourceRegistrationParams) validateHostTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, physicalSourceRegistrationParamsTypeHostTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PhysicalSourceRegistrationParams) validateHostType(formats strfmt.Registry) error {
	if swag.IsZero(m.HostType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHostTypeEnum("hostType", "body", *m.HostType); err != nil {
		return err
	}

	return nil
}

var physicalSourceRegistrationParamsTypePhysicalTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kGroup","kHost","kWindowsCluster","kOracleRACCluster","kOracleAPCluster","kUnixCluster"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		physicalSourceRegistrationParamsTypePhysicalTypePropEnum = append(physicalSourceRegistrationParamsTypePhysicalTypePropEnum, v)
	}
}

const (

	// PhysicalSourceRegistrationParamsPhysicalTypeKGroup captures enum value "kGroup"
	PhysicalSourceRegistrationParamsPhysicalTypeKGroup string = "kGroup"

	// PhysicalSourceRegistrationParamsPhysicalTypeKHost captures enum value "kHost"
	PhysicalSourceRegistrationParamsPhysicalTypeKHost string = "kHost"

	// PhysicalSourceRegistrationParamsPhysicalTypeKWindowsCluster captures enum value "kWindowsCluster"
	PhysicalSourceRegistrationParamsPhysicalTypeKWindowsCluster string = "kWindowsCluster"

	// PhysicalSourceRegistrationParamsPhysicalTypeKOracleRACCluster captures enum value "kOracleRACCluster"
	PhysicalSourceRegistrationParamsPhysicalTypeKOracleRACCluster string = "kOracleRACCluster"

	// PhysicalSourceRegistrationParamsPhysicalTypeKOracleAPCluster captures enum value "kOracleAPCluster"
	PhysicalSourceRegistrationParamsPhysicalTypeKOracleAPCluster string = "kOracleAPCluster"

	// PhysicalSourceRegistrationParamsPhysicalTypeKUnixCluster captures enum value "kUnixCluster"
	PhysicalSourceRegistrationParamsPhysicalTypeKUnixCluster string = "kUnixCluster"
)

// prop value enum
func (m *PhysicalSourceRegistrationParams) validatePhysicalTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, physicalSourceRegistrationParamsTypePhysicalTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PhysicalSourceRegistrationParams) validatePhysicalType(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalType) { // not required
		return nil
	}

	// value enum
	if err := m.validatePhysicalTypeEnum("physicalType", "body", *m.PhysicalType); err != nil {
		return err
	}

	return nil
}

var physicalSourceRegistrationParamsApplicationsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSQL","kOracle"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		physicalSourceRegistrationParamsApplicationsItemsEnum = append(physicalSourceRegistrationParamsApplicationsItemsEnum, v)
	}
}

func (m *PhysicalSourceRegistrationParams) validateApplicationsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, physicalSourceRegistrationParamsApplicationsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PhysicalSourceRegistrationParams) validateApplications(formats strfmt.Registry) error {
	if swag.IsZero(m.Applications) { // not required
		return nil
	}

	for i := 0; i < len(m.Applications); i++ {

		// value enum
		if err := m.validateApplicationsItemsEnum("applications"+"."+strconv.Itoa(i), "body", m.Applications[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this physical source registration params based on context it is used
func (m *PhysicalSourceRegistrationParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *PhysicalSourceRegistrationParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PhysicalSourceRegistrationParams) UnmarshalBinary(b []byte) error {
	var res PhysicalSourceRegistrationParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
