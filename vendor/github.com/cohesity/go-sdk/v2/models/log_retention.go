// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LogRetention Specifies the log retention of a backup.
//
// swagger:model LogRetention
type LogRetention struct {

	// Specificies the Retention Unit of a backup measured in days, months or years. <br> If unit is 'Months', then number specified in duration is multiplied to 30. <br> Example: If duration is 4 and unit is 'Months' then number of retention days will be 30 * 4 = 120 days. <br> If unit is 'Years', then number specified in duration is multiplied to 365. <br> If duration is 2 and unit is 'Months' then number of retention days will be 365 * 2 = 730 days.
	// Required: true
	// Enum: ["Days","Weeks","Months","Years"]
	Unit *string `json:"unit"`

	// Specifies the duration for a backup retention. <br> Example. If duration is 7 and unit is Months, the retention of a backup is 7 * 30 = 210 days.
	// Required: true
	// Minimum: 0
	Duration *int64 `json:"duration"`

	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the Protection Groups using this policy will be kept for the last N days as specified in the duration of the datalock. During that time, the snapshots cannot be deleted. For RPaaS the data lock will always be automatically set to cover the whole retention, and any input will be ignored.
	DataLockConfig *DataLockConfig `json:"dataLockConfig,omitempty"`
}

// Validate validates this log retention
func (m *LogRetention) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLockConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var logRetentionTypeUnitPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Days","Weeks","Months","Years"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		logRetentionTypeUnitPropEnum = append(logRetentionTypeUnitPropEnum, v)
	}
}

const (

	// LogRetentionUnitDays captures enum value "Days"
	LogRetentionUnitDays string = "Days"

	// LogRetentionUnitWeeks captures enum value "Weeks"
	LogRetentionUnitWeeks string = "Weeks"

	// LogRetentionUnitMonths captures enum value "Months"
	LogRetentionUnitMonths string = "Months"

	// LogRetentionUnitYears captures enum value "Years"
	LogRetentionUnitYears string = "Years"
)

// prop value enum
func (m *LogRetention) validateUnitEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, logRetentionTypeUnitPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *LogRetention) validateUnit(formats strfmt.Registry) error {

	if err := validate.Required("unit", "body", m.Unit); err != nil {
		return err
	}

	// value enum
	if err := m.validateUnitEnum("unit", "body", *m.Unit); err != nil {
		return err
	}

	return nil
}

func (m *LogRetention) validateDuration(formats strfmt.Registry) error {

	if err := validate.Required("duration", "body", m.Duration); err != nil {
		return err
	}

	if err := validate.MinimumInt("duration", "body", *m.Duration, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *LogRetention) validateDataLockConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLockConfig) { // not required
		return nil
	}

	if m.DataLockConfig != nil {
		if err := m.DataLockConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this log retention based on the context it is used
func (m *LogRetention) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDataLockConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LogRetention) contextValidateDataLockConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.DataLockConfig != nil {

		if swag.IsZero(m.DataLockConfig) { // not required
			return nil
		}

		if err := m.DataLockConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LogRetention) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LogRetention) UnmarshalBinary(b []byte) error {
	var res LogRetention
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
