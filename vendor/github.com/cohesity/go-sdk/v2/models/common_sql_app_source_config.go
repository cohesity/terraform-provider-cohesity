// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CommonSQLAppSourceConfig Common Sql App Source Config.
//
// Specifies a common parameters used when restroring back to original or new source.
//
// swagger:model CommonSqlAppSourceConfig
type CommonSQLAppSourceConfig struct {

	// Specifies the time in the past to which the Sql database needs to be restored. This allows for granular recovery of Sql databases. If this is not set, the Sql database will be restored from the full/incremental snapshot.
	RestoreTimeUsecs *int64 `json:"restoreTimeUsecs,omitempty"`

	// Specifies the secondary data filename pattern and corresponding direcories of the DB. Secondary data files are optional and are user defined. The recommended file extention for secondary files is ".ndf". If this option is specified and the destination folders do not exist they will be automatically created.
	SecondaryDataFilesDirList []*FilenamePatternToDirectory `json:"secondaryDataFilesDirList"`

	// Specifies the flag to bring DBs online or not after successful recovery. If this is passed as true, then it means DBs won't be brought online.
	WithNoRecovery *bool `json:"withNoRecovery,omitempty"`

	// Specifies whether to keep CDC (Change Data Capture) on recovered databases or not. If not passed, this is assumed to be true. If withNoRecovery is passed as true, then this field must not be set to true. Passing this field as true in this scenario will be a invalid request.
	KeepCdc *bool `json:"keepCdc,omitempty"`

	// Specifies a policy to be used while recovering existing databases.
	// Enum: ["FailIfExists","Overwrite"]
	OverwritingPolicy *string `json:"overwritingPolicy,omitempty"`

	// Specifies the parameters related to multi stage Sql restore.
	MultiStageRestoreOptions *MultiStageRestoreOptions `json:"multiStageRestoreOptions,omitempty"`

	// 'with_clause' contains 'with clause' to be used in native sql restore command. This is only applicable for database restore of native sql backup. Here user can specify multiple restore options. Example: 'WITH BUFFERCOUNT = 575, MAXTRANSFERSIZE = 2097152'.
	NativeRecoveryWithClause *string `json:"nativeRecoveryWithClause,omitempty"`

	// Specifies the option to set replay last log bit while creating the sql restore task and doing restore to latest point-in-time. If this is set to true, we will replay the entire last log without STOPAT.
	ReplayEntireLastLog *bool `json:"replayEntireLastLog,omitempty"`

	// Specifies the WITH clause to be used in native sql log restore command. This is only applicable for native log restore.
	NativeLogRecoveryWithClause *string `json:"nativeLogRecoveryWithClause,omitempty"`
}

// Validate validates this common Sql app source config
func (m *CommonSQLAppSourceConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSecondaryDataFilesDirList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverwritingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMultiStageRestoreOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CommonSQLAppSourceConfig) validateSecondaryDataFilesDirList(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryDataFilesDirList) { // not required
		return nil
	}

	for i := 0; i < len(m.SecondaryDataFilesDirList); i++ {
		if swag.IsZero(m.SecondaryDataFilesDirList[i]) { // not required
			continue
		}

		if m.SecondaryDataFilesDirList[i] != nil {
			if err := m.SecondaryDataFilesDirList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("secondaryDataFilesDirList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("secondaryDataFilesDirList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var commonSqlAppSourceConfigTypeOverwritingPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FailIfExists","Overwrite"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		commonSqlAppSourceConfigTypeOverwritingPolicyPropEnum = append(commonSqlAppSourceConfigTypeOverwritingPolicyPropEnum, v)
	}
}

const (

	// CommonSQLAppSourceConfigOverwritingPolicyFailIfExists captures enum value "FailIfExists"
	CommonSQLAppSourceConfigOverwritingPolicyFailIfExists string = "FailIfExists"

	// CommonSQLAppSourceConfigOverwritingPolicyOverwrite captures enum value "Overwrite"
	CommonSQLAppSourceConfigOverwritingPolicyOverwrite string = "Overwrite"
)

// prop value enum
func (m *CommonSQLAppSourceConfig) validateOverwritingPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, commonSqlAppSourceConfigTypeOverwritingPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CommonSQLAppSourceConfig) validateOverwritingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.OverwritingPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateOverwritingPolicyEnum("overwritingPolicy", "body", *m.OverwritingPolicy); err != nil {
		return err
	}

	return nil
}

func (m *CommonSQLAppSourceConfig) validateMultiStageRestoreOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.MultiStageRestoreOptions) { // not required
		return nil
	}

	if m.MultiStageRestoreOptions != nil {
		if err := m.MultiStageRestoreOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("multiStageRestoreOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("multiStageRestoreOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this common Sql app source config based on the context it is used
func (m *CommonSQLAppSourceConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSecondaryDataFilesDirList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMultiStageRestoreOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CommonSQLAppSourceConfig) contextValidateSecondaryDataFilesDirList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SecondaryDataFilesDirList); i++ {

		if m.SecondaryDataFilesDirList[i] != nil {

			if swag.IsZero(m.SecondaryDataFilesDirList[i]) { // not required
				return nil
			}

			if err := m.SecondaryDataFilesDirList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("secondaryDataFilesDirList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("secondaryDataFilesDirList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CommonSQLAppSourceConfig) contextValidateMultiStageRestoreOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.MultiStageRestoreOptions != nil {

		if swag.IsZero(m.MultiStageRestoreOptions) { // not required
			return nil
		}

		if err := m.MultiStageRestoreOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("multiStageRestoreOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("multiStageRestoreOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CommonSQLAppSourceConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CommonSQLAppSourceConfig) UnmarshalBinary(b []byte) error {
	var res CommonSQLAppSourceConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
