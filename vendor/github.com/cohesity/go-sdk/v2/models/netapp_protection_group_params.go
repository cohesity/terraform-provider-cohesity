// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NetappProtectionGroupParams Specifies the parameters which are specific to Netapp related Protection Groups.
//
// swagger:model NetappProtectionGroupParams
type NetappProtectionGroupParams struct {

	// Specifies the objects to be included in the Protection Group.
	// Required: true
	// Min Items: 1
	// Unique: true
	Objects []*NetappProtectionGroupObjectParams `json:"objects"`

	// Specifies the objects to be excluded in the Protection Group.
	// Unique: true
	ExcludeObjectIds []int64 `json:"excludeObjectIds"`

	// Specifies whether or not to store the snapshots in this run directly in an Archive Target instead of on the Cluster. If this is set to true, the associated policy must have exactly one Archive Target associated with it and the policy must be set up to archive after every run. Also, a Storage Domain cannot be specified. Default behavior is 'false'.
	DirectCloudArchive *bool `json:"directCloudArchive,omitempty"`

	// Specifies whether or not to enable native format for direct archive job. This field is set to true if native format should be used for archiving.
	NativeFormat *bool `json:"nativeFormat,omitempty"`

	// Specifies the incremental and full snapshot label for Data-Protect Netapp Volumes backup. If snapMirrorConfig is provided then snapshotLabel should not be provided.
	SnapshotLabel *SnapshotLabel `json:"snapshotLabel,omitempty"`

	// Specifies the snapshot backup configuration if S3 views are used for backing up NetApp volumes. If snapshotLabel config is provided then snapMirrorConfig should not be provided.
	SnapMirrorConfig *SnapMirrorConfig `json:"snapMirrorConfig,omitempty"`

	// Specifies that snapshot label is not set for Data-Protect Netapp Volumes backup. If field is set to true, existing oldest snapshot is used for backup and subsequent incremental will be selected in ascending order of snapshot create time on the source. If snapshot label is set, this field is set to false.
	BackupExistingSnapshot *bool `json:"backupExistingSnapshot,omitempty"`

	// Specifies the fields required to enable indexing of the protected objects such as files and directories.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies the preferred protocol to use if this device supports multiple protocols.
	// Enum: ["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]
	Protocol *string `json:"protocol,omitempty"`

	// Specifies the preference of NFS version to be backed up if a volume supports multiple versions of NFS.
	// Enum: ["kNfs3","kNfs4_1"]
	NfsVersionPreference *string `json:"nfsVersionPreference,omitempty"`

	// Specifies whether or not the Protection Group should continue regardless of whether or not an error was encountered during protection group run.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Specifies whether the protection group should use encryption while backup or not.
	EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

	// Optional config that enables file locking for this view. It cannot be disabled during the edit of a view, if it has been enabled during the creation of the view. Also, it cannot be enabled if it was disabled during the creation of the view.
	FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

	// Specifies file paths to include or exclude.
	FileFilters *FileFilteringPolicy `json:"fileFilters,omitempty"`

	// Specifies the id of the parent of the objects.
	// Read Only: true
	SourceID *int64 `json:"sourceId,omitempty"`

	// Specifies the name of the parent of the objects.
	// Read Only: true
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the pre script and post script to run before and after the protection group.
	PrePostScript *HostBasedBackupScriptParams `json:"prePostScript,omitempty"`

	// Specifies the source snapshots to be taken even if there is a pending run in a protection group.
	ContinuousSnapshots *ContinuousSnapshotParams `json:"continuousSnapshots,omitempty"`

	// Specifies the list of IP addresses that are allowed or denied at the job level. Allowed IPs and Denied IPs cannot be used together.
	FilterIPConfig *FilterIPConfig `json:"filterIpConfig,omitempty"`

	// Specifies the source throttling parameters to be used during full or incremental backup of the NAS source.
	ThrottlingConfig *NasThrottlingConfig `json:"throttlingConfig,omitempty"`

	// Specifies if the Netapp source permissions should be modified internally to allow backups.
	ModifySourcePermissions *bool `json:"modifySourcePermissions,omitempty"`
}

// Validate validates this netapp protection group params
func (m *NetappProtectionGroupParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateObjects(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeObjectIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapMirrorConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsVersionPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileLockConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrePostScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContinuousSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilterIPConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThrottlingConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetappProtectionGroupParams) validateObjects(formats strfmt.Registry) error {

	if err := validate.Required("objects", "body", m.Objects); err != nil {
		return err
	}

	iObjectsSize := int64(len(m.Objects))

	if err := validate.MinItems("objects", "body", iObjectsSize, 1); err != nil {
		return err
	}

	if err := validate.UniqueItems("objects", "body", m.Objects); err != nil {
		return err
	}

	for i := 0; i < len(m.Objects); i++ {
		if swag.IsZero(m.Objects[i]) { // not required
			continue
		}

		if m.Objects[i] != nil {
			if err := m.Objects[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NetappProtectionGroupParams) validateExcludeObjectIds(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeObjectIds) { // not required
		return nil
	}

	if err := validate.UniqueItems("excludeObjectIds", "body", m.ExcludeObjectIds); err != nil {
		return err
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateSnapshotLabel(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotLabel) { // not required
		return nil
	}

	if m.SnapshotLabel != nil {
		if err := m.SnapshotLabel.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotLabel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotLabel")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateSnapMirrorConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapMirrorConfig) { // not required
		return nil
	}

	if m.SnapMirrorConfig != nil {
		if err := m.SnapMirrorConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapMirrorConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapMirrorConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateIndexingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IndexingPolicy) { // not required
		return nil
	}

	if m.IndexingPolicy != nil {
		if err := m.IndexingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

var netappProtectionGroupParamsTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		netappProtectionGroupParamsTypeProtocolPropEnum = append(netappProtectionGroupParamsTypeProtocolPropEnum, v)
	}
}

const (

	// NetappProtectionGroupParamsProtocolKNoProtocol captures enum value "kNoProtocol"
	NetappProtectionGroupParamsProtocolKNoProtocol string = "kNoProtocol"

	// NetappProtectionGroupParamsProtocolKNfs3 captures enum value "kNfs3"
	NetappProtectionGroupParamsProtocolKNfs3 string = "kNfs3"

	// NetappProtectionGroupParamsProtocolKNfs41 captures enum value "kNfs4_1"
	NetappProtectionGroupParamsProtocolKNfs41 string = "kNfs4_1"

	// NetappProtectionGroupParamsProtocolKCifs1 captures enum value "kCifs1"
	NetappProtectionGroupParamsProtocolKCifs1 string = "kCifs1"

	// NetappProtectionGroupParamsProtocolKCifs2 captures enum value "kCifs2"
	NetappProtectionGroupParamsProtocolKCifs2 string = "kCifs2"

	// NetappProtectionGroupParamsProtocolKCifs3 captures enum value "kCifs3"
	NetappProtectionGroupParamsProtocolKCifs3 string = "kCifs3"
)

// prop value enum
func (m *NetappProtectionGroupParams) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, netappProtectionGroupParamsTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NetappProtectionGroupParams) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

var netappProtectionGroupParamsTypeNfsVersionPreferencePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNfs3","kNfs4_1"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		netappProtectionGroupParamsTypeNfsVersionPreferencePropEnum = append(netappProtectionGroupParamsTypeNfsVersionPreferencePropEnum, v)
	}
}

const (

	// NetappProtectionGroupParamsNfsVersionPreferenceKNfs3 captures enum value "kNfs3"
	NetappProtectionGroupParamsNfsVersionPreferenceKNfs3 string = "kNfs3"

	// NetappProtectionGroupParamsNfsVersionPreferenceKNfs41 captures enum value "kNfs4_1"
	NetappProtectionGroupParamsNfsVersionPreferenceKNfs41 string = "kNfs4_1"
)

// prop value enum
func (m *NetappProtectionGroupParams) validateNfsVersionPreferenceEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, netappProtectionGroupParamsTypeNfsVersionPreferencePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NetappProtectionGroupParams) validateNfsVersionPreference(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsVersionPreference) { // not required
		return nil
	}

	// value enum
	if err := m.validateNfsVersionPreferenceEnum("nfsVersionPreference", "body", *m.NfsVersionPreference); err != nil {
		return err
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateFileLockConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FileLockConfig) { // not required
		return nil
	}

	if m.FileLockConfig != nil {
		if err := m.FileLockConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateFileFilters(formats strfmt.Registry) error {
	if swag.IsZero(m.FileFilters) { // not required
		return nil
	}

	if m.FileFilters != nil {
		if err := m.FileFilters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileFilters")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validatePrePostScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PrePostScript) { // not required
		return nil
	}

	if m.PrePostScript != nil {
		if err := m.PrePostScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prePostScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("prePostScript")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateContinuousSnapshots(formats strfmt.Registry) error {
	if swag.IsZero(m.ContinuousSnapshots) { // not required
		return nil
	}

	if m.ContinuousSnapshots != nil {
		if err := m.ContinuousSnapshots.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("continuousSnapshots")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("continuousSnapshots")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateFilterIPConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FilterIPConfig) { // not required
		return nil
	}

	if m.FilterIPConfig != nil {
		if err := m.FilterIPConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) validateThrottlingConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ThrottlingConfig) { // not required
		return nil
	}

	if m.ThrottlingConfig != nil {
		if err := m.ThrottlingConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this netapp protection group params based on the context it is used
func (m *NetappProtectionGroupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateObjects(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapMirrorConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIndexingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileLockConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrePostScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContinuousSnapshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilterIPConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThrottlingConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetappProtectionGroupParams) contextValidateObjects(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Objects); i++ {

		if m.Objects[i] != nil {

			if swag.IsZero(m.Objects[i]) { // not required
				return nil
			}

			if err := m.Objects[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateSnapshotLabel(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotLabel != nil {

		if swag.IsZero(m.SnapshotLabel) { // not required
			return nil
		}

		if err := m.SnapshotLabel.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotLabel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotLabel")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateSnapMirrorConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapMirrorConfig != nil {

		if swag.IsZero(m.SnapMirrorConfig) { // not required
			return nil
		}

		if err := m.SnapMirrorConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapMirrorConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapMirrorConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateIndexingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.IndexingPolicy != nil {

		if swag.IsZero(m.IndexingPolicy) { // not required
			return nil
		}

		if err := m.IndexingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateFileLockConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FileLockConfig != nil {

		if swag.IsZero(m.FileLockConfig) { // not required
			return nil
		}

		if err := m.FileLockConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateFileFilters(ctx context.Context, formats strfmt.Registry) error {

	if m.FileFilters != nil {

		if swag.IsZero(m.FileFilters) { // not required
			return nil
		}

		if err := m.FileFilters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileFilters")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateSourceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceId", "body", m.SourceID); err != nil {
		return err
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateSourceName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "sourceName", "body", m.SourceName); err != nil {
		return err
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidatePrePostScript(ctx context.Context, formats strfmt.Registry) error {

	if m.PrePostScript != nil {

		if swag.IsZero(m.PrePostScript) { // not required
			return nil
		}

		if err := m.PrePostScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("prePostScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("prePostScript")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateContinuousSnapshots(ctx context.Context, formats strfmt.Registry) error {

	if m.ContinuousSnapshots != nil {

		if swag.IsZero(m.ContinuousSnapshots) { // not required
			return nil
		}

		if err := m.ContinuousSnapshots.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("continuousSnapshots")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("continuousSnapshots")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateFilterIPConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FilterIPConfig != nil {

		if swag.IsZero(m.FilterIPConfig) { // not required
			return nil
		}

		if err := m.FilterIPConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NetappProtectionGroupParams) contextValidateThrottlingConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ThrottlingConfig != nil {

		if swag.IsZero(m.ThrottlingConfig) { // not required
			return nil
		}

		if err := m.ThrottlingConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NetappProtectionGroupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetappProtectionGroupParams) UnmarshalBinary(b []byte) error {
	var res NetappProtectionGroupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
