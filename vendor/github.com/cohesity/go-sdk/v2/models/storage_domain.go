// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StorageDomain Specifies a Storage Domain.
//
// swagger:model StorageDomain
type StorageDomain struct {

	// Specifies the Storage Domain id.
	// Read Only: true
	ID *int64 `json:"id,omitempty"`

	// Specifies the Storage Domain name.
	// Required: true
	Name *string `json:"name"`

	// Specifies the current removal state of the Storage Domain. 'DontRemove' means the state of object is functional and it is not being removed. 'MarkedForRemoval' means the object is being removed. 'OkToRemove' means the object has been removed on the Cohesity Cluster and if the object is physical, it can be removed from the Cohesity Cluster.
	// Read Only: true
	// Enum: ["DontRemove","MarkedForRemoval","OkToRemove"]
	RemovalState *string `json:"removalState,omitempty"`

	// Specifies the cluster partition id of the Storage Domain.
	// Required: true
	ClusterPartitionID *int64 `json:"clusterPartitionId"`

	// Specifies the cluster partition name of the Storage Domain.
	// Read Only: true
	ClusterPartitionName *string `json:"clusterPartitionName,omitempty"`

	// Specifies a list of Subnets with IP addresses that have permissions to access the Storage Domain.
	SubnetWhitelist []*Subnet `json:"subnetWhitelist"`

	// Specifies whether to enable creation of S3 bucket on this Storage Domain.
	S3BucketsEnabled *bool `json:"s3BucketsEnabled,omitempty"`

	// Specifies the Active Directory domain name that this Storage Domain is mapped to.
	AdDomainName *string `json:"adDomainName,omitempty"`

	// Specifies the NIS domain names that this Storage Domain is mapped to.
	NisDomainNames []string `json:"nisDomainNames"`

	// Specifies the Kerberos realm name that this Storage Domain is mapped to.
	KerberosRealmName *string `json:"kerberosRealmName,omitempty"`

	// Specifies the LDAP provider id that this Storage Domain is mapped to.
	LdapProviderID *int64 `json:"ldapProviderId,omitempty"`

	// Specifies a list of tenant ids that that Storage Domain belongs. There can only be one tenant id in this field unless Storage Domain sharing between tenants is allowed on this cluster.
	TenantIds []string `json:"tenantIds"`

	// Specifies whether to enable driect archive on this Storage Domain. If enabled, this Storage Domain can be used as a staging area while copying a large dataset that can't fit on the cluster to an external target.
	DirectArchiveEnabled *bool `json:"directArchiveEnabled,omitempty"`

	// Specifies the brick size used for blobs in this Storage Domain.
	BlobBrickSizeBytes *int32 `json:"blobBrickSizeBytes,omitempty"`

	// Specifies the associated KMS server id.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// Specifies whether DEK(Data Encryption Key) rotation is enabled for this Storage Domain. This is applicable only when the Storage Domain uses AWS or similar KMS in which the KEK (Key Encryption Key) is not created and maintained by Cohesity. For Internal KMS and keys stored in Safenet servers, DEK rotation will not be performed.
	DekRotationEnabled *bool `json:"dekRotationEnabled,omitempty"`

	// If 'true', when the Cohesity Cluster is writing to a file, the file modification time is not persisted synchronously during the file write, so the modification time may not be accurate. (Typically the file modification time is off by 30 seconds but it can be longer.)
	TreatFileSyncAsDataSync *bool `json:"treatFileSyncAsDataSync,omitempty"`

	// Specifies whether Storage Domain is recommended for the specified View template.
	// Read Only: true
	Recommended *bool `json:"recommended,omitempty"`

	// Specifies the Storage Domain schemas.
	// Read Only: true
	Schemas []*Schema `json:"schemas"`

	// Specifies the file count by size for the View.
	// Read Only: true
	FileCountBySize []*FileCount `json:"fileCountBySize"`

	// Specifies the cloud domain Id.
	CloudDomainID *int64 `json:"cloudDomainId,omitempty"`

	// Specifies the vault Id associated with cloud domain ID.
	VaultID *int64 `json:"vaultId,omitempty"`

	// Last key rotation timestamp in msecs for storage domain.
	LastKeyRotationTimestampMsecs *int64 `json:"lastKeyRotationTimestampMsecs,omitempty"`

	// Specifies the cloud down water fall parameters for this Storage Domain.
	CloudDownWaterFallParams *CloudDownWaterFallParams `json:"cloudDownWaterFallParams,omitempty"`

	// Specifies a default user quota limit for users within views in this Storage Domain.
	DefaultUserQuota *QuotaPolicy `json:"defaultUserQuota,omitempty"`

	// Specifies a default logical quota limit for all views in this Storage Domain. This quota can be overwritten by a view level quota.
	DefaultViewQuota *QuotaPolicy `json:"defaultViewQuota,omitempty"`

	// Specifies a quota limit for physical usage of this Storage Domain. This quota defines a limit of data that can be physically (after data size is reduced by block tracking, compression and deduplication) stored on this storage domain. A new write will not be allowed when the storage domain usage will exceeds the specified quota. Due to the latency of calculating usage across all nodes, the actual storage domain usage may exceed the quota limit by a little bit.
	PhysicalQuota *QuotaPolicy `json:"physicalQuota,omitempty"`

	// Specifies the Storage Domain stats.
	// Read Only: true
	Stats *DataUsageStats `json:"stats,omitempty"`

	// Specifies the storage policy for this Storage Domain.
	StoragePolicy *StoragePolicy `json:"storagePolicy,omitempty"`
}

// Validate validates this storage domain
func (m *StorageDomain) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterPartitionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubnetWhitelist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileCountBySize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudDownWaterFallParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultUserQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultViewQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoragePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StorageDomain) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var storageDomainTypeRemovalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DontRemove","MarkedForRemoval","OkToRemove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storageDomainTypeRemovalStatePropEnum = append(storageDomainTypeRemovalStatePropEnum, v)
	}
}

const (

	// StorageDomainRemovalStateDontRemove captures enum value "DontRemove"
	StorageDomainRemovalStateDontRemove string = "DontRemove"

	// StorageDomainRemovalStateMarkedForRemoval captures enum value "MarkedForRemoval"
	StorageDomainRemovalStateMarkedForRemoval string = "MarkedForRemoval"

	// StorageDomainRemovalStateOkToRemove captures enum value "OkToRemove"
	StorageDomainRemovalStateOkToRemove string = "OkToRemove"
)

// prop value enum
func (m *StorageDomain) validateRemovalStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, storageDomainTypeRemovalStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *StorageDomain) validateRemovalState(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemovalStateEnum("removalState", "body", *m.RemovalState); err != nil {
		return err
	}

	return nil
}

func (m *StorageDomain) validateClusterPartitionID(formats strfmt.Registry) error {

	if err := validate.Required("clusterPartitionId", "body", m.ClusterPartitionID); err != nil {
		return err
	}

	return nil
}

func (m *StorageDomain) validateSubnetWhitelist(formats strfmt.Registry) error {
	if swag.IsZero(m.SubnetWhitelist) { // not required
		return nil
	}

	for i := 0; i < len(m.SubnetWhitelist); i++ {
		if swag.IsZero(m.SubnetWhitelist[i]) { // not required
			continue
		}

		if m.SubnetWhitelist[i] != nil {
			if err := m.SubnetWhitelist[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDomain) validateSchemas(formats strfmt.Registry) error {
	if swag.IsZero(m.Schemas) { // not required
		return nil
	}

	for i := 0; i < len(m.Schemas); i++ {
		if swag.IsZero(m.Schemas[i]) { // not required
			continue
		}

		if m.Schemas[i] != nil {
			if err := m.Schemas[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schemas" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schemas" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDomain) validateFileCountBySize(formats strfmt.Registry) error {
	if swag.IsZero(m.FileCountBySize) { // not required
		return nil
	}

	for i := 0; i < len(m.FileCountBySize); i++ {
		if swag.IsZero(m.FileCountBySize[i]) { // not required
			continue
		}

		if m.FileCountBySize[i] != nil {
			if err := m.FileCountBySize[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileCountBySize" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileCountBySize" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDomain) validateCloudDownWaterFallParams(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudDownWaterFallParams) { // not required
		return nil
	}

	if m.CloudDownWaterFallParams != nil {
		if err := m.CloudDownWaterFallParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudDownWaterFallParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudDownWaterFallParams")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) validateDefaultUserQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultUserQuota) { // not required
		return nil
	}

	if m.DefaultUserQuota != nil {
		if err := m.DefaultUserQuota.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultUserQuota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultUserQuota")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) validateDefaultViewQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultViewQuota) { // not required
		return nil
	}

	if m.DefaultViewQuota != nil {
		if err := m.DefaultViewQuota.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultViewQuota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultViewQuota")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) validatePhysicalQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalQuota) { // not required
		return nil
	}

	if m.PhysicalQuota != nil {
		if err := m.PhysicalQuota.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("physicalQuota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("physicalQuota")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) validateStoragePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.StoragePolicy) { // not required
		return nil
	}

	if m.StoragePolicy != nil {
		if err := m.StoragePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this storage domain based on the context it is used
func (m *StorageDomain) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemovalState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterPartitionName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubnetWhitelist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecommended(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileCountBySize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudDownWaterFallParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultUserQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultViewQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStoragePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StorageDomain) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *StorageDomain) contextValidateRemovalState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "removalState", "body", m.RemovalState); err != nil {
		return err
	}

	return nil
}

func (m *StorageDomain) contextValidateClusterPartitionName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterPartitionName", "body", m.ClusterPartitionName); err != nil {
		return err
	}

	return nil
}

func (m *StorageDomain) contextValidateSubnetWhitelist(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SubnetWhitelist); i++ {

		if m.SubnetWhitelist[i] != nil {

			if swag.IsZero(m.SubnetWhitelist[i]) { // not required
				return nil
			}

			if err := m.SubnetWhitelist[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDomain) contextValidateRecommended(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "recommended", "body", m.Recommended); err != nil {
		return err
	}

	return nil
}

func (m *StorageDomain) contextValidateSchemas(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "schemas", "body", []*Schema(m.Schemas)); err != nil {
		return err
	}

	for i := 0; i < len(m.Schemas); i++ {

		if m.Schemas[i] != nil {

			if swag.IsZero(m.Schemas[i]) { // not required
				return nil
			}

			if err := m.Schemas[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schemas" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schemas" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDomain) contextValidateFileCountBySize(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fileCountBySize", "body", []*FileCount(m.FileCountBySize)); err != nil {
		return err
	}

	for i := 0; i < len(m.FileCountBySize); i++ {

		if m.FileCountBySize[i] != nil {

			if swag.IsZero(m.FileCountBySize[i]) { // not required
				return nil
			}

			if err := m.FileCountBySize[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileCountBySize" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileCountBySize" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StorageDomain) contextValidateCloudDownWaterFallParams(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudDownWaterFallParams != nil {

		if swag.IsZero(m.CloudDownWaterFallParams) { // not required
			return nil
		}

		if err := m.CloudDownWaterFallParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudDownWaterFallParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudDownWaterFallParams")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) contextValidateDefaultUserQuota(ctx context.Context, formats strfmt.Registry) error {

	if m.DefaultUserQuota != nil {

		if swag.IsZero(m.DefaultUserQuota) { // not required
			return nil
		}

		if err := m.DefaultUserQuota.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultUserQuota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultUserQuota")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) contextValidateDefaultViewQuota(ctx context.Context, formats strfmt.Registry) error {

	if m.DefaultViewQuota != nil {

		if swag.IsZero(m.DefaultViewQuota) { // not required
			return nil
		}

		if err := m.DefaultViewQuota.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultViewQuota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultViewQuota")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) contextValidatePhysicalQuota(ctx context.Context, formats strfmt.Registry) error {

	if m.PhysicalQuota != nil {

		if swag.IsZero(m.PhysicalQuota) { // not required
			return nil
		}

		if err := m.PhysicalQuota.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("physicalQuota")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("physicalQuota")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if swag.IsZero(m.Stats) { // not required
			return nil
		}

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *StorageDomain) contextValidateStoragePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.StoragePolicy != nil {

		if swag.IsZero(m.StoragePolicy) { // not required
			return nil
		}

		if err := m.StoragePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StorageDomain) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StorageDomain) UnmarshalBinary(b []byte) error {
	var res StorageDomain
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
