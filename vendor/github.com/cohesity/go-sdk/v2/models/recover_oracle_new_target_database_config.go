// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RecoverOracleNewTargetDatabaseConfig Recover Oracle App New Database Target Config.
//
// Specifies recovery parameters when recovering to a database.
//
// swagger:model RecoverOracleNewTargetDatabaseConfig
type RecoverOracleNewTargetDatabaseConfig struct {
	CommonOracleAppSourceConfig

	// Specifies a new name for the restored database. If this field is not specified, then the original database will be overwritten after recovery.
	DatabaseName *string `json:"databaseName,omitempty"`

	// Specifies the oracle base folder at selected host.
	OracleBaseFolder *string `json:"oracleBaseFolder,omitempty"`

	// Specifies the oracle home folder at selected host.
	OracleHomeFolder *string `json:"oracleHomeFolder,omitempty"`

	// Specifies the location to restore database files.
	DbFilesDestination *string `json:"dbFilesDestination,omitempty"`

	// Specifies the config file path on selected host which configures the restored database.
	DbConfigFilePath *string `json:"dbConfigFilePath,omitempty"`

	// Specifies archive log mode for oracle restore.
	EnableArchiveLogMode *bool `json:"enableArchiveLogMode,omitempty"`

	// Specifies a key value pair for pfile parameters.
	PfileParameterMap []*KeyValuePair `json:"pfileParameterMap"`

	// Specifies BCT file path.
	BctFilePath *string `json:"bctFilePath,omitempty"`

	// Specifies no. of tempfiles to be used for the recovered database.
	NumTempfiles *int32 `json:"numTempfiles,omitempty"`

	// Specifies whether this task is a multistage restore task. If set, we migrate the DB after clone completes.
	IsMultiStageRestore *bool `json:"isMultiStageRestore,omitempty"`

	// Whether or not to skip the nid step in Oracle Clone workflow. Applicable to both smart and old clone workflow.
	SkipCloneNid *bool `json:"skipCloneNid,omitempty"`

	// Specifies whether to validate filenames or not in Oracle alternate restore workflow.
	NoFilenameCheck *bool `json:"noFilenameCheck,omitempty"`

	// Specifies newname clause for db files which allows user to have full control on how their database files can be renamed during the oracle alternate restore workflow.
	NewNameClause *string `json:"newNameClause,omitempty"`

	// Oracle Disaster Recovery parameters.
	//
	// Specifies the parameters that are needed for Disaster Recovery of a database to its production configuration.
	DisasterRecoveryOptions *DisasterRecoveryOptions `json:"disasterRecoveryOptions,omitempty"`

	// Whether or not to restore to a RAC database.
	RestoreToRac *bool `json:"restoreToRac,omitempty"`

	// Specifies the parameters that are needed for updating oracle restore options.
	OracleUpdateRestoreOptions *MigrateCloneParams `json:"oracleUpdateRestoreOptions,omitempty"`

	// Specifies redo log config.
	RedoLogConfig *RedoLogGroupConfig `json:"redoLogConfig,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *RecoverOracleNewTargetDatabaseConfig) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 CommonOracleAppSourceConfig
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.CommonOracleAppSourceConfig = aO0

	// now for regular properties
	var propsRecoverOracleNewTargetDatabaseConfig struct {
		DatabaseName *string `json:"databaseName,omitempty"`

		OracleBaseFolder *string `json:"oracleBaseFolder,omitempty"`

		OracleHomeFolder *string `json:"oracleHomeFolder,omitempty"`

		DbFilesDestination *string `json:"dbFilesDestination,omitempty"`

		DbConfigFilePath *string `json:"dbConfigFilePath,omitempty"`

		EnableArchiveLogMode *bool `json:"enableArchiveLogMode,omitempty"`

		PfileParameterMap []*KeyValuePair `json:"pfileParameterMap"`

		BctFilePath *string `json:"bctFilePath,omitempty"`

		NumTempfiles *int32 `json:"numTempfiles,omitempty"`

		IsMultiStageRestore *bool `json:"isMultiStageRestore,omitempty"`

		SkipCloneNid *bool `json:"skipCloneNid,omitempty"`

		NoFilenameCheck *bool `json:"noFilenameCheck,omitempty"`

		NewNameClause *string `json:"newNameClause,omitempty"`

		DisasterRecoveryOptions *DisasterRecoveryOptions `json:"disasterRecoveryOptions,omitempty"`

		RestoreToRac *bool `json:"restoreToRac,omitempty"`

		OracleUpdateRestoreOptions *MigrateCloneParams `json:"oracleUpdateRestoreOptions,omitempty"`

		RedoLogConfig *RedoLogGroupConfig `json:"redoLogConfig,omitempty"`
	}
	if err := swag.ReadJSON(raw, &propsRecoverOracleNewTargetDatabaseConfig); err != nil {
		return err
	}
	m.DatabaseName = propsRecoverOracleNewTargetDatabaseConfig.DatabaseName

	m.OracleBaseFolder = propsRecoverOracleNewTargetDatabaseConfig.OracleBaseFolder

	m.OracleHomeFolder = propsRecoverOracleNewTargetDatabaseConfig.OracleHomeFolder

	m.DbFilesDestination = propsRecoverOracleNewTargetDatabaseConfig.DbFilesDestination

	m.DbConfigFilePath = propsRecoverOracleNewTargetDatabaseConfig.DbConfigFilePath

	m.EnableArchiveLogMode = propsRecoverOracleNewTargetDatabaseConfig.EnableArchiveLogMode

	m.PfileParameterMap = propsRecoverOracleNewTargetDatabaseConfig.PfileParameterMap

	m.BctFilePath = propsRecoverOracleNewTargetDatabaseConfig.BctFilePath

	m.NumTempfiles = propsRecoverOracleNewTargetDatabaseConfig.NumTempfiles

	m.IsMultiStageRestore = propsRecoverOracleNewTargetDatabaseConfig.IsMultiStageRestore

	m.SkipCloneNid = propsRecoverOracleNewTargetDatabaseConfig.SkipCloneNid

	m.NoFilenameCheck = propsRecoverOracleNewTargetDatabaseConfig.NoFilenameCheck

	m.NewNameClause = propsRecoverOracleNewTargetDatabaseConfig.NewNameClause

	m.DisasterRecoveryOptions = propsRecoverOracleNewTargetDatabaseConfig.DisasterRecoveryOptions

	m.RestoreToRac = propsRecoverOracleNewTargetDatabaseConfig.RestoreToRac

	m.OracleUpdateRestoreOptions = propsRecoverOracleNewTargetDatabaseConfig.OracleUpdateRestoreOptions

	m.RedoLogConfig = propsRecoverOracleNewTargetDatabaseConfig.RedoLogConfig

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m RecoverOracleNewTargetDatabaseConfig) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.CommonOracleAppSourceConfig)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	// now for regular properties
	var propsRecoverOracleNewTargetDatabaseConfig struct {
		DatabaseName *string `json:"databaseName,omitempty"`

		OracleBaseFolder *string `json:"oracleBaseFolder,omitempty"`

		OracleHomeFolder *string `json:"oracleHomeFolder,omitempty"`

		DbFilesDestination *string `json:"dbFilesDestination,omitempty"`

		DbConfigFilePath *string `json:"dbConfigFilePath,omitempty"`

		EnableArchiveLogMode *bool `json:"enableArchiveLogMode,omitempty"`

		PfileParameterMap []*KeyValuePair `json:"pfileParameterMap"`

		BctFilePath *string `json:"bctFilePath,omitempty"`

		NumTempfiles *int32 `json:"numTempfiles,omitempty"`

		IsMultiStageRestore *bool `json:"isMultiStageRestore,omitempty"`

		SkipCloneNid *bool `json:"skipCloneNid,omitempty"`

		NoFilenameCheck *bool `json:"noFilenameCheck,omitempty"`

		NewNameClause *string `json:"newNameClause,omitempty"`

		DisasterRecoveryOptions *DisasterRecoveryOptions `json:"disasterRecoveryOptions,omitempty"`

		RestoreToRac *bool `json:"restoreToRac,omitempty"`

		OracleUpdateRestoreOptions *MigrateCloneParams `json:"oracleUpdateRestoreOptions,omitempty"`

		RedoLogConfig *RedoLogGroupConfig `json:"redoLogConfig,omitempty"`
	}
	propsRecoverOracleNewTargetDatabaseConfig.DatabaseName = m.DatabaseName

	propsRecoverOracleNewTargetDatabaseConfig.OracleBaseFolder = m.OracleBaseFolder

	propsRecoverOracleNewTargetDatabaseConfig.OracleHomeFolder = m.OracleHomeFolder

	propsRecoverOracleNewTargetDatabaseConfig.DbFilesDestination = m.DbFilesDestination

	propsRecoverOracleNewTargetDatabaseConfig.DbConfigFilePath = m.DbConfigFilePath

	propsRecoverOracleNewTargetDatabaseConfig.EnableArchiveLogMode = m.EnableArchiveLogMode

	propsRecoverOracleNewTargetDatabaseConfig.PfileParameterMap = m.PfileParameterMap

	propsRecoverOracleNewTargetDatabaseConfig.BctFilePath = m.BctFilePath

	propsRecoverOracleNewTargetDatabaseConfig.NumTempfiles = m.NumTempfiles

	propsRecoverOracleNewTargetDatabaseConfig.IsMultiStageRestore = m.IsMultiStageRestore

	propsRecoverOracleNewTargetDatabaseConfig.SkipCloneNid = m.SkipCloneNid

	propsRecoverOracleNewTargetDatabaseConfig.NoFilenameCheck = m.NoFilenameCheck

	propsRecoverOracleNewTargetDatabaseConfig.NewNameClause = m.NewNameClause

	propsRecoverOracleNewTargetDatabaseConfig.DisasterRecoveryOptions = m.DisasterRecoveryOptions

	propsRecoverOracleNewTargetDatabaseConfig.RestoreToRac = m.RestoreToRac

	propsRecoverOracleNewTargetDatabaseConfig.OracleUpdateRestoreOptions = m.OracleUpdateRestoreOptions

	propsRecoverOracleNewTargetDatabaseConfig.RedoLogConfig = m.RedoLogConfig

	jsonDataPropsRecoverOracleNewTargetDatabaseConfig, errRecoverOracleNewTargetDatabaseConfig := swag.WriteJSON(propsRecoverOracleNewTargetDatabaseConfig)
	if errRecoverOracleNewTargetDatabaseConfig != nil {
		return nil, errRecoverOracleNewTargetDatabaseConfig
	}
	_parts = append(_parts, jsonDataPropsRecoverOracleNewTargetDatabaseConfig)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this recover oracle new target database config
func (m *RecoverOracleNewTargetDatabaseConfig) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with CommonOracleAppSourceConfig
	if err := m.CommonOracleAppSourceConfig.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePfileParameterMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisasterRecoveryOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOracleUpdateRestoreOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedoLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) validatePfileParameterMap(formats strfmt.Registry) error {
	if swag.IsZero(m.PfileParameterMap) { // not required
		return nil
	}

	for i := 0; i < len(m.PfileParameterMap); i++ {
		if swag.IsZero(m.PfileParameterMap[i]) { // not required
			continue
		}

		if m.PfileParameterMap[i] != nil {
			if err := m.PfileParameterMap[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pfileParameterMap" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pfileParameterMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) validateDisasterRecoveryOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.DisasterRecoveryOptions) { // not required
		return nil
	}

	if m.DisasterRecoveryOptions != nil {
		if err := m.DisasterRecoveryOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("disasterRecoveryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("disasterRecoveryOptions")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) validateOracleUpdateRestoreOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.OracleUpdateRestoreOptions) { // not required
		return nil
	}

	if m.OracleUpdateRestoreOptions != nil {
		if err := m.OracleUpdateRestoreOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracleUpdateRestoreOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracleUpdateRestoreOptions")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) validateRedoLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.RedoLogConfig) { // not required
		return nil
	}

	if m.RedoLogConfig != nil {
		if err := m.RedoLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("redoLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("redoLogConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this recover oracle new target database config based on the context it is used
func (m *RecoverOracleNewTargetDatabaseConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with CommonOracleAppSourceConfig
	if err := m.CommonOracleAppSourceConfig.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePfileParameterMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDisasterRecoveryOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOracleUpdateRestoreOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRedoLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) contextValidatePfileParameterMap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PfileParameterMap); i++ {

		if m.PfileParameterMap[i] != nil {

			if swag.IsZero(m.PfileParameterMap[i]) { // not required
				return nil
			}

			if err := m.PfileParameterMap[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pfileParameterMap" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pfileParameterMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) contextValidateDisasterRecoveryOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.DisasterRecoveryOptions != nil {

		if swag.IsZero(m.DisasterRecoveryOptions) { // not required
			return nil
		}

		if err := m.DisasterRecoveryOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("disasterRecoveryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("disasterRecoveryOptions")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) contextValidateOracleUpdateRestoreOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.OracleUpdateRestoreOptions != nil {

		if swag.IsZero(m.OracleUpdateRestoreOptions) { // not required
			return nil
		}

		if err := m.OracleUpdateRestoreOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oracleUpdateRestoreOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oracleUpdateRestoreOptions")
			}
			return err
		}
	}

	return nil
}

func (m *RecoverOracleNewTargetDatabaseConfig) contextValidateRedoLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.RedoLogConfig != nil {

		if swag.IsZero(m.RedoLogConfig) { // not required
			return nil
		}

		if err := m.RedoLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("redoLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("redoLogConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecoverOracleNewTargetDatabaseConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecoverOracleNewTargetDatabaseConfig) UnmarshalBinary(b []byte) error {
	var res RecoverOracleNewTargetDatabaseConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
