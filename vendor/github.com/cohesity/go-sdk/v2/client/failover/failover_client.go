// Code generated by go-swagger; DO NOT EDIT.

package failover

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new failover API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new failover API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new failover API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for failover API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CancelFailover(params *CancelFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CancelFailoverCreated, error)

	CancelViewFailover(params *CancelViewFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CancelViewFailoverNoContent, error)

	CreatePlannedRun(params *CreatePlannedRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreatePlannedRunCreated, error)

	CreateViewFailover(params *CreateViewFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateViewFailoverCreated, error)

	GetFailoverOps(params *GetFailoverOpsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFailoverOpsOK, error)

	GetTrackingViewID(params *GetTrackingViewIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetTrackingViewIDOK, error)

	GetViewFailover(params *GetViewFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetViewFailoverOK, error)

	InitFailover(params *InitFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InitFailoverCreated, error)

	ObjectLinkage(params *ObjectLinkageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ObjectLinkageCreated, error)

	PollPlannedRuns(params *PollPlannedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PollPlannedRunsOK, error)

	ReplicationBackupActivation(params *ReplicationBackupActivationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplicationBackupActivationCreated, error)

	SourceBackupDeactivation(params *SourceBackupDeactivationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SourceBackupDeactivationCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CancelFailover cancels failover workflow

**Privileges:** ```RESTORE_MODIFY``` <br><br>Specifies the request to cancel failover workflow. The cancellation request should not be made if '/backupActivation' or '/backupDeactivaetion' are already called on replication or source cluster respectively.
*/
func (a *Client) CancelFailover(params *CancelFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CancelFailoverCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelFailoverParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CancelFailover",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/{id}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CancelFailoverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CancelFailoverCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CancelFailoverDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CancelViewFailover cancels view failover task

**Privileges:** ```STORAGE_MODIFY``` <br><br>Cancel an in progress view failover task.
*/
func (a *Client) CancelViewFailover(params *CancelViewFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CancelViewFailoverNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCancelViewFailoverParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CancelViewFailover",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/views/{id}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CancelViewFailoverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CancelViewFailoverNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CancelViewFailoverDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreatePlannedRun creates a planned run for backup and replication

**Privileges:** ```RESTORE_MODIFY``` <br><br>Specifies the configuration required for executing a special run as a part of failover workflow. This special run is triggered during palnned failover to sync the source cluster to replication cluster with minimum possible delta.
*/
func (a *Client) CreatePlannedRun(params *CreatePlannedRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreatePlannedRunCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePlannedRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreatePlannedRun",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/{id}/planned-run",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreatePlannedRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreatePlannedRunCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreatePlannedRunDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateViewFailover creates view failover task

**Privileges:** ```STORAGE_MODIFY``` <br><br>Create a view failover task.
*/
func (a *Client) CreateViewFailover(params *CreateViewFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateViewFailoverCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateViewFailoverParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateViewFailover",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/views/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateViewFailoverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateViewFailoverCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateViewFailoverDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetFailoverOps gets all the failover operations which can be performed on this view

**Privileges:** ```STORAGE_VIEW``` <br><br>Gets all the failover operations which can be performed on this view.
*/
func (a *Client) GetFailoverOps(params *GetFailoverOpsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFailoverOpsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFailoverOpsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetFailoverOps",
		Method:             "GET",
		PathPattern:        "/data-protect/failover/views/{id}/operations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFailoverOpsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetFailoverOpsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetFailoverOpsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetTrackingViewID gets tracking view Id

**Privileges:** ```STORAGE_VIEW``` <br><br>Get tracking View Id
*/
func (a *Client) GetTrackingViewID(params *GetTrackingViewIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetTrackingViewIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTrackingViewIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetTrackingViewId",
		Method:             "GET",
		PathPattern:        "/data-protect/failover/views/trackingViewId/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTrackingViewIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetTrackingViewIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetTrackingViewIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetViewFailover gets view failover

**Privileges:** ```STORAGE_VIEW``` <br><br>Get failover tasks of a View.
*/
func (a *Client) GetViewFailover(params *GetViewFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetViewFailoverOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetViewFailoverParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetViewFailover",
		Method:             "GET",
		PathPattern:        "/data-protect/failover/views/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetViewFailoverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetViewFailoverOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetViewFailoverDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
InitFailover initiates a failover request

**Privileges:** ```RESTORE_MODIFY``` <br><br>Initiate a failover request.
*/
func (a *Client) InitFailover(params *InitFailoverParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InitFailoverCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInitFailoverParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InitFailover",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InitFailoverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InitFailoverCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InitFailoverDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ObjectLinkage linkings between replicated objects and failover objects

**Privileges:** ```RESTORE_MODIFY``` <br><br>Specifies the request to link failover objects on replication cluster to the replicated entity from source cluster. This linking need to be done after perforing recoveries for failed entities on replication cluster. This linkage will be useful when merging snapshots of object across replications and failovers.
*/
func (a *Client) ObjectLinkage(params *ObjectLinkageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ObjectLinkageCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewObjectLinkageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ObjectLinkage",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/{id}/object-linkage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ObjectLinkageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ObjectLinkageCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ObjectLinkageDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PollPlannedRuns gets the list of failover planned runs

**Privileges:** ```RESTORE_MODIFY``` <br><br>Poll to see whether planned run has been scheduled or not.
*/
func (a *Client) PollPlannedRuns(params *PollPlannedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PollPlannedRunsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPollPlannedRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PollPlannedRuns",
		Method:             "GET",
		PathPattern:        "/data-protect/failover/planned-runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PollPlannedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PollPlannedRunsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PollPlannedRunsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ReplicationBackupActivation activates failover entity backup on replication clsuter

**Privileges:** ```RESTORE_MODIFY``` <br><br>Specifies the configuration required for activating backup for failover objects on replication cluster. Here orchastrator can call this API multiple times as long as full set of object are non-overlapping. They can also use the existing job if its compatible to backup failover objects.
*/
func (a *Client) ReplicationBackupActivation(params *ReplicationBackupActivationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReplicationBackupActivationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplicationBackupActivationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ReplicationBackupActivation",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/{id}/backup-activation",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ReplicationBackupActivationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ReplicationBackupActivationCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ReplicationBackupActivationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SourceBackupDeactivation deactivates failover entity backup on source clsuter

**Privileges:** ```RESTORE_MODIFY``` <br><br>Specifies the configuration required for deactivating backup for failover entities on source cluster.
*/
func (a *Client) SourceBackupDeactivation(params *SourceBackupDeactivationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SourceBackupDeactivationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSourceBackupDeactivationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SourceBackupDeactivation",
		Method:             "POST",
		PathPattern:        "/data-protect/failover/{id}/backup-deactivation",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SourceBackupDeactivationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SourceBackupDeactivationCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SourceBackupDeactivationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
