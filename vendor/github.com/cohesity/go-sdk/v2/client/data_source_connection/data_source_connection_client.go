// Code generated by go-swagger; DO NOT EDIT.

package data_source_connection

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new data source connection API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new data source connection API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new data source connection API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for data source connection API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateDataSourceConnection(params *CreateDataSourceConnectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDataSourceConnectionCreated, error)

	DeleteDataSourceConnection(params *DeleteDataSourceConnectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDataSourceConnectionNoContent, error)

	GenerateDataSourceConnectionRegistrationToken(params *GenerateDataSourceConnectionRegistrationTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateDataSourceConnectionRegistrationTokenOK, error)

	GetConnectionsUpgradeConfig(params *GetConnectionsUpgradeConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionsUpgradeConfigOK, error)

	GetDataSourceConnections(params *GetDataSourceConnectionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDataSourceConnectionsOK, error)

	PatchDataSourceConnection(params *PatchDataSourceConnectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchDataSourceConnectionOK, error)

	ResetConnectionUpgrade(params *ResetConnectionUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResetConnectionUpgradeNoContent, error)

	UpdateConnectionsUpgradeConfig(params *UpdateConnectionsUpgradeConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConnectionsUpgradeConfigOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateDataSourceConnection creates a data source connection

**Privileges:** ```DATA_SOURCE_CONNECTION_MODIFY``` <br><br>Creates a data-source connection which can be used to register and protect sources, to access filer services, etc.
*/
func (a *Client) CreateDataSourceConnection(params *CreateDataSourceConnectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateDataSourceConnectionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDataSourceConnectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateDataSourceConnection",
		Method:             "POST",
		PathPattern:        "/data-source-connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateDataSourceConnectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateDataSourceConnectionCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateDataSourceConnectionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteDataSourceConnection deletes the data source connection specified by the ID in the request path

**Privileges:** ```DATA_SOURCE_CONNECTION_MODIFY``` <br><br>Delete a data-source connection using its ID. After deleting a connection, any connectors within it won't be able to connect to the cluster. A connection should only be deleted after ensuring that no sources are using it.
*/
func (a *Client) DeleteDataSourceConnection(params *DeleteDataSourceConnectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteDataSourceConnectionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDataSourceConnectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteDataSourceConnection",
		Method:             "DELETE",
		PathPattern:        "/data-source-connections/{connectionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDataSourceConnectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteDataSourceConnectionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteDataSourceConnectionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GenerateDataSourceConnectionRegistrationToken generates registration token for a data source connection

**Privileges:** ```DATA_SOURCE_CONNECTION_MODIFY``` <br><br>Generate a token to register connectors against the data-source connection specified by the ID in the request path. The same token can be used to register multiple connectors as long as the token is valid. Once the token expires, typically in a day, this API can be hit again to generate another token.
*/
func (a *Client) GenerateDataSourceConnectionRegistrationToken(params *GenerateDataSourceConnectionRegistrationTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateDataSourceConnectionRegistrationTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGenerateDataSourceConnectionRegistrationTokenParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GenerateDataSourceConnectionRegistrationToken",
		Method:             "POST",
		PathPattern:        "/data-source-connections/{connectionId}/registrationToken",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GenerateDataSourceConnectionRegistrationTokenReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GenerateDataSourceConnectionRegistrationTokenOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GenerateDataSourceConnectionRegistrationTokenDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetConnectionsUpgradeConfig gets upgrade connections config

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get upgrade connections config.
*/
func (a *Client) GetConnectionsUpgradeConfig(params *GetConnectionsUpgradeConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionsUpgradeConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConnectionsUpgradeConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetConnectionsUpgradeConfig",
		Method:             "GET",
		PathPattern:        "/data-source-connections/upgrade-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConnectionsUpgradeConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetConnectionsUpgradeConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetConnectionsUpgradeConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetDataSourceConnections gets data source connections

**Privileges:** ```DATA_SOURCE_CONNECTION_VIEW, CLUSTER_VIEW``` <br><br>Gets all specified data-source connections.
*/
func (a *Client) GetDataSourceConnections(params *GetDataSourceConnectionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDataSourceConnectionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDataSourceConnectionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetDataSourceConnections",
		Method:             "GET",
		PathPattern:        "/data-source-connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetDataSourceConnectionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetDataSourceConnectionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetDataSourceConnectionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchDataSourceConnection patches a data source connection using its ID

**Privileges:** ```DATA_SOURCE_CONNECTION_MODIFY``` <br><br>Patch the data-source connection specified by the ID in the request path.
*/
func (a *Client) PatchDataSourceConnection(params *PatchDataSourceConnectionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchDataSourceConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchDataSourceConnectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchDataSourceConnection",
		Method:             "PATCH",
		PathPattern:        "/data-source-connections/{connectionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchDataSourceConnectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchDataSourceConnectionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchDataSourceConnectionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ResetConnectionUpgrade resets the upgrade for a data source connection

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Helps unblock upgrades for the connection if the current connector getting upgraded is not responding for upgrade status which can cause rest of the connectors to be blocked. This should generally be used when the issue has been fixed for the connector or the connector has been removed from the connection.
*/
func (a *Client) ResetConnectionUpgrade(params *ResetConnectionUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResetConnectionUpgradeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResetConnectionUpgradeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ResetConnectionUpgrade",
		Method:             "POST",
		PathPattern:        "/data-source-connections/{connectionId}/reset-upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ResetConnectionUpgradeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResetConnectionUpgradeNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ResetConnectionUpgradeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpdateConnectionsUpgradeConfig configs for upgrading connections

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates the upgrade configuration for the data source connections.

Connectors within a connection would be upgraded in a rolling manner.
Upgrade status for a connection can be fetched using GET
data-source-connection. If the connection is removed from the config
after the upgrade is issued internally by the system, the connection
upgrade status would not be updated for success or failure. Note that
this is a config and upgrades would be asynchronously done at a later
point in time.
*/
func (a *Client) UpdateConnectionsUpgradeConfig(params *UpdateConnectionsUpgradeConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateConnectionsUpgradeConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateConnectionsUpgradeConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateConnectionsUpgradeConfig",
		Method:             "PUT",
		PathPattern:        "/data-source-connections/upgrade-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateConnectionsUpgradeConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateConnectionsUpgradeConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateConnectionsUpgradeConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
