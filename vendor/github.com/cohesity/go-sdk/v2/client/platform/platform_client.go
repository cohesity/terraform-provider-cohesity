// Code generated by go-swagger; DO NOT EDIT.

package platform

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new platform API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new platform API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new platform API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for platform API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AddHosts(params *AddHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddHostsCreated, error)

	AddRemoteDisk(params *AddRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddRemoteDiskCreated, error)

	ChangeServicesStates(params *ChangeServicesStatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangeServicesStatesAccepted, error)

	ClearSMTPConfiguration(params *ClearSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClearSMTPConfigurationNoContent, error)

	ClusterUpdateIpmiUsers(params *ClusterUpdateIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterUpdateIpmiUsersOK, error)

	CreateBond(params *CreateBondParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateBondCreated, error)

	CreateCluster(params *CreateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterCreated, error)

	CreateClusterVlan(params *CreateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterVlanCreated, error)

	CreateInterfaceGroup(params *CreateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInterfaceGroupCreated, error)

	CreateRacks(params *CreateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRacksCreated, error)

	DeleteAMQPTargetConfig(params *DeleteAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAMQPTargetConfigNoContent, error)

	DeleteClusterSnapshotPolicy(params *DeleteClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterSnapshotPolicyNoContent, error)

	DeleteHosts(params *DeleteHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteHostsNoContent, error)

	DeleteIpmiUser(params *DeleteIpmiUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteIpmiUserOK, error)

	DiscoverDisks(params *DiscoverDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiscoverDisksOK, error)

	DiskIdentify(params *DiskIdentifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskIdentifyOK, error)

	DisksAssimilate(params *DisksAssimilateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisksAssimilateOK, error)

	GetAMQPTargetConfig(params *GetAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAMQPTargetConfigOK, error)

	GetChassis(params *GetChassisParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisOK, error)

	GetChassisByID(params *GetChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisByIDOK, error)

	GetCluster(params *GetClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOK, error)

	GetClusterIpmiLanInfo(params *GetClusterIpmiLanInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterIpmiLanInfoOK, error)

	GetClusterIpmiUsers(params *GetClusterIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterIpmiUsersOK, error)

	GetClusterLocalDomainSID(params *GetClusterLocalDomainSIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterLocalDomainSIDOK, error)

	GetClusterOperationStatusList(params *GetClusterOperationStatusListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOperationStatusListOK, error)

	GetClusterPackages(params *GetClusterPackagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPackagesOK, error)

	GetClusterSnapshotPolicy(params *GetClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSnapshotPolicyOK, error)

	GetClusterState(params *GetClusterStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStateOK, error)

	GetClusterStatus(params *GetClusterStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStatusOK, error)

	GetClusterSubnetsInfo(params *GetClusterSubnetsInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSubnetsInfoOK, error)

	GetHardwareInfo(params *GetHardwareInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetHardwareInfoOK, error)

	GetIpmiFruInfo(params *GetIpmiFruInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiFruInfoOK, error)

	GetIpmiLanInfo(params *GetIpmiLanInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiLanInfoOK, error)

	GetIpmiSdrInfo(params *GetIpmiSdrInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiSdrInfoOK, error)

	GetIpmiSel(params *GetIpmiSelParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiSelOK, error)

	GetIpmiSelInfo(params *GetIpmiSelInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiSelInfoOK, error)

	GetIpmiUsers(params *GetIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiUsersOK, error)

	GetIsDMaaSCluster(params *GetIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIsDMaaSClusterOK, error)

	GetKubernetesInfraHealthStatus(params *GetKubernetesInfraHealthStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetKubernetesInfraHealthStatusOK, error)

	GetNetworkInterfaces(params *GetNetworkInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNetworkInterfacesOK, error)

	GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error)

	GetRackByID(params *GetRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRackByIDOK, error)

	GetRacks(params *GetRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRacksOK, error)

	GetRemoteDisks(params *GetRemoteDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRemoteDisksOK, error)

	GetSMTPConfiguration(params *GetSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSMTPConfigurationOK, error)

	GetSWUpdateHistory(params *GetSWUpdateHistoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSWUpdateHistoryOK, error)

	GetServiceGflags(params *GetServiceGflagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetServiceGflagsOK, error)

	GetSoftwareComponents(params *GetSoftwareComponentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSoftwareComponentsOK, error)

	GetSupportChannelConfig(params *GetSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSupportChannelConfigOK, error)

	IdentifyNode(params *IdentifyNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*IdentifyNodeOK, error)

	ImportCrlFile(params *ImportCrlFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImportCrlFileNoContent, error)

	ListDisks(params *ListDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDisksOK, error)

	ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error)

	ListHosts(params *ListHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListHostsOK, error)

	ListServicesStates(params *ListServicesStatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListServicesStatesAccepted, error)

	MarkBaseosUpgrade(params *MarkBaseosUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkBaseosUpgradeOK, error)

	MarkDiskRemoval(params *MarkDiskRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkDiskRemovalOK, error)

	MarkNodeRemoval(params *MarkNodeRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeRemovalOK, error)

	NodeInformation(params *NodeInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeInformationOK, error)

	NodeStatus(params *NodeStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeStatusOK, error)

	PublicKeyRequest(params *PublicKeyRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublicKeyRequestOK, error)

	RemoveRemoteDisk(params *RemoveRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveRemoteDiskNoContent, error)

	ResetIpmiBmc(params *ResetIpmiBmcParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResetIpmiBmcOK, error)

	SetNodePower(params *SetNodePowerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetNodePowerNoContent, error)

	UpdateAMQPTargetConfig(params *UpdateAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAMQPTargetConfigOK, error)

	UpdateAirgapConfig(params *UpdateAirgapConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAirgapConfigAccepted, error)

	UpdateChassisByID(params *UpdateChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChassisByIDOK, error)

	UpdateCluster(params *UpdateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterOK, error)

	UpdateClusterIpmiLanInfo(params *UpdateClusterIpmiLanInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterIpmiLanInfoOK, error)

	UpdateClusterSnapshotPolicy(params *UpdateClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSnapshotPolicyOK, error)

	UpdateClusterSoftware(params *UpdateClusterSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSoftwareAccepted, error)

	UpdateClusterSubnets(params *UpdateClusterSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSubnetsOK, error)

	UpdateFeatureFlag(params *UpdateFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateFeatureFlagOK, error)

	UpdateHosts(params *UpdateHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateHostsOK, error)

	UpdateIpmiUser(params *UpdateIpmiUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIpmiUserOK, error)

	UpdateIsDMaaSCluster(params *UpdateIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIsDMaaSClusterOK, error)

	UpdateRackByID(params *UpdateRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRackByIDOK, error)

	UpdateRacks(params *UpdateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRacksOK, error)

	UpdateSMTPConfiguration(params *UpdateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSMTPConfigurationOK, error)

	UpdateServiceGflags(params *UpdateServiceGflagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateServiceGflagsOK, error)

	UpdateSupportChannelConfig(params *UpdateSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSupportChannelConfigOK, error)

	UpgradeCheckGetResults(params *UpgradeCheckGetResultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckGetResultsOK, error)

	UpgradeCheckRunTests(params *UpgradeCheckRunTestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckRunTestsOK, error)

	UpgradeNodes(params *UpgradeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeNodesAccepted, error)

	UploadFilePackage(params *UploadFilePackageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadFilePackageNoContent, error)

	ValidateSMTPConfiguration(params *ValidateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ValidateSMTPConfigurationNoContent, error)

	VerifyIpmiUser(params *VerifyIpmiUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VerifyIpmiUserOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AddHosts creates cluster host mappings

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to add one or more new entries to the Cluster's /etc/hosts
*/
func (a *Client) AddHosts(params *AddHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddHostsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddHosts",
		Method:             "POST",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddHostsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AddHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
AddRemoteDisk adds remote disk

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Add a remote disk.
*/
func (a *Client) AddRemoteDisk(params *AddRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddRemoteDiskCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddRemoteDiskParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddRemoteDisk",
		Method:             "POST",
		PathPattern:        "/disks/remote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddRemoteDiskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddRemoteDiskCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AddRemoteDiskDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ChangeServicesStates changes cluster services states

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Change the state of one or more services on a Cohesity Cluster.
*/
func (a *Client) ChangeServicesStates(params *ChangeServicesStatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangeServicesStatesAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewChangeServicesStatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ChangeServicesStates",
		Method:             "POST",
		PathPattern:        "/clusters/services/states",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ChangeServicesStatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ChangeServicesStatesAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ChangeServicesStatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ClearSMTPConfiguration clears SMTP configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Clear cluster SMTP configuration.
*/
func (a *Client) ClearSMTPConfiguration(params *ClearSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClearSMTPConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClearSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ClearSMTPConfiguration",
		Method:             "DELETE",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClearSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClearSMTPConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClearSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ClusterUpdateIpmiUsers tos update IP m i users for cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates the cluster ipmi user information.
*/
func (a *Client) ClusterUpdateIpmiUsers(params *ClusterUpdateIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterUpdateIpmiUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterUpdateIpmiUsersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ClusterUpdateIpmiUsers",
		Method:             "PUT",
		PathPattern:        "/ipmi/cluster-users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterUpdateIpmiUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterUpdateIpmiUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterUpdateIpmiUsersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateBond creates a new network bond

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to create a new network bond on the Cluster. This can only be performed on a Node before it is part of a Cluster.
*/
func (a *Client) CreateBond(params *CreateBondParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateBondCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateBondParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateBond",
		Method:             "POST",
		PathPattern:        "/network/bonds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateBondReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateBondCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateBondDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateCluster creates a cluster

**Privileges:** ```CLUSTER_CREATE``` <br><br>Create a cluster with given network and cluster configuration.
*/
func (a *Client) CreateCluster(params *CreateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateCluster",
		Method:             "POST",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClusterCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateClusterVlan creates vlan

```Unknown Privileges``` <br><br>Create a vlan on the cluster.
*/
func (a *Client) CreateClusterVlan(params *CreateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterVlanCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterVlanParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateClusterVlan",
		Method:             "POST",
		PathPattern:        "/network/vlans",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterVlanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClusterVlanCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClusterVlanDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateInterfaceGroup creates interface group

```Unknown Privileges``` <br><br>Create an interface group on the cluster.
*/
func (a *Client) CreateInterfaceGroup(params *CreateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInterfaceGroupCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateInterfaceGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateInterfaceGroup",
		Method:             "POST",
		PathPattern:        "/network/interface-groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateInterfaceGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateInterfaceGroupCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateInterfaceGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRacks creates racks

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Create list of racks and optionally also assign list of chassis to each rack
*/
func (a *Client) CreateRacks(params *CreateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRacksCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRacks",
		Method:             "POST",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRacksCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteAMQPTargetConfig deletes a m q p target config

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Delete AMQP target config on the cluster.
*/
func (a *Client) DeleteAMQPTargetConfig(params *DeleteAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAMQPTargetConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteAMQPTargetConfig",
		Method:             "DELETE",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteAMQPTargetConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteClusterSnapshotPolicy deletes cluster snapshot policy

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Delete cluster snapshot policy.
*/
func (a *Client) DeleteClusterSnapshotPolicy(params *DeleteClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterSnapshotPolicyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterSnapshotPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteClusterSnapshotPolicy",
		Method:             "DELETE",
		PathPattern:        "/clusters/snapshot-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterSnapshotPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteClusterSnapshotPolicyNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteClusterSnapshotPolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteHosts deletes multiple host mappings within the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Delete one or more Host Mappings within the cluster.
*/
func (a *Client) DeleteHosts(params *DeleteHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteHostsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteHosts",
		Method:             "POST",
		PathPattern:        "/clusters/host-mappings/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteHostsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteIpmiUser tos delete IP m i user for node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Deletes the provided ipmi user for given node.
*/
func (a *Client) DeleteIpmiUser(params *DeleteIpmiUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteIpmiUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteIpmiUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteIpmiUser",
		Method:             "DELETE",
		PathPattern:        "/ipmi/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteIpmiUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteIpmiUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteIpmiUserDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DiscoverDisks discovers new disks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Discover disks that are ready for activation
*/
func (a *Client) DiscoverDisks(params *DiscoverDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiscoverDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiscoverDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DiscoverDisks",
		Method:             "GET",
		PathPattern:        "/disks/discover",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiscoverDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiscoverDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiscoverDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DiskIdentify identifies a disk

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Turn on/off led light of a disk.
*/
func (a *Client) DiskIdentify(params *DiskIdentifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskIdentifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiskIdentifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DiskIdentify",
		Method:             "POST",
		PathPattern:        "/disks/identify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiskIdentifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiskIdentifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiskIdentifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DisksAssimilate assimilates disks

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Assimilate list of disks from one or more nodes of cluster.
*/
func (a *Client) DisksAssimilate(params *DisksAssimilateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisksAssimilateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisksAssimilateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DisksAssimilate",
		Method:             "POST",
		PathPattern:        "/disks/assimilate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DisksAssimilateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DisksAssimilateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DisksAssimilateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAMQPTargetConfig gets a m q p target config

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetch AMQP target config on the cluster.
*/
func (a *Client) GetAMQPTargetConfig(params *GetAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAMQPTargetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAMQPTargetConfig",
		Method:             "GET",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAMQPTargetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetChassis gets list of chassis

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get list of all chassis info that are part of cluster.
*/
func (a *Client) GetChassis(params *GetChassisParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChassisParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetChassis",
		Method:             "GET",
		PathPattern:        "/chassis",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChassisReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetChassisOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetChassisDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetChassisByID gets a chassis by chassis id

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get a chassis info by id.
*/
func (a *Client) GetChassisByID(params *GetChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChassisByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetChassisById",
		Method:             "GET",
		PathPattern:        "/chassis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChassisByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetChassisByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetChassisByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetCluster retrieves cluster configuration

**Privileges:** ```CLUSTER_VIEW``` <br><br>Retrieve some summary information about the Cluster Configuration.
*/
func (a *Client) GetCluster(params *GetClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetCluster",
		Method:             "GET",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterIpmiLanInfo tos get IP m i l a n info for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about LAN for the cluster in which current node is present.
*/
func (a *Client) GetClusterIpmiLanInfo(params *GetClusterIpmiLanInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterIpmiLanInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterIpmiLanInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterIpmiLanInfo",
		Method:             "GET",
		PathPattern:        "/ipmi/cluster-get-lan-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterIpmiLanInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterIpmiLanInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterIpmiLanInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterIpmiUsers tos get IP m i users info for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about cluster and node level IPMI user names.
*/
func (a *Client) GetClusterIpmiUsers(params *GetClusterIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterIpmiUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterIpmiUsersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterIpmiUsers",
		Method:             "GET",
		PathPattern:        "/ipmi/cluster-users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterIpmiUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterIpmiUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterIpmiUsersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterLocalDomainSID gets cluster local domain s ID

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetch SID of cluster local domain.
*/
func (a *Client) GetClusterLocalDomainSID(params *GetClusterLocalDomainSIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterLocalDomainSIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterLocalDomainSIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterLocalDomainSID",
		Method:             "GET",
		PathPattern:        "/clusters/local-domain-sid",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterLocalDomainSIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterLocalDomainSIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterLocalDomainSIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterOperationStatusList gets cluster operations status

```No Privileges Required``` <br><br>Get list of cluster operations status information.
*/
func (a *Client) GetClusterOperationStatusList(params *GetClusterOperationStatusListParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOperationStatusListOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterOperationStatusListParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterOperationStatusList",
		Method:             "GET",
		PathPattern:        "/clusters/operation-status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterOperationStatusListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterOperationStatusListOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterOperationStatusListDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterPackages gets packages

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get software packages on the cluster.
*/
func (a *Client) GetClusterPackages(params *GetClusterPackagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPackagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterPackagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterPackages",
		Method:             "GET",
		PathPattern:        "/clusters/packages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterPackagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterPackagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterPackagesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterSnapshotPolicy gets cluster snapshot policy

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get cluster snapshot policy.
*/
func (a *Client) GetClusterSnapshotPolicy(params *GetClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSnapshotPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterSnapshotPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterSnapshotPolicy",
		Method:             "GET",
		PathPattern:        "/clusters/snapshot-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterSnapshotPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterSnapshotPolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterSnapshotPolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterState gets cluster state

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get the current state of the cluster.
*/
func (a *Client) GetClusterState(params *GetClusterStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterStateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterState",
		Method:             "GET",
		PathPattern:        "/clusters/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterStateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterStatus gets cluster status

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get cluster status.
*/
func (a *Client) GetClusterStatus(params *GetClusterStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterStatus",
		Method:             "GET",
		PathPattern:        "/clusters/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterSubnetsInfo gets cluster subnets info

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get cluster subnet info.
*/
func (a *Client) GetClusterSubnetsInfo(params *GetClusterSubnetsInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSubnetsInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterSubnetsInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterSubnetsInfo",
		Method:             "GET",
		PathPattern:        "/clusters/subnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterSubnetsInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterSubnetsInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterSubnetsInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetHardwareInfo fetches node hardware information

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetch general information about the node hardware to which the request is sent to.
*/
func (a *Client) GetHardwareInfo(params *GetHardwareInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetHardwareInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHardwareInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetHardwareInfo",
		Method:             "GET",
		PathPattern:        "/node/hardware-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHardwareInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetHardwareInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetHardwareInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiFruInfo tos get IP m i f r u info

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about FRU for given IPMI
*/
func (a *Client) GetIpmiFruInfo(params *GetIpmiFruInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiFruInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiFruInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiFruInfo",
		Method:             "GET",
		PathPattern:        "/ipmi/get-fru-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiFruInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiFruInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiFruInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiLanInfo tos get IP m i l a n info

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about LAN for given IPMI
*/
func (a *Client) GetIpmiLanInfo(params *GetIpmiLanInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiLanInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiLanInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiLanInfo",
		Method:             "GET",
		PathPattern:        "/ipmi/get-lan-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiLanInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiLanInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiLanInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiSdrInfo tos get IP m i s d r info

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about SDR info for given IPMI
*/
func (a *Client) GetIpmiSdrInfo(params *GetIpmiSdrInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiSdrInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiSdrInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiSdrInfo",
		Method:             "GET",
		PathPattern:        "/ipmi/get-sdr-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiSdrInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiSdrInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiSdrInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiSel tos get IP m i s e l

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about SEL for given IPMI
*/
func (a *Client) GetIpmiSel(params *GetIpmiSelParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiSelOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiSelParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiSel",
		Method:             "GET",
		PathPattern:        "/ipmi/get-sel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiSelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiSelOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiSelDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiSelInfo tos get IP m i s e l info

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the information about SEL info for given IPMI
*/
func (a *Client) GetIpmiSelInfo(params *GetIpmiSelInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiSelInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiSelInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiSelInfo",
		Method:             "GET",
		PathPattern:        "/ipmi/get-sel-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiSelInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiSelInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiSelInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiUsers tos get IP m i user info for node

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetches the ipmi user information for given node.
*/
func (a *Client) GetIpmiUsers(params *GetIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiUsersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiUsers",
		Method:             "GET",
		PathPattern:        "/ipmi/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiUsersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIsDMaaSCluster gets whether the cluster is a d maa s cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get whether the cluster is a DMaaS cluster.
*/
func (a *Client) GetIsDMaaSCluster(params *GetIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIsDMaaSClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIsDMaaSClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIsDMaaSCluster",
		Method:             "GET",
		PathPattern:        "/clusters/is-dmaas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIsDMaaSClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIsDMaaSClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIsDMaaSClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetKubernetesInfraHealthStatus gets kubernetes infra health status

**Privileges:** ```APPS_MANAGEMENT``` <br><br>Fetches the Kubernetes Infra Health status
*/
func (a *Client) GetKubernetesInfraHealthStatus(params *GetKubernetesInfraHealthStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetKubernetesInfraHealthStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetKubernetesInfraHealthStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetKubernetesInfraHealthStatus",
		Method:             "GET",
		PathPattern:        "/kubernetes/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetKubernetesInfraHealthStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetKubernetesInfraHealthStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetKubernetesInfraHealthStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNetworkInterfaces gets list of interfaces

**Privileges:** ```CLUSTER_VIEW, CLUSTER_CREATE``` <br><br>Get a list of interfaces present on the node or cluster.
*/
func (a *Client) GetNetworkInterfaces(params *GetNetworkInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNetworkInterfacesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNetworkInterfacesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNetworkInterfaces",
		Method:             "GET",
		PathPattern:        "/network-interfaces",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNetworkInterfacesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNetworkInterfacesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNetworkInterfacesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNodes lists nodes of the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Gets the list of Nodes in a cluster.
*/
func (a *Client) GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodes",
		Method:             "GET",
		PathPattern:        "/clusters/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRackByID gets a rack by rack id

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get a rack info by id.
*/
func (a *Client) GetRackByID(params *GetRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRackByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRackById",
		Method:             "GET",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRackByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRacks gets list of racks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get list of all racks that are part of cluster.
*/
func (a *Client) GetRacks(params *GetRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRacksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRacks",
		Method:             "GET",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRacksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRemoteDisks gets remote disks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get remote disks.
*/
func (a *Client) GetRemoteDisks(params *GetRemoteDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRemoteDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRemoteDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRemoteDisks",
		Method:             "GET",
		PathPattern:        "/disks/remote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRemoteDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRemoteDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRemoteDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSMTPConfiguration gets SMTP configuration

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get the SMTP cluster configuration.
*/
func (a *Client) GetSMTPConfiguration(params *GetSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSMTPConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSMTPConfiguration",
		Method:             "GET",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSMTPConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSWUpdateHistory gets cluster software history

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get upgrade and patch history of the cluster.
*/
func (a *Client) GetSWUpdateHistory(params *GetSWUpdateHistoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSWUpdateHistoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSWUpdateHistoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSWUpdateHistory",
		Method:             "GET",
		PathPattern:        "/clusters/softwares",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSWUpdateHistoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSWUpdateHistoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSWUpdateHistoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetServiceGflags gets cluster gflags for a service

**Privileges:** ```CLUSTER_VIEW``` <br><br>Gets the cluster gflags for a service.
*/
func (a *Client) GetServiceGflags(params *GetServiceGflagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetServiceGflagsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServiceGflagsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetServiceGflags",
		Method:             "GET",
		PathPattern:        "/clusters/gflag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetServiceGflagsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetServiceGflagsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetServiceGflagsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSoftwareComponents gets software components

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get software components versions on the cluster.
*/
func (a *Client) GetSoftwareComponents(params *GetSoftwareComponentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSoftwareComponentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSoftwareComponentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSoftwareComponents",
		Method:             "GET",
		PathPattern:        "/clusters/software-components",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSoftwareComponentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSoftwareComponentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSoftwareComponentsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSupportChannelConfig gets support channel configuration

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get support channel configuration.
*/
func (a *Client) GetSupportChannelConfig(params *GetSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSupportChannelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSupportChannelConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSupportChannelConfig",
		Method:             "GET",
		PathPattern:        "/support-channel-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSupportChannelConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSupportChannelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSupportChannelConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IdentifyNode identifies node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Turn on/off LED light of a node to identify.
*/
func (a *Client) IdentifyNode(params *IdentifyNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*IdentifyNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIdentifyNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IdentifyNode",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/identify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &IdentifyNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IdentifyNodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IdentifyNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ImportCrlFile imports crl file

**Privileges:** ```CLUSTER_MAINTENANCE``` <br><br>Import a Crl file into the cluster.
*/
func (a *Client) ImportCrlFile(params *ImportCrlFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImportCrlFileNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportCrlFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImportCrlFile",
		Method:             "PUT",
		PathPattern:        "/clusters/import-crl-file",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportCrlFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportCrlFileNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ImportCrlFileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDisks gets list of disks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get list of local disks.
*/
func (a *Client) ListDisks(params *ListDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListDisks",
		Method:             "GET",
		PathPattern:        "/disks/local",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListFreeNodes lists the free cohesity nodes present on a network

**Privileges:** ```CLUSTER_VIEW, CLUSTER_CREATE``` <br><br>Sends a request to any Node to list all of the free Nodes that are present on the network.
*/
func (a *Client) ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListFreeNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListFreeNodes",
		Method:             "GET",
		PathPattern:        "/clusters/nodes/free",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListFreeNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListFreeNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListFreeNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListHosts lists host mappings

**Privileges:** ```CLUSTER_VIEW``` <br><br>Lists the host mappings in /etc/hosts of the nodes in a cluster.
*/
func (a *Client) ListHosts(params *ListHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListHosts",
		Method:             "GET",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListServicesStates lists services states

**Privileges:** ```CLUSTER_VIEW``` <br><br>List the states of the services on the Cluster
*/
func (a *Client) ListServicesStates(params *ListServicesStatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListServicesStatesAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListServicesStatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListServicesStates",
		Method:             "GET",
		PathPattern:        "/clusters/services/states",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListServicesStatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListServicesStatesAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListServicesStatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkBaseosUpgrade sets clears the base o s upgrade cluster operation

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sets/clears the BaseOS upgrade cluster operation.
*/
func (a *Client) MarkBaseosUpgrade(params *MarkBaseosUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkBaseosUpgradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkBaseosUpgradeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkBaseosUpgrade",
		Method:             "PUT",
		PathPattern:        "/clusters/baseos-upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkBaseosUpgradeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkBaseosUpgradeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkBaseosUpgradeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkDiskRemoval marks disk for removal

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Mark disk for removal or cancel removal if a disk is already marked for removal.
*/
func (a *Client) MarkDiskRemoval(params *MarkDiskRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkDiskRemovalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkDiskRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkDiskRemoval",
		Method:             "POST",
		PathPattern:        "/disks/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkDiskRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkDiskRemovalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkDiskRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkNodeRemoval marks node for removal

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Mark node for removal or Cancel if a node is already marked for removal.
*/
func (a *Client) MarkNodeRemoval(params *MarkNodeRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeRemovalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkNodeRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkNodeRemoval",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkNodeRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkNodeRemovalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkNodeRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NodeInformation fetches node general information

**Privileges:** ```CLUSTER_VIEW, NODE_VIEW``` <br><br>Fetch general information about the node to which the request is sent to.
*/
func (a *Client) NodeInformation(params *NodeInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeInformationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeInformationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Node Information",
		Method:             "GET",
		PathPattern:        "/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeInformationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeInformationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeInformationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NodeStatus fetches node status information

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetch node status details.
*/
func (a *Client) NodeStatus(params *NodeStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "NodeStatus",
		Method:             "GET",
		PathPattern:        "/node/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PublicKeyRequest gets the SSH public key

**Privileges:** ```PROTECTION_MODIFY``` <br><br>Get the SSH public key corresponding to the private key used by workloads. For example, users may specify multiple scripts which are supposed to be executed on a remote machine at different progress states of a protection group run (for instance - running a script before the run starts and another after the run completes). The public key returned as part of this response should be added on the remote server where the script is to be executed as there is a specific private key used by the workload for remote login.
*/
func (a *Client) PublicKeyRequest(params *PublicKeyRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublicKeyRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicKeyRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PublicKeyRequest",
		Method:             "POST",
		PathPattern:        "/clusters/ssh-public-key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicKeyRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublicKeyRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublicKeyRequestDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RemoveRemoteDisk removes remote disk

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Remove a remote disk.
*/
func (a *Client) RemoveRemoteDisk(params *RemoveRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveRemoteDiskNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoveRemoteDiskParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RemoveRemoteDisk",
		Method:             "DELETE",
		PathPattern:        "/disks/remote/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RemoveRemoteDiskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoveRemoteDiskNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RemoveRemoteDiskDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ResetIpmiBmc tos reset IP m i b m c for given node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Resets the ipmi bmc for given node.
*/
func (a *Client) ResetIpmiBmc(params *ResetIpmiBmcParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResetIpmiBmcOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResetIpmiBmcParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ResetIpmiBmc",
		Method:             "POST",
		PathPattern:        "/ipmi/reset-bmc",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ResetIpmiBmcReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResetIpmiBmcOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ResetIpmiBmcDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SetNodePower reboots or shutdown nodes in cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Reboot or shutdown nodes in cluster.
*/
func (a *Client) SetNodePower(params *SetNodePowerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetNodePowerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetNodePowerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SetNodePower",
		Method:             "POST",
		PathPattern:        "/node-power",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetNodePowerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetNodePowerNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SetNodePowerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAMQPTargetConfig updates a m q p target config

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates AMQP target config on the cluster.
*/
func (a *Client) UpdateAMQPTargetConfig(params *UpdateAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAMQPTargetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAMQPTargetConfig",
		Method:             "PUT",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAMQPTargetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAirgapConfig updates airgap config

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Enable or Disable Airgap on the cluster.
*/
func (a *Client) UpdateAirgapConfig(params *UpdateAirgapConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAirgapConfigAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAirgapConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAirgapConfig",
		Method:             "PUT",
		PathPattern:        "/clusters/airgap",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAirgapConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAirgapConfigAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateAirgapConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateChassisByID updates a chassis by chassis id

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update selected properties of chassis info by id.
*/
func (a *Client) UpdateChassisByID(params *UpdateChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChassisByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateChassisByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateChassisById",
		Method:             "PATCH",
		PathPattern:        "/chassis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateChassisByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateChassisByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateChassisByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateCluster updates a cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update the Cluster with the given configuration.
*/
func (a *Client) UpdateCluster(params *UpdateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateCluster",
		Method:             "PUT",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterIpmiLanInfo tos update IP m i l a n info for the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates the information about LAN for the cluster in which current node is present.
*/
func (a *Client) UpdateClusterIpmiLanInfo(params *UpdateClusterIpmiLanInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterIpmiLanInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterIpmiLanInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterIpmiLanInfo",
		Method:             "PUT",
		PathPattern:        "/ipmi/cluster-update-lan-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterIpmiLanInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterIpmiLanInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterIpmiLanInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterSnapshotPolicy updates cluster snapshot policy

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update cluster snapshot policy.
*/
func (a *Client) UpdateClusterSnapshotPolicy(params *UpdateClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSnapshotPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterSnapshotPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterSnapshotPolicy",
		Method:             "PUT",
		PathPattern:        "/clusters/snapshot-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterSnapshotPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterSnapshotPolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterSnapshotPolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterSoftware updates cluster software

**Privileges:** ```CLUSTER_UPGRADE, CLUSTER_MAINTENANCE``` <br><br>Update the software on the cluster through upgrade and/or patch.
*/
func (a *Client) UpdateClusterSoftware(params *UpdateClusterSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSoftwareAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterSoftwareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterSoftware",
		Method:             "PUT",
		PathPattern:        "/clusters/softwares",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterSoftwareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterSoftwareAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterSoftwareDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterSubnets updates the cluster subnets

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update the cluster subnet Info
*/
func (a *Client) UpdateClusterSubnets(params *UpdateClusterSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSubnetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterSubnetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterSubnets",
		Method:             "PUT",
		PathPattern:        "/clusters/subnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterSubnetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterSubnetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdateClusterSubnets: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateFeatureFlag updates feature flag override status

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update a feature flag override status to cluster.
*/
func (a *Client) UpdateFeatureFlag(params *UpdateFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateFeatureFlagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateFeatureFlagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateFeatureFlag",
		Method:             "PUT",
		PathPattern:        "/clusters/feature-flag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateFeatureFlagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateFeatureFlagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateFeatureFlagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateHosts updates host mappings

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates Host Mapping on the Cluster.
*/
func (a *Client) UpdateHosts(params *UpdateHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateHosts",
		Method:             "PUT",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIpmiUser tos update IP m i user info for node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates the ipmi user information for given node.
*/
func (a *Client) UpdateIpmiUser(params *UpdateIpmiUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIpmiUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIpmiUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIpmiUser",
		Method:             "POST",
		PathPattern:        "/ipmi/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIpmiUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIpmiUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIpmiUserDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIsDMaaSCluster updates whether the cluster is a d maa s cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update whether the cluster is a DMaaS cluster.
*/
func (a *Client) UpdateIsDMaaSCluster(params *UpdateIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIsDMaaSClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIsDMaaSClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIsDMaaSCluster",
		Method:             "PUT",
		PathPattern:        "/clusters/is-dmaas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIsDMaaSClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIsDMaaSClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIsDMaaSClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRackByID **Privileges:** ```CLUSTER_MODIFY``` <br><br>Update selected properties of a rack given by id.
*/
func (a *Client) UpdateRackByID(params *UpdateRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRackByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRackById",
		Method:             "PATCH",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRackByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRacks updates racks

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates list of racks with name, chassis list or/and location
*/
func (a *Client) UpdateRacks(params *UpdateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRacksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRacks",
		Method:             "PATCH",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRacksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateSMTPConfiguration updates SMTP configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update SMTP configuration.
*/
func (a *Client) UpdateSMTPConfiguration(params *UpdateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSMTPConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateSMTPConfiguration",
		Method:             "PUT",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSMTPConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateServiceGflags updates the gflags

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates the gflags for a service on the Cluster.
*/
func (a *Client) UpdateServiceGflags(params *UpdateServiceGflagsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateServiceGflagsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateServiceGflagsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateServiceGflags",
		Method:             "PUT",
		PathPattern:        "/clusters/gflag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateServiceGflagsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateServiceGflagsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateServiceGflagsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateSupportChannelConfig updates support channel configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update support channel configuration.
*/
func (a *Client) UpdateSupportChannelConfig(params *UpdateSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSupportChannelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSupportChannelConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateSupportChannelConfig",
		Method:             "PUT",
		PathPattern:        "/support-channel-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSupportChannelConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSupportChannelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateSupportChannelConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpgradeCheckGetResults gets upgrade checks results

	**Privileges:** ```CLUSTER_VIEW``` <br><br>Get upgrade checks results.

This API will be deprecated.  Use
[GetClusterOperationStatusList](#tag/Platform/operation/GetClusterOperationStatusList)
with `AssessSoftwareUpdate` operationType query.
*/
func (a *Client) UpgradeCheckGetResults(params *UpgradeCheckGetResultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckGetResultsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeCheckGetResultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCheckGetResults",
		Method:             "GET",
		PathPattern:        "/clusters/upgrade-checks/{testRunInstanceId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeCheckGetResultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeCheckGetResultsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeCheckGetResultsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpgradeCheckRunTests runs upgrade checks on cluster

	**Privileges:** ```CLUSTER_MODIFY, CLUSTER_UPGRADE``` <br><br>Run upgrade checks on cluster.

This API will be deprecated.  Use
[UpdateClusterSoftware](#tag/Platform/operation/UpdateClusterSoftware)
with `AssessSoftwareUpdate` operationType.
*/
func (a *Client) UpgradeCheckRunTests(params *UpgradeCheckRunTestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckRunTestsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeCheckRunTestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCheckRunTests",
		Method:             "PUT",
		PathPattern:        "/clusters/upgrade-checks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeCheckRunTestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeCheckRunTestsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeCheckRunTestsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeNodes upgrades a free node

**Privileges:** ```CLUSTER_CREATE``` <br><br>Upgrade a free Node.
*/
func (a *Client) UpgradeNodes(params *UpgradeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeNodesAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeNodes",
		Method:             "PUT",
		PathPattern:        "/nodes/software",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeNodesAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UploadFilePackage uploads package by files

**Privileges:** ```CLUSTER_UPGRADE, CLUSTER_MAINTENANCE``` <br><br>Upload upgrade/patch package.
*/
func (a *Client) UploadFilePackage(params *UploadFilePackageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadFilePackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadFilePackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadFilePackage",
		Method:             "POST",
		PathPattern:        "/clusters/packages/file",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UploadFilePackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UploadFilePackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UploadFilePackageDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ValidateSMTPConfiguration validates SMTP configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Validate SMTP configuration by sending a test email.
*/
func (a *Client) ValidateSMTPConfiguration(params *ValidateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ValidateSMTPConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ValidateSMTPConfiguration",
		Method:             "POST",
		PathPattern:        "/clusters/smtp/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateSMTPConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ValidateSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
VerifyIpmiUser tos verify IP m i user with password for node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Verifies the ipmi user with password information for given node.
*/
func (a *Client) VerifyIpmiUser(params *VerifyIpmiUserParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VerifyIpmiUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewVerifyIpmiUserParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "VerifyIpmiUser",
		Method:             "POST",
		PathPattern:        "/ipmi/verify-users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &VerifyIpmiUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*VerifyIpmiUserOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*VerifyIpmiUserDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
