// Code generated by go-swagger; DO NOT EDIT.

package platform

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new platform API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new platform API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new platform API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for platform API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AddHosts(params *AddHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddHostsCreated, error)

	AddRemoteDisk(params *AddRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddRemoteDiskCreated, error)

	ClearSMTPConfiguration(params *ClearSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClearSMTPConfigurationNoContent, error)

	CreateCluster(params *CreateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterCreated, error)

	CreateClusterVlan(params *CreateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterVlanCreated, error)

	CreateInterfaceGroup(params *CreateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInterfaceGroupCreated, error)

	CreateRacks(params *CreateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRacksCreated, error)

	DeleteAMQPTargetConfig(params *DeleteAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAMQPTargetConfigNoContent, error)

	DeleteClusterSnapshotPolicy(params *DeleteClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterSnapshotPolicyNoContent, error)

	DeleteHosts(params *DeleteHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteHostsNoContent, error)

	DiscoverDisks(params *DiscoverDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiscoverDisksOK, error)

	DiskIdentify(params *DiskIdentifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskIdentifyOK, error)

	DisksAssimilate(params *DisksAssimilateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisksAssimilateOK, error)

	GetAMQPTargetConfig(params *GetAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAMQPTargetConfigOK, error)

	GetChassis(params *GetChassisParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisOK, error)

	GetChassisByID(params *GetChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisByIDOK, error)

	GetCluster(params *GetClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOK, error)

	GetClusterLocalDomainSID(params *GetClusterLocalDomainSIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterLocalDomainSIDOK, error)

	GetClusterPackages(params *GetClusterPackagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPackagesOK, error)

	GetClusterSnapshotPolicy(params *GetClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSnapshotPolicyOK, error)

	GetClusterState(params *GetClusterStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStateOK, error)

	GetIsDMaaSCluster(params *GetIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIsDMaaSClusterOK, error)

	GetNetworkInterfaces(params *GetNetworkInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNetworkInterfacesOK, error)

	GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error)

	GetRackByID(params *GetRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRackByIDOK, error)

	GetRacks(params *GetRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRacksOK, error)

	GetRemoteDisks(params *GetRemoteDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRemoteDisksOK, error)

	GetSMTPConfiguration(params *GetSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSMTPConfigurationOK, error)

	GetSupportChannelConfig(params *GetSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSupportChannelConfigOK, error)

	IdentifyNode(params *IdentifyNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*IdentifyNodeOK, error)

	ImportCrlFile(params *ImportCrlFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImportCrlFileNoContent, error)

	ListDisks(params *ListDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDisksOK, error)

	ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error)

	ListHosts(params *ListHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListHostsOK, error)

	MarkBaseosUpgrade(params *MarkBaseosUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkBaseosUpgradeOK, error)

	MarkDiskRemoval(params *MarkDiskRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkDiskRemovalOK, error)

	MarkNodeRemoval(params *MarkNodeRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeRemovalOK, error)

	NodeInformation(params *NodeInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeInformationOK, error)

	PublicKeyRequest(params *PublicKeyRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublicKeyRequestOK, error)

	RemoveRemoteDisk(params *RemoveRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveRemoteDiskNoContent, error)

	SetNodePower(params *SetNodePowerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetNodePowerNoContent, error)

	UpdateAMQPTargetConfig(params *UpdateAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAMQPTargetConfigOK, error)

	UpdateAirgapConfig(params *UpdateAirgapConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAirgapConfigAccepted, error)

	UpdateChassisByID(params *UpdateChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChassisByIDOK, error)

	UpdateCluster(params *UpdateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterOK, error)

	UpdateClusterSnapshotPolicy(params *UpdateClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSnapshotPolicyOK, error)

	UpdateFeatureFlag(params *UpdateFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateFeatureFlagOK, error)

	UpdateHosts(params *UpdateHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateHostsOK, error)

	UpdateIsDMaaSCluster(params *UpdateIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIsDMaaSClusterOK, error)

	UpdateRackByID(params *UpdateRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRackByIDOK, error)

	UpdateRacks(params *UpdateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRacksOK, error)

	UpdateSMTPConfiguration(params *UpdateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSMTPConfigurationOK, error)

	UpdateSupportChannelConfig(params *UpdateSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSupportChannelConfigOK, error)

	UpgradeCheckGetResults(params *UpgradeCheckGetResultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckGetResultsOK, error)

	UpgradeCheckRunTests(params *UpgradeCheckRunTestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckRunTestsOK, error)

	UpgradeClusterSoftware(params *UpgradeClusterSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeClusterSoftwareAccepted, error)

	ValidateSMTPConfiguration(params *ValidateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ValidateSMTPConfigurationNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AddHosts creates cluster host mappings

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to add one or more new entries to the Cluster's /etc/hosts
*/
func (a *Client) AddHosts(params *AddHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddHostsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddHosts",
		Method:             "POST",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddHostsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AddHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
AddRemoteDisk adds remote disk

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Add a remote disk.
*/
func (a *Client) AddRemoteDisk(params *AddRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddRemoteDiskCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddRemoteDiskParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddRemoteDisk",
		Method:             "POST",
		PathPattern:        "/disks/remote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddRemoteDiskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddRemoteDiskCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AddRemoteDiskDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ClearSMTPConfiguration clears SMTP configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Clear cluster SMTP configuration.
*/
func (a *Client) ClearSMTPConfiguration(params *ClearSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClearSMTPConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClearSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ClearSMTPConfiguration",
		Method:             "DELETE",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClearSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClearSMTPConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClearSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateCluster creates a cluster

**Privileges:** ```CLUSTER_CREATE``` <br><br>Create a cluster with given network and cluster configuration.
*/
func (a *Client) CreateCluster(params *CreateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateCluster",
		Method:             "POST",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClusterCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateClusterVlan creates vlan

```Unknown Privileges``` <br><br>Create a vlan on the cluster.
*/
func (a *Client) CreateClusterVlan(params *CreateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterVlanCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterVlanParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateClusterVlan",
		Method:             "POST",
		PathPattern:        "/network/vlans",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterVlanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClusterVlanCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClusterVlanDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateInterfaceGroup creates interface group

```Unknown Privileges``` <br><br>Create an interface group on the cluster.
*/
func (a *Client) CreateInterfaceGroup(params *CreateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInterfaceGroupCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateInterfaceGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateInterfaceGroup",
		Method:             "POST",
		PathPattern:        "/network/interface-groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateInterfaceGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateInterfaceGroupCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateInterfaceGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRacks creates racks

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Create list of racks and optionally also assign list of chassis to each rack
*/
func (a *Client) CreateRacks(params *CreateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRacksCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRacks",
		Method:             "POST",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRacksCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteAMQPTargetConfig deletes a m q p target config

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Delete AMQP target config on the cluster.
*/
func (a *Client) DeleteAMQPTargetConfig(params *DeleteAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAMQPTargetConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteAMQPTargetConfig",
		Method:             "DELETE",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteAMQPTargetConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteClusterSnapshotPolicy deletes cluster snapshot policy

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Delete cluster snapshot policy.
*/
func (a *Client) DeleteClusterSnapshotPolicy(params *DeleteClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterSnapshotPolicyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterSnapshotPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteClusterSnapshotPolicy",
		Method:             "DELETE",
		PathPattern:        "/clusters/snapshot-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterSnapshotPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteClusterSnapshotPolicyNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteClusterSnapshotPolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteHosts deletes multiple host mappings within the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Delete one or more Host Mappings within the cluster.
*/
func (a *Client) DeleteHosts(params *DeleteHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteHostsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteHosts",
		Method:             "POST",
		PathPattern:        "/clusters/host-mappings/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteHostsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DiscoverDisks discovers new disks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Discover disks that are ready for activation
*/
func (a *Client) DiscoverDisks(params *DiscoverDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiscoverDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiscoverDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DiscoverDisks",
		Method:             "GET",
		PathPattern:        "/disks/discover",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiscoverDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiscoverDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiscoverDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DiskIdentify identifies a disk

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Turn on/off led light of a disk.
*/
func (a *Client) DiskIdentify(params *DiskIdentifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskIdentifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiskIdentifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DiskIdentify",
		Method:             "POST",
		PathPattern:        "/disks/identify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiskIdentifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiskIdentifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiskIdentifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DisksAssimilate assimilates disks

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Assimilate list of disks from one or more nodes of cluster.
*/
func (a *Client) DisksAssimilate(params *DisksAssimilateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisksAssimilateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisksAssimilateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DisksAssimilate",
		Method:             "POST",
		PathPattern:        "/disks/assimilate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DisksAssimilateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DisksAssimilateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DisksAssimilateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAMQPTargetConfig gets a m q p target config

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetch AMQP target config on the cluster.
*/
func (a *Client) GetAMQPTargetConfig(params *GetAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAMQPTargetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAMQPTargetConfig",
		Method:             "GET",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAMQPTargetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetChassis gets list of chassis

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get list of all chassis info that are part of cluster.
*/
func (a *Client) GetChassis(params *GetChassisParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChassisParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetChassis",
		Method:             "GET",
		PathPattern:        "/chassis",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChassisReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetChassisOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetChassisDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetChassisByID gets a chassis by chassis id

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get a chassis info by id.
*/
func (a *Client) GetChassisByID(params *GetChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChassisByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetChassisById",
		Method:             "GET",
		PathPattern:        "/chassis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChassisByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetChassisByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetChassisByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetCluster retrieves cluster configuration

**Privileges:** ```CLUSTER_VIEW``` <br><br>Retrieve some summary information about the Cluster Configuration.
*/
func (a *Client) GetCluster(params *GetClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetCluster",
		Method:             "GET",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterLocalDomainSID gets cluster local domain s ID

**Privileges:** ```CLUSTER_VIEW``` <br><br>Fetch SID of cluster local domain.
*/
func (a *Client) GetClusterLocalDomainSID(params *GetClusterLocalDomainSIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterLocalDomainSIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterLocalDomainSIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterLocalDomainSID",
		Method:             "GET",
		PathPattern:        "/clusters/local-domain-sid",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterLocalDomainSIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterLocalDomainSIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterLocalDomainSIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterPackages gets packages

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get software packages on the cluster.
*/
func (a *Client) GetClusterPackages(params *GetClusterPackagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPackagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterPackagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterPackages",
		Method:             "GET",
		PathPattern:        "/clusters/packages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterPackagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterPackagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterPackagesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterSnapshotPolicy gets cluster snapshot policy

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get cluster snapshot policy.
*/
func (a *Client) GetClusterSnapshotPolicy(params *GetClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSnapshotPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterSnapshotPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterSnapshotPolicy",
		Method:             "GET",
		PathPattern:        "/clusters/snapshot-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterSnapshotPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterSnapshotPolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterSnapshotPolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterState gets cluster state

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get the current state of the cluster.
*/
func (a *Client) GetClusterState(params *GetClusterStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterStateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterState",
		Method:             "GET",
		PathPattern:        "/clusters/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterStateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIsDMaaSCluster gets whether the cluster is a d maa s cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get whether the cluster is a DMaaS cluster.
*/
func (a *Client) GetIsDMaaSCluster(params *GetIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIsDMaaSClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIsDMaaSClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIsDMaaSCluster",
		Method:             "GET",
		PathPattern:        "/clusters/is-dmaas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIsDMaaSClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIsDMaaSClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIsDMaaSClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNetworkInterfaces gets list of interfaces

**Privileges:** ```CLUSTER_VIEW, CLUSTER_CREATE``` <br><br>Get a list of interfaces present on the node or cluster.
*/
func (a *Client) GetNetworkInterfaces(params *GetNetworkInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNetworkInterfacesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNetworkInterfacesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNetworkInterfaces",
		Method:             "GET",
		PathPattern:        "/network-interfaces",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNetworkInterfacesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNetworkInterfacesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNetworkInterfacesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNodes lists nodes of the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Gets the list of Nodes in a cluster.
*/
func (a *Client) GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodes",
		Method:             "GET",
		PathPattern:        "/clusters/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRackByID gets a rack by rack id

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get a rack info by id.
*/
func (a *Client) GetRackByID(params *GetRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRackByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRackById",
		Method:             "GET",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRackByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRacks gets list of racks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get list of all racks that are part of cluster.
*/
func (a *Client) GetRacks(params *GetRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRacksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRacks",
		Method:             "GET",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRacksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRemoteDisks gets remote disks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get remote disks.
*/
func (a *Client) GetRemoteDisks(params *GetRemoteDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRemoteDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRemoteDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRemoteDisks",
		Method:             "GET",
		PathPattern:        "/disks/remote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRemoteDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRemoteDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRemoteDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSMTPConfiguration gets SMTP configuration

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get the SMTP cluster configuration.
*/
func (a *Client) GetSMTPConfiguration(params *GetSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSMTPConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSMTPConfiguration",
		Method:             "GET",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSMTPConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSupportChannelConfig gets support channel configuration

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get support channel configuration.
*/
func (a *Client) GetSupportChannelConfig(params *GetSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSupportChannelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSupportChannelConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSupportChannelConfig",
		Method:             "GET",
		PathPattern:        "/support-channel-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSupportChannelConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSupportChannelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSupportChannelConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IdentifyNode identifies node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Turn on/off LED light of a node to identify.
*/
func (a *Client) IdentifyNode(params *IdentifyNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*IdentifyNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIdentifyNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Identify node",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/identify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &IdentifyNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IdentifyNodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IdentifyNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ImportCrlFile imports crl file

**Privileges:** ```CLUSTER_MAINTENANCE``` <br><br>Import a Crl file into the cluster.
*/
func (a *Client) ImportCrlFile(params *ImportCrlFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImportCrlFileNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportCrlFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImportCrlFile",
		Method:             "PUT",
		PathPattern:        "/clusters/import-crl-file",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportCrlFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportCrlFileNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ImportCrlFileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDisks gets list of disks

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get list of local disks.
*/
func (a *Client) ListDisks(params *ListDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListDisks",
		Method:             "GET",
		PathPattern:        "/disks/local",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListFreeNodes lists the free cohesity nodes present on a network

**Privileges:** ```CLUSTER_VIEW, CLUSTER_CREATE``` <br><br>Sends a request to any Node to list all of the free Nodes that are present on the network.
*/
func (a *Client) ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListFreeNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListFreeNodes",
		Method:             "GET",
		PathPattern:        "/clusters/nodes/free",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListFreeNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListFreeNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListFreeNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListHosts lists host mappings

**Privileges:** ```CLUSTER_VIEW``` <br><br>Lists the host mappings in /etc/hosts of the nodes in a cluster.
*/
func (a *Client) ListHosts(params *ListHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListHosts",
		Method:             "GET",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkBaseosUpgrade sets clears the base o s upgrade cluster operation

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sets/clears the BaseOS upgrade cluster operation.
*/
func (a *Client) MarkBaseosUpgrade(params *MarkBaseosUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkBaseosUpgradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkBaseosUpgradeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkBaseosUpgrade",
		Method:             "PUT",
		PathPattern:        "/clusters/baseos-upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkBaseosUpgradeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkBaseosUpgradeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkBaseosUpgradeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkDiskRemoval marks disk for removal

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Mark disk for removal or cancel removal if a disk is already marked for removal.
*/
func (a *Client) MarkDiskRemoval(params *MarkDiskRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkDiskRemovalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkDiskRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkDiskRemoval",
		Method:             "POST",
		PathPattern:        "/disks/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkDiskRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkDiskRemovalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkDiskRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkNodeRemoval marks node for removal

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Mark node for removal or Cancel if a node is already marked for removal.
*/
func (a *Client) MarkNodeRemoval(params *MarkNodeRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeRemovalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkNodeRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkNodeRemoval",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkNodeRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkNodeRemovalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkNodeRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NodeInformation fetches node general information

**Privileges:** ```CLUSTER_VIEW, NODE_VIEW``` <br><br>Fetch general information about the node to which the request is sent to.
*/
func (a *Client) NodeInformation(params *NodeInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeInformationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeInformationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Node Information",
		Method:             "GET",
		PathPattern:        "/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeInformationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeInformationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeInformationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PublicKeyRequest gets the SSH public key

**Privileges:** ```PROTECTION_MODIFY``` <br><br>Get the SSH public key corresponding to the private key used by workloads. For example, users may specify multiple scripts which are supposed to be executed on a remote machine at different progress states of a protection group run (for instance - running a script before the run starts and another after the run completes). The public key returned as part of this response should be added on the remote server where the script is to be executed as there is a specific private key used by the workload for remote login.
*/
func (a *Client) PublicKeyRequest(params *PublicKeyRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublicKeyRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicKeyRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PublicKeyRequest",
		Method:             "POST",
		PathPattern:        "/clusters/ssh-public-key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicKeyRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublicKeyRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublicKeyRequestDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RemoveRemoteDisk removes remote disk

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Remove a remote disk.
*/
func (a *Client) RemoveRemoteDisk(params *RemoveRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveRemoteDiskNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoveRemoteDiskParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RemoveRemoteDisk",
		Method:             "DELETE",
		PathPattern:        "/disks/remote/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RemoveRemoteDiskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoveRemoteDiskNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RemoveRemoteDiskDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SetNodePower reboots or shutdown nodes in cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Reboot or shutdown nodes in cluster.
*/
func (a *Client) SetNodePower(params *SetNodePowerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetNodePowerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetNodePowerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SetNodePower",
		Method:             "POST",
		PathPattern:        "/node-power",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetNodePowerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetNodePowerNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SetNodePowerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAMQPTargetConfig updates a m q p target config

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates AMQP target config on the cluster.
*/
func (a *Client) UpdateAMQPTargetConfig(params *UpdateAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAMQPTargetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAMQPTargetConfig",
		Method:             "PUT",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAMQPTargetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAirgapConfig updates airgap config

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Enable or Disable Airgap on the cluster.
*/
func (a *Client) UpdateAirgapConfig(params *UpdateAirgapConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAirgapConfigAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAirgapConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAirgapConfig",
		Method:             "PUT",
		PathPattern:        "/clusters/airgap",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAirgapConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAirgapConfigAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateAirgapConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateChassisByID updates a chassis by chassis id

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update selected properties of chassis info by id.
*/
func (a *Client) UpdateChassisByID(params *UpdateChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChassisByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateChassisByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateChassisById",
		Method:             "PATCH",
		PathPattern:        "/chassis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateChassisByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateChassisByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateChassisByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateCluster updates a cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update the Cluster with the given configuration.
*/
func (a *Client) UpdateCluster(params *UpdateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateCluster",
		Method:             "PUT",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterSnapshotPolicy updates cluster snapshot policy

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update cluster snapshot policy.
*/
func (a *Client) UpdateClusterSnapshotPolicy(params *UpdateClusterSnapshotPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSnapshotPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterSnapshotPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterSnapshotPolicy",
		Method:             "PUT",
		PathPattern:        "/clusters/snapshot-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterSnapshotPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterSnapshotPolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterSnapshotPolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateFeatureFlag updates feature flag override status

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update a feature flag override status to cluster.
*/
func (a *Client) UpdateFeatureFlag(params *UpdateFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateFeatureFlagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateFeatureFlagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateFeatureFlag",
		Method:             "PUT",
		PathPattern:        "/clusters/feature-flag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateFeatureFlagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateFeatureFlagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateFeatureFlagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateHosts updates host mappings

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates Host Mapping on the Cluster.
*/
func (a *Client) UpdateHosts(params *UpdateHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateHosts",
		Method:             "PUT",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIsDMaaSCluster updates whether the cluster is a d maa s cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update whether the cluster is a DMaaS cluster.
*/
func (a *Client) UpdateIsDMaaSCluster(params *UpdateIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIsDMaaSClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIsDMaaSClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIsDMaaSCluster",
		Method:             "PUT",
		PathPattern:        "/clusters/is-dmaas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIsDMaaSClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIsDMaaSClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIsDMaaSClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRackByID **Privileges:** ```CLUSTER_MODIFY``` <br><br>Update selected properties of a rack given by id.
*/
func (a *Client) UpdateRackByID(params *UpdateRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRackByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRackById",
		Method:             "PATCH",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRackByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRacks updates racks

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Updates list of racks with name, chassis list or/and location
*/
func (a *Client) UpdateRacks(params *UpdateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRacksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRacks",
		Method:             "PATCH",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRacksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateSMTPConfiguration updates SMTP configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update SMTP configuration.
*/
func (a *Client) UpdateSMTPConfiguration(params *UpdateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSMTPConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateSMTPConfiguration",
		Method:             "PUT",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSMTPConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateSupportChannelConfig updates support channel configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update support channel configuration.
*/
func (a *Client) UpdateSupportChannelConfig(params *UpdateSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSupportChannelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSupportChannelConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateSupportChannelConfig",
		Method:             "PUT",
		PathPattern:        "/support-channel-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSupportChannelConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSupportChannelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateSupportChannelConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeCheckGetResults gets upgrade checks results

```Unknown Privileges``` <br><br>Get upgrade checks results.
*/
func (a *Client) UpgradeCheckGetResults(params *UpgradeCheckGetResultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckGetResultsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeCheckGetResultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCheckGetResults",
		Method:             "GET",
		PathPattern:        "/cluster/upgrade-checks/{testRunInstanceId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeCheckGetResultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeCheckGetResultsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeCheckGetResultsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeCheckRunTests runs upgrade checks on cluster

```Unknown Privileges``` <br><br>Run upgrade checks on cluster.
*/
func (a *Client) UpgradeCheckRunTests(params *UpgradeCheckRunTestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckRunTestsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeCheckRunTestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCheckRunTests",
		Method:             "PUT",
		PathPattern:        "/cluster/upgrade-checks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeCheckRunTestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeCheckRunTestsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeCheckRunTestsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeClusterSoftware upgrades cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Upgrade the software on the cluster.
*/
func (a *Client) UpgradeClusterSoftware(params *UpgradeClusterSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeClusterSoftwareAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeClusterSoftwareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeClusterSoftware",
		Method:             "PUT",
		PathPattern:        "/clusters/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeClusterSoftwareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeClusterSoftwareAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeClusterSoftwareDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ValidateSMTPConfiguration validates SMTP configuration

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Validate SMTP configuration by sending a test email.
*/
func (a *Client) ValidateSMTPConfiguration(params *ValidateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ValidateSMTPConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ValidateSMTPConfiguration",
		Method:             "POST",
		PathPattern:        "/clusters/smtp/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateSMTPConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ValidateSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
