// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AwsProtectionSource AWS Protection Source.
//
// Specifies a Protection Source in AWS environment.
//
// swagger:model AwsProtectionSource
type AwsProtectionSource struct {

	// Specifies Access key of the AWS account.
	AccessKey *string `json:"accessKey,omitempty"`

	// Specifies Amazon Resource Name (owner ID) of the IAM user, act as an
	// unique identifier of as AWS entity.
	AmazonResourceName *string `json:"amazonResourceName,omitempty"`

	// Specifies the authentication method to be used for API calls.
	// Specifies the authentication method to be used for API calls.
	// 'kUseIAMUser' indicates a user based authentication.
	// 'kUseIAMRole' indicates a role based authentication, used only for AWS CE.
	// 'kUseHelios' indicates a Helios based authentication.
	// Enum: ["kUseIAMUser","kUseIAMRole","kUseHelios"]
	AuthMethod *string `json:"authMethod,omitempty"`

	// Specifies information related to AWS fleets launched for various purposes.
	// This will only be set for kIAMUser entity.
	AwsFleetParams *AwsFleetPublicParams `json:"awsFleetParams,omitempty"`

	// Specifies the entity type such as 'kIAMUser' if the environment is kAWS.
	// Specifies the type of an AWS source entity.
	// 'kIAMUser' indicates a unique user within an AWS account.
	// 'kRegion' indicates a geographical region in the global infrastructure.
	// 'kAvailabilityZone' indicates an availability zone within a region.
	// 'kEC2Instance' indicates a Virtual Machine running in AWS environment.
	// 'kVPC' indicates a virtual private cloud (VPC) network within AWS.
	// 'kSubnet' indicates a subnet inside the VPC.
	// 'kNetworkSecurityGroup' represents a network security group.
	// 'kInstanceType' represents various machine types.
	// 'kKeyPair' represents a pair of public and private key used to login into a Virtual Machine.
	// 'kTag' represents a tag attached to EC2 instance.
	// 'kRDSOptionGroup' represents a RDS option group for configuring database features.
	// 'kRDSParameterGroup' represents a RDS parameter group.
	// 'kRDSInstance' represents a RDS DB instance.
	// 'kRDSSubnet' represents a RDS subnet.
	// 'kRDSTag' represents a tag attached to RDS instance.
	// 'kAuroraTag' represents a tag attached to an Aurora cluster.
	// 'kAccount' represents an AWS account.
	// 'kAuroraCluster' represents an Aurora cluster.
	// 'kSubTaskPermit' entity type will be used by slave sub-tasks to take permit for native backups,
	// so that we can control the number of concurrent sub-tasks independent of the number of VMs being backed up concurrently.
	// This does not represent any entity type in AWS entity hierarchy.
	// 'kS3Bucket' represents an S3 bucket.
	// 'kS3Tag' represents an S3 tag attached to S3 Bucket.
	// 'kKmsKey' represents a KMS key.
	// Enum: ["kIAMUser","kRegion","kAvailabilityZone","kEC2Instance","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kKeyPair","kTag","kRDSOptionGroup","kRDSParameterGroup","kRDSInstance","kRDSSubnet","kRDSTag","kAuroraTag","kAccount","kAuroraCluster","kSubTaskPermit","kS3Bucket","kS3Tag","kKmsKey"]
	AwsType *string `json:"awsType,omitempty"`

	// Specifies the C2S Access Portal (CAP) server info.
	C2sServerInfo *C2SServerInfo `json:"c2sServerInfo,omitempty"`

	// Specifies information related to cluster. This is only valid for CE
	// clusters. This is only populated for kIAMUser entity.
	ClusterNetworkInfo *FleetNetworkParams `json:"clusterNetworkInfo,omitempty"`

	// Specifies DB engine version info of the entity. This is populated only
	// for RDSInstance, RDSOptionGroup and RDSParameterGroup entity types.
	DbEngineID *string `json:"dbEngineId,omitempty"`

	// Specifies the OS type of the Protection Source of type 'kVirtualMachine'
	// such as 'kWindows' or 'kLinux'.
	// overrideDescription: true
	// 'kLinux' indicates the Linux operating system.
	// 'kWindows' indicates the Microsoft Windows operating system.
	// 'kAix' indicates the IBM AIX operating system.
	// 'kSolaris' indicates the Oracle Solaris operating system.
	// 'kSapHana' indicates the Sap Hana database system developed by SAP SE.
	// 'kSapOracle' indicates the Sap Oracle database system developed by SAP SE.
	// 'kCockroachDB' indicates the CockroachDB database system.
	// 'kMySQL' indicates the MySQL database system.
	// 'kSapSybase' indicates the SapSybase database system.
	// 'kSapMaxDB' indicates the SapMaxDB database system.
	// 'kSapSybaseIQ' indicates the SapSybaseIQ database system.
	// 'kDB2' indicates the DB2 database system.
	// 'kSapASE' indicates the SapASE database system.
	// 'kMariaDB' indicates the MariaDB database system.
	// 'kPostgreSQL' indicates the PostgreSQL database system.
	// 'kHPUX' indicates the HPUX database system.
	// 'kVOS' indicates the VOS database system.
	// 'kOther' indicates the other types of operating system.
	// Enum: ["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]
	HostType *string `json:"hostType,omitempty"`

	// Specifies the IAM role which will be used to access the security
	// credentials required for API calls.
	IamRoleArn *string `json:"iamRoleArn,omitempty"`

	// Specifies the IP address of the entity of type 'kVirtualMachine'.
	IPAddresses *string `json:"ipAddresses,omitempty"`

	// Specifies the name of the Object set by the Cloud Provider.
	// If the provider did not set a name for the object, this field is not set.
	Name *string `json:"name,omitempty"`

	// Specifies the owner id of the resource in AWS environment. With type,
	// name and ownerId gives a globally unique identity to the AWS entity.
	OwnerID *string `json:"ownerId,omitempty"`

	// Specifies the Protection Source id of the registered Physical Host.
	// If the cloud entity is protected using a Physical Agent, it must be
	// registered as a physical host.
	PhysicalSourceID *int64 `json:"physicalSourceId,omitempty"`

	// Specifies the region Id of the entity if the entity is an EC2 instance.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies the unique Id of the resource given by the cloud provider.
	ResourceID *string `json:"resourceId,omitempty"`

	// Specifies the id of the "convert and deploy" restore task that
	// created the entity in the cloud.
	//
	// It is required to support the DR-to-cloud usecase where we replicate an
	// on-prem entity to a cluster running in cloud, bring it up using
	// "convert and deploy" mechanism, protect it using a cloud job that uses
	// physical adapter, and convert it back to the on-prem format before
	// replication.
	//
	// Before replicating, we need to update the backup task state of the backed
	// up entity using the on-prem entity and on-prem entity's parent.
	// The id is used to lookup the restore entity that contains details about
	// the on-prem entity.
	//
	// It is set at the time of refreshing the cloud entity hierarchy if all the
	// following conditions are met:
	// Name of the current entity matches with name of any cloud entity
	// deployed using the "convert and deploy" restore task.
	// Restore entity associated with the above matched cloud entity has
	// 'failed_over' flag set to true in its cloud extension.
	RestoreTaskID *int64 `json:"restoreTaskId,omitempty"`

	// Specifies S3 entity specific params.
	S3EntityInfo *S3EntityInfo `json:"s3EntityInfo,omitempty"`

	// Params required for s3 backups for the registered entity.
	S3ProtectionParams *S3ProtectionParams `json:"s3ProtectionParams,omitempty"`

	// Specifies Secret Access key of the AWS account.
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`

	// Specifies the subscription type of AWS such as 'kAWSCommercial' or
	// 'kAWSGovCloud'.
	// Specifies the subscription type of an AWS source entity.
	// 'kAWSCommercial' indicates a standard AWS subscription.
	// 'kAWSGovCloud' indicates a govt AWS subscription.
	// Enum: ["kAWSCommercial","kAWSGovCloud"]
	SubscriptionType *string `json:"subscriptionType,omitempty"`

	// Specifies the list of AWS tag attributes.
	TagAttributes []*TagAttribute `json:"tagAttributes"`

	// Specifies the type of an AWS Protection Source Object such as
	// 'kStorageContainer', 'kVirtualMachine', 'kVirtualNetwork', etc.
	// Specifies the type of an AWS source entity.
	// 'kIAMUser' indicates a unique user within an AWS account.
	// 'kRegion' indicates a geographical region in the global infrastructure.
	// 'kAvailabilityZone' indicates an availability zone within a region.
	// 'kEC2Instance' indicates a Virtual Machine running in AWS environment.
	// 'kVPC' indicates a virtual private cloud (VPC) network within AWS.
	// 'kSubnet' indicates a subnet inside the VPC.
	// 'kNetworkSecurityGroup' represents a network security group.
	// 'kInstanceType' represents various machine types.
	// 'kKeyPair' represents a pair of public and private key used to login into a Virtual Machine.
	// 'kTag' represents a tag attached to EC2 instance.
	// 'kRDSOptionGroup' represents a RDS option group for configuring database features.
	// 'kRDSParameterGroup' represents a RDS parameter group.
	// 'kRDSInstance' represents a RDS DB instance.
	// 'kRDSSubnet' represents a RDS subnet.
	// 'kRDSTag' represents a tag attached to RDS instance.
	// 'kAuroraTag' represents a tag attached to an Aurora cluster.
	// 'kAccount' represents an AWS account.
	// 'kAuroraCluster' represents an Aurora cluster.
	// 'kSubTaskPermit' entity type will be used by slave sub-tasks to take permit for native backups,
	// so that we can control the number of concurrent sub-tasks independent of the number of VMs being backed up concurrently.
	// This does not represent any entity type in AWS entity hierarchy.
	// 'kS3Bucket' represents an S3 bucket.
	// 'kS3Tag' represents an S3 tag attached to S3 Bucket.
	// 'kKmsKey' represents a KMS key.
	// Enum: ["kIAMUser","kRegion","kAvailabilityZone","kEC2Instance","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kKeyPair","kTag","kRDSOptionGroup","kRDSParameterGroup","kRDSInstance","kRDSSubnet","kRDSTag","kAuroraTag","kAccount","kAuroraCluster","kSubTaskPermit","kS3Bucket","kS3Tag","kKmsKey"]
	Type *string `json:"type,omitempty"`

	// Specifies the account id derived from the ARN of the user.
	UserAccountID *string `json:"userAccountId,omitempty"`

	// Specifies the Amazon Resource Name (ARN) of the user.
	UserResourceName *string `json:"userResourceName,omitempty"`

	// Specified the list of EBS volumes attached to the entity if the entity is
	// an EC2 instance.
	Volumes []*EbsVolumeInfo `json:"volumes"`
}

// Validate validates this aws protection source
func (m *AwsProtectionSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsFleetParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateC2sServerInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterNetworkInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3EntityInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3ProtectionParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var awsProtectionSourceTypeAuthMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUseIAMUser","kUseIAMRole","kUseHelios"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		awsProtectionSourceTypeAuthMethodPropEnum = append(awsProtectionSourceTypeAuthMethodPropEnum, v)
	}
}

const (

	// AwsProtectionSourceAuthMethodKUseIAMUser captures enum value "kUseIAMUser"
	AwsProtectionSourceAuthMethodKUseIAMUser string = "kUseIAMUser"

	// AwsProtectionSourceAuthMethodKUseIAMRole captures enum value "kUseIAMRole"
	AwsProtectionSourceAuthMethodKUseIAMRole string = "kUseIAMRole"

	// AwsProtectionSourceAuthMethodKUseHelios captures enum value "kUseHelios"
	AwsProtectionSourceAuthMethodKUseHelios string = "kUseHelios"
)

// prop value enum
func (m *AwsProtectionSource) validateAuthMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, awsProtectionSourceTypeAuthMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AwsProtectionSource) validateAuthMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthMethodEnum("authMethod", "body", *m.AuthMethod); err != nil {
		return err
	}

	return nil
}

func (m *AwsProtectionSource) validateAwsFleetParams(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsFleetParams) { // not required
		return nil
	}

	if m.AwsFleetParams != nil {
		if err := m.AwsFleetParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("awsFleetParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("awsFleetParams")
			}
			return err
		}
	}

	return nil
}

var awsProtectionSourceTypeAwsTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kIAMUser","kRegion","kAvailabilityZone","kEC2Instance","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kKeyPair","kTag","kRDSOptionGroup","kRDSParameterGroup","kRDSInstance","kRDSSubnet","kRDSTag","kAuroraTag","kAccount","kAuroraCluster","kSubTaskPermit","kS3Bucket","kS3Tag","kKmsKey"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		awsProtectionSourceTypeAwsTypePropEnum = append(awsProtectionSourceTypeAwsTypePropEnum, v)
	}
}

const (

	// AwsProtectionSourceAwsTypeKIAMUser captures enum value "kIAMUser"
	AwsProtectionSourceAwsTypeKIAMUser string = "kIAMUser"

	// AwsProtectionSourceAwsTypeKRegion captures enum value "kRegion"
	AwsProtectionSourceAwsTypeKRegion string = "kRegion"

	// AwsProtectionSourceAwsTypeKAvailabilityZone captures enum value "kAvailabilityZone"
	AwsProtectionSourceAwsTypeKAvailabilityZone string = "kAvailabilityZone"

	// AwsProtectionSourceAwsTypeKEC2Instance captures enum value "kEC2Instance"
	AwsProtectionSourceAwsTypeKEC2Instance string = "kEC2Instance"

	// AwsProtectionSourceAwsTypeKVPC captures enum value "kVPC"
	AwsProtectionSourceAwsTypeKVPC string = "kVPC"

	// AwsProtectionSourceAwsTypeKSubnet captures enum value "kSubnet"
	AwsProtectionSourceAwsTypeKSubnet string = "kSubnet"

	// AwsProtectionSourceAwsTypeKNetworkSecurityGroup captures enum value "kNetworkSecurityGroup"
	AwsProtectionSourceAwsTypeKNetworkSecurityGroup string = "kNetworkSecurityGroup"

	// AwsProtectionSourceAwsTypeKInstanceType captures enum value "kInstanceType"
	AwsProtectionSourceAwsTypeKInstanceType string = "kInstanceType"

	// AwsProtectionSourceAwsTypeKKeyPair captures enum value "kKeyPair"
	AwsProtectionSourceAwsTypeKKeyPair string = "kKeyPair"

	// AwsProtectionSourceAwsTypeKTag captures enum value "kTag"
	AwsProtectionSourceAwsTypeKTag string = "kTag"

	// AwsProtectionSourceAwsTypeKRDSOptionGroup captures enum value "kRDSOptionGroup"
	AwsProtectionSourceAwsTypeKRDSOptionGroup string = "kRDSOptionGroup"

	// AwsProtectionSourceAwsTypeKRDSParameterGroup captures enum value "kRDSParameterGroup"
	AwsProtectionSourceAwsTypeKRDSParameterGroup string = "kRDSParameterGroup"

	// AwsProtectionSourceAwsTypeKRDSInstance captures enum value "kRDSInstance"
	AwsProtectionSourceAwsTypeKRDSInstance string = "kRDSInstance"

	// AwsProtectionSourceAwsTypeKRDSSubnet captures enum value "kRDSSubnet"
	AwsProtectionSourceAwsTypeKRDSSubnet string = "kRDSSubnet"

	// AwsProtectionSourceAwsTypeKRDSTag captures enum value "kRDSTag"
	AwsProtectionSourceAwsTypeKRDSTag string = "kRDSTag"

	// AwsProtectionSourceAwsTypeKAuroraTag captures enum value "kAuroraTag"
	AwsProtectionSourceAwsTypeKAuroraTag string = "kAuroraTag"

	// AwsProtectionSourceAwsTypeKAccount captures enum value "kAccount"
	AwsProtectionSourceAwsTypeKAccount string = "kAccount"

	// AwsProtectionSourceAwsTypeKAuroraCluster captures enum value "kAuroraCluster"
	AwsProtectionSourceAwsTypeKAuroraCluster string = "kAuroraCluster"

	// AwsProtectionSourceAwsTypeKSubTaskPermit captures enum value "kSubTaskPermit"
	AwsProtectionSourceAwsTypeKSubTaskPermit string = "kSubTaskPermit"

	// AwsProtectionSourceAwsTypeKS3Bucket captures enum value "kS3Bucket"
	AwsProtectionSourceAwsTypeKS3Bucket string = "kS3Bucket"

	// AwsProtectionSourceAwsTypeKS3Tag captures enum value "kS3Tag"
	AwsProtectionSourceAwsTypeKS3Tag string = "kS3Tag"

	// AwsProtectionSourceAwsTypeKKmsKey captures enum value "kKmsKey"
	AwsProtectionSourceAwsTypeKKmsKey string = "kKmsKey"
)

// prop value enum
func (m *AwsProtectionSource) validateAwsTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, awsProtectionSourceTypeAwsTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AwsProtectionSource) validateAwsType(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAwsTypeEnum("awsType", "body", *m.AwsType); err != nil {
		return err
	}

	return nil
}

func (m *AwsProtectionSource) validateC2sServerInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.C2sServerInfo) { // not required
		return nil
	}

	if m.C2sServerInfo != nil {
		if err := m.C2sServerInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c2sServerInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("c2sServerInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) validateClusterNetworkInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterNetworkInfo) { // not required
		return nil
	}

	if m.ClusterNetworkInfo != nil {
		if err := m.ClusterNetworkInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterNetworkInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterNetworkInfo")
			}
			return err
		}
	}

	return nil
}

var awsProtectionSourceTypeHostTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		awsProtectionSourceTypeHostTypePropEnum = append(awsProtectionSourceTypeHostTypePropEnum, v)
	}
}

const (

	// AwsProtectionSourceHostTypeKLinux captures enum value "kLinux"
	AwsProtectionSourceHostTypeKLinux string = "kLinux"

	// AwsProtectionSourceHostTypeKWindows captures enum value "kWindows"
	AwsProtectionSourceHostTypeKWindows string = "kWindows"

	// AwsProtectionSourceHostTypeKAix captures enum value "kAix"
	AwsProtectionSourceHostTypeKAix string = "kAix"

	// AwsProtectionSourceHostTypeKSolaris captures enum value "kSolaris"
	AwsProtectionSourceHostTypeKSolaris string = "kSolaris"

	// AwsProtectionSourceHostTypeKSapHana captures enum value "kSapHana"
	AwsProtectionSourceHostTypeKSapHana string = "kSapHana"

	// AwsProtectionSourceHostTypeKSapOracle captures enum value "kSapOracle"
	AwsProtectionSourceHostTypeKSapOracle string = "kSapOracle"

	// AwsProtectionSourceHostTypeKCockroachDB captures enum value "kCockroachDB"
	AwsProtectionSourceHostTypeKCockroachDB string = "kCockroachDB"

	// AwsProtectionSourceHostTypeKMySQL captures enum value "kMySQL"
	AwsProtectionSourceHostTypeKMySQL string = "kMySQL"

	// AwsProtectionSourceHostTypeKOther captures enum value "kOther"
	AwsProtectionSourceHostTypeKOther string = "kOther"

	// AwsProtectionSourceHostTypeKSapSybase captures enum value "kSapSybase"
	AwsProtectionSourceHostTypeKSapSybase string = "kSapSybase"

	// AwsProtectionSourceHostTypeKSapMaxDB captures enum value "kSapMaxDB"
	AwsProtectionSourceHostTypeKSapMaxDB string = "kSapMaxDB"

	// AwsProtectionSourceHostTypeKSapSybaseIQ captures enum value "kSapSybaseIQ"
	AwsProtectionSourceHostTypeKSapSybaseIQ string = "kSapSybaseIQ"

	// AwsProtectionSourceHostTypeKDB2 captures enum value "kDB2"
	AwsProtectionSourceHostTypeKDB2 string = "kDB2"

	// AwsProtectionSourceHostTypeKSapASE captures enum value "kSapASE"
	AwsProtectionSourceHostTypeKSapASE string = "kSapASE"

	// AwsProtectionSourceHostTypeKMariaDB captures enum value "kMariaDB"
	AwsProtectionSourceHostTypeKMariaDB string = "kMariaDB"

	// AwsProtectionSourceHostTypeKPostgreSQL captures enum value "kPostgreSQL"
	AwsProtectionSourceHostTypeKPostgreSQL string = "kPostgreSQL"

	// AwsProtectionSourceHostTypeKVOS captures enum value "kVOS"
	AwsProtectionSourceHostTypeKVOS string = "kVOS"

	// AwsProtectionSourceHostTypeKHPUX captures enum value "kHPUX"
	AwsProtectionSourceHostTypeKHPUX string = "kHPUX"
)

// prop value enum
func (m *AwsProtectionSource) validateHostTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, awsProtectionSourceTypeHostTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AwsProtectionSource) validateHostType(formats strfmt.Registry) error {
	if swag.IsZero(m.HostType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHostTypeEnum("hostType", "body", *m.HostType); err != nil {
		return err
	}

	return nil
}

func (m *AwsProtectionSource) validateS3EntityInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.S3EntityInfo) { // not required
		return nil
	}

	if m.S3EntityInfo != nil {
		if err := m.S3EntityInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3EntityInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3EntityInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) validateS3ProtectionParams(formats strfmt.Registry) error {
	if swag.IsZero(m.S3ProtectionParams) { // not required
		return nil
	}

	if m.S3ProtectionParams != nil {
		if err := m.S3ProtectionParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3ProtectionParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3ProtectionParams")
			}
			return err
		}
	}

	return nil
}

var awsProtectionSourceTypeSubscriptionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAWSCommercial","kAWSGovCloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		awsProtectionSourceTypeSubscriptionTypePropEnum = append(awsProtectionSourceTypeSubscriptionTypePropEnum, v)
	}
}

const (

	// AwsProtectionSourceSubscriptionTypeKAWSCommercial captures enum value "kAWSCommercial"
	AwsProtectionSourceSubscriptionTypeKAWSCommercial string = "kAWSCommercial"

	// AwsProtectionSourceSubscriptionTypeKAWSGovCloud captures enum value "kAWSGovCloud"
	AwsProtectionSourceSubscriptionTypeKAWSGovCloud string = "kAWSGovCloud"
)

// prop value enum
func (m *AwsProtectionSource) validateSubscriptionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, awsProtectionSourceTypeSubscriptionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AwsProtectionSource) validateSubscriptionType(formats strfmt.Registry) error {
	if swag.IsZero(m.SubscriptionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubscriptionTypeEnum("subscriptionType", "body", *m.SubscriptionType); err != nil {
		return err
	}

	return nil
}

func (m *AwsProtectionSource) validateTagAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.TagAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.TagAttributes); i++ {
		if swag.IsZero(m.TagAttributes[i]) { // not required
			continue
		}

		if m.TagAttributes[i] != nil {
			if err := m.TagAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var awsProtectionSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kIAMUser","kRegion","kAvailabilityZone","kEC2Instance","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kKeyPair","kTag","kRDSOptionGroup","kRDSParameterGroup","kRDSInstance","kRDSSubnet","kRDSTag","kAuroraTag","kAccount","kAuroraCluster","kSubTaskPermit","kS3Bucket","kS3Tag","kKmsKey"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		awsProtectionSourceTypeTypePropEnum = append(awsProtectionSourceTypeTypePropEnum, v)
	}
}

const (

	// AwsProtectionSourceTypeKIAMUser captures enum value "kIAMUser"
	AwsProtectionSourceTypeKIAMUser string = "kIAMUser"

	// AwsProtectionSourceTypeKRegion captures enum value "kRegion"
	AwsProtectionSourceTypeKRegion string = "kRegion"

	// AwsProtectionSourceTypeKAvailabilityZone captures enum value "kAvailabilityZone"
	AwsProtectionSourceTypeKAvailabilityZone string = "kAvailabilityZone"

	// AwsProtectionSourceTypeKEC2Instance captures enum value "kEC2Instance"
	AwsProtectionSourceTypeKEC2Instance string = "kEC2Instance"

	// AwsProtectionSourceTypeKVPC captures enum value "kVPC"
	AwsProtectionSourceTypeKVPC string = "kVPC"

	// AwsProtectionSourceTypeKSubnet captures enum value "kSubnet"
	AwsProtectionSourceTypeKSubnet string = "kSubnet"

	// AwsProtectionSourceTypeKNetworkSecurityGroup captures enum value "kNetworkSecurityGroup"
	AwsProtectionSourceTypeKNetworkSecurityGroup string = "kNetworkSecurityGroup"

	// AwsProtectionSourceTypeKInstanceType captures enum value "kInstanceType"
	AwsProtectionSourceTypeKInstanceType string = "kInstanceType"

	// AwsProtectionSourceTypeKKeyPair captures enum value "kKeyPair"
	AwsProtectionSourceTypeKKeyPair string = "kKeyPair"

	// AwsProtectionSourceTypeKTag captures enum value "kTag"
	AwsProtectionSourceTypeKTag string = "kTag"

	// AwsProtectionSourceTypeKRDSOptionGroup captures enum value "kRDSOptionGroup"
	AwsProtectionSourceTypeKRDSOptionGroup string = "kRDSOptionGroup"

	// AwsProtectionSourceTypeKRDSParameterGroup captures enum value "kRDSParameterGroup"
	AwsProtectionSourceTypeKRDSParameterGroup string = "kRDSParameterGroup"

	// AwsProtectionSourceTypeKRDSInstance captures enum value "kRDSInstance"
	AwsProtectionSourceTypeKRDSInstance string = "kRDSInstance"

	// AwsProtectionSourceTypeKRDSSubnet captures enum value "kRDSSubnet"
	AwsProtectionSourceTypeKRDSSubnet string = "kRDSSubnet"

	// AwsProtectionSourceTypeKRDSTag captures enum value "kRDSTag"
	AwsProtectionSourceTypeKRDSTag string = "kRDSTag"

	// AwsProtectionSourceTypeKAuroraTag captures enum value "kAuroraTag"
	AwsProtectionSourceTypeKAuroraTag string = "kAuroraTag"

	// AwsProtectionSourceTypeKAccount captures enum value "kAccount"
	AwsProtectionSourceTypeKAccount string = "kAccount"

	// AwsProtectionSourceTypeKAuroraCluster captures enum value "kAuroraCluster"
	AwsProtectionSourceTypeKAuroraCluster string = "kAuroraCluster"

	// AwsProtectionSourceTypeKSubTaskPermit captures enum value "kSubTaskPermit"
	AwsProtectionSourceTypeKSubTaskPermit string = "kSubTaskPermit"

	// AwsProtectionSourceTypeKS3Bucket captures enum value "kS3Bucket"
	AwsProtectionSourceTypeKS3Bucket string = "kS3Bucket"

	// AwsProtectionSourceTypeKS3Tag captures enum value "kS3Tag"
	AwsProtectionSourceTypeKS3Tag string = "kS3Tag"

	// AwsProtectionSourceTypeKKmsKey captures enum value "kKmsKey"
	AwsProtectionSourceTypeKKmsKey string = "kKmsKey"
)

// prop value enum
func (m *AwsProtectionSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, awsProtectionSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AwsProtectionSource) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *AwsProtectionSource) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this aws protection source based on the context it is used
func (m *AwsProtectionSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwsFleetParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateC2sServerInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterNetworkInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3EntityInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3ProtectionParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTagAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AwsProtectionSource) contextValidateAwsFleetParams(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsFleetParams != nil {

		if swag.IsZero(m.AwsFleetParams) { // not required
			return nil
		}

		if err := m.AwsFleetParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("awsFleetParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("awsFleetParams")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) contextValidateC2sServerInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.C2sServerInfo != nil {

		if swag.IsZero(m.C2sServerInfo) { // not required
			return nil
		}

		if err := m.C2sServerInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c2sServerInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("c2sServerInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) contextValidateClusterNetworkInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterNetworkInfo != nil {

		if swag.IsZero(m.ClusterNetworkInfo) { // not required
			return nil
		}

		if err := m.ClusterNetworkInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterNetworkInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterNetworkInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) contextValidateS3EntityInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.S3EntityInfo != nil {

		if swag.IsZero(m.S3EntityInfo) { // not required
			return nil
		}

		if err := m.S3EntityInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3EntityInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3EntityInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) contextValidateS3ProtectionParams(ctx context.Context, formats strfmt.Registry) error {

	if m.S3ProtectionParams != nil {

		if swag.IsZero(m.S3ProtectionParams) { // not required
			return nil
		}

		if err := m.S3ProtectionParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3ProtectionParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3ProtectionParams")
			}
			return err
		}
	}

	return nil
}

func (m *AwsProtectionSource) contextValidateTagAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TagAttributes); i++ {

		if m.TagAttributes[i] != nil {

			if swag.IsZero(m.TagAttributes[i]) { // not required
				return nil
			}

			if err := m.TagAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AwsProtectionSource) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {

			if swag.IsZero(m.Volumes[i]) { // not required
				return nil
			}

			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AwsProtectionSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AwsProtectionSource) UnmarshalBinary(b []byte) error {
	var res AwsProtectionSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
