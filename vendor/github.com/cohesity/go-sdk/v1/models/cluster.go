// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster Cohesity Cluster.
//
// Specifies information about the Cohesity Cluster.
//
// swagger:model Cluster
type Cluster struct {

	// Specifies the default AES Encryption mode on the cluster.
	AesEncryptionMode *string `json:"aesEncryptionMode,omitempty"`

	// Specifies the AMQP target config.
	AmqpTargetConfig *AMQPTargetConfig `json:"amqpTargetConfig,omitempty"`

	// The subnet for Athena apps.
	AppsSubnet *Subnet `json:"appsSubnet,omitempty"`

	// Specifies the number of racks in cluster with at least one rack assigned.
	AssignedRacksCount *int32 `json:"assignedRacksCount,omitempty"`

	// To attempt agent connection on port 21213 first
	AttemptAgentPortsUpgrade *bool `json:"attemptAgentPortsUpgrade,omitempty"`

	// Bool specifying if cluster can support authHeaders for upgrade
	AuthSupportForPkgDownloads *bool `json:"authSupportForPkgDownloads,omitempty"`

	// Information about storage available for metadata
	AvailableMetadataSpace *int64 `json:"availableMetadataSpace,omitempty"`

	// Specifies whether UI banner is enabled on the cluster or not. When banner
	// is enabled, UI will make an additional API call to fetch the banner and
	// show at the login page.
	BannerEnabled *bool `json:"bannerEnabled,omitempty"`

	// Specifies the number of chassis in cluster.
	ChassisCount *int32 `json:"chassisCount,omitempty"`

	// Specifies the type from which the cluster was claimed to Helios.
	// 'kCohesity' implies Cohesity cluster is claimed.
	// 'kIBMStroageProtect' implies IBM storage protect cluster is claimed.
	// Enum: ["kCohesity","kIBMStorageProtect"]
	ClaimType *string `json:"claimType,omitempty"`

	// Cluster Audit Log Configuration.
	ClusterAuditLogConfig *ClusterAuditLogConfiguration `json:"clusterAuditLogConfig,omitempty"`

	// Specifies the size of Cloud Edition(CE) Cluster such as kSmall, kNextGen.
	// Specifies the clustersize of the cloud edition(CE) clusters.
	// 'kSmall' indicates small cluster size of CE.
	// 'kMedium' indicates medium cluster size of CE.
	// 'kLarge' indicates large cluster size of CE.
	// 'kXLarge' indicates extra large cluster size of CE.
	// 'kNextGen' indicates next gen CE.
	// Enum: ["kSmall","kMedium","kLarge","kXLarge","kNextGen"]
	ClusterSize *string `json:"clusterSize,omitempty"`

	// Specifies the current release of the Cohesity software running on
	// this Cohesity Cluster.
	ClusterSoftwareVersion *string `json:"clusterSoftwareVersion,omitempty"`

	// Specifies the type of Cluster such as kPhysical.
	// 'kPhysical' indicates the Cohesity Cluster is hosted directly on hardware.
	// 'kVirtualRobo' indicates the Cohesity Cluster is hosted in a VM on
	// a ESXi Host of a VMware vCenter Server using Cohesity's Virtual Edition.
	// 'kMicrosoftCloud' indicates the Cohesity Cluster is hosted in a VM
	// on Microsoft Azure using Cohesity's Cloud Edition.
	// 'kAmazonCloud' indicates the Cohesity Cluster is hosted in a VM
	// on Amazon S3 using Cohesity's Cloud Edition.
	// 'kGoogleCloud' indicates the Cohesity Cluster is hosted in a VM
	// on Google Cloud Platform using Cohesity's Cloud Edition.
	// Enum: ["kPhysical","kVirtualRobo","kMicrosoftCloud","kAmazonCloud","kGoogleCloud"]
	ClusterType *string `json:"clusterType,omitempty"`

	// Specifies the time when the Cohesity Cluster was created.
	// This value is specified as a Unix epoch Timestamp (in microseconds).
	CreatedTimeMsecs *int64 `json:"createdTimeMsecs,omitempty"`

	// Specifies the time scheduled by the Cohesity Cluster to
	// start the current running operation.
	CurrentOpScheduledTimeSecs *int64 `json:"currentOpScheduledTimeSecs,omitempty"`

	// Specifies the current Cluster-level operation in progress.
	// 'kUpgrade' indicates the Cohesity Cluster is upgrading to a new release.
	// 'kRemoveNode' indicates the Cohesity Cluster is removing a Node
	// from the Cluster.
	// 'kNone' indicates no action is occurring on the Cohesity Cluster.
	// 'kDestroy' indicates the Cohesity Cluster is getting destoryed.
	// 'kClean' indicates the Cohesity Cluster is getting cleaned.
	// 'kRestartServices' indicates the Cohesity Cluster is restarting the
	// services.
	// 'kRestartSystemServices' indicates the Cohesity Cluster is restarting the
	// system services.
	// Enum: ["kRemoveNode","kUpgrade","kNone","kDestroy","kClean","kRestartServices","kRestartSystemServices"]
	CurrentOperation *string `json:"currentOperation,omitempty"`

	// Specifies the current system time on the Cohesity Cluster.
	// This value is specified as a Unix epoch Timestamp (in microseconds).
	CurrentTimeMsecs *int64 `json:"currentTimeMsecs,omitempty"`

	// Specifies the number of disks on the cluster by Storage Tier.
	// Read Only: true
	DiskCountByTier []*CountByTier `json:"diskCountByTier"`

	// Array of IP Addresses of DNS Servers.
	//
	// Specifies the IP addresses of the DNS Servers used by the Cohesity
	// Cluster.
	DNSServerIps []string `json:"dnsServerIps"`

	// Array of Domain Names.
	//
	// The first domain name specified in the array is the fully qualified
	// domain name assigned to the Cohesity Cluster. Any additional
	// domain names specified are used for the domain search list for
	// hostname look-up.
	DomainNames []string `json:"domainNames"`

	// Specifies if Cohesity can receive monitoring information from the
	// Cohesity Cluster.
	// If 'true', remote monitoring of the Cohesity Cluster is allowed.
	EnableActiveMonitoring *bool `json:"enableActiveMonitoring,omitempty"`

	// Specifies whether to enable downloading patches from Cohesity download
	// site.
	EnablePatchesDownload *bool `json:"enablePatchesDownload,omitempty"`

	// If 'true', Cohesity's upgrade server is polled for new releases.
	EnableUpgradePkgPolling *bool `json:"enableUpgradePkgPolling,omitempty"`

	// If 'true', the entire Cohesity Cluster is encrypted including all View
	// Boxes.
	EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

	// Specifies the period of time (in seconds) when encryption keys are rotated.
	// By default, the encryption keys are rotated every 77760000 seconds
	// (30 days).
	EncryptionKeyRotationPeriodSecs *int64 `json:"encryptionKeyRotationPeriodSecs,omitempty"`

	// EULA Acceptance Information.
	//
	// Specifies the End User License Agreement (EULA) acceptance information.
	EulaConfig struct {
		EulaConfig
	} `json:"eulaConfig,omitempty"`

	// Specifies the level which 'MetadataFaultToleranceFactor' applies to.
	// 'kNode' indicates 'MetadataFaultToleranceFactor' applies to Node level.
	// 'kChassis' indicates 'MetadataFaultToleranceFactor' applies to Chassis
	// level.
	// 'kRack' indicates 'MetadataFaultToleranceFactor' applies to Rack level.
	// Enum: ["kNode","kChassis","kRack"]
	FaultToleranceLevel *string `json:"faultToleranceLevel,omitempty"`

	// Filer Audit Log Configuration.
	FilerAuditLogConfig *FilerAuditLogConfiguration `json:"filerAuditLogConfig,omitempty"`

	// Specifies if the Cohesity Cluster should operate in the FIPS mode,
	// which is compliant with the Federal Information Processing Standard
	// 140-2 certification.
	FipsModeEnabled *bool `json:"fipsModeEnabled,omitempty"`

	// Specifies the gateway IP address.
	Gateway *string `json:"gateway,omitempty"`

	// Specifies whether Google Analytics is enabled.
	GoogleAnalyticsEnabled *bool `json:"googleAnalyticsEnabled,omitempty"`

	// Specifies if hardware encryption(SED) is enabled.
	HardwareEncryptionEnabled *bool `json:"hardwareEncryptionEnabled,omitempty"`

	// Specifies a hardware type for motherboard of the nodes
	// that make up this Cohesity Cluster such as S2600WB for Ivy Bridge
	// or S2600TP for Haswell.
	HardwareInfo *ClusterHardwareInfo `json:"hardwareInfo,omitempty"`

	// Specifies the unique id of Cohesity Cluster.
	ID *int64 `json:"id,omitempty"`

	// Specifies the unique incarnation id of the Cohesity Cluster.
	IncarnationID *int64 `json:"incarnationId,omitempty"`

	// IP preference
	IPPreference *int32 `json:"ipPreference,omitempty"`

	// Specifies whether or not athena subnet is clashing with some other
	// internal subnet
	IsAthenaSubnetClash *bool `json:"isAthenaSubnetClash,omitempty"`

	// Specifies if MFA is enabled on cluster.
	IsClusterMfaEnabled *bool `json:"isClusterMfaEnabled,omitempty"`

	// Specifies what version of the documentation is used.
	// If 'true', the version of documentation stored locally on the Cohesity
	// Cluster is used.
	// If 'false', the documentation stored on a Cohesity Web Server
	// is used. The default is 'false'.
	// Cohesity recommends accessing the Help from the Cohesity Web site which
	// provides the newest and most complete version of Help.
	IsDocumentationLocal *bool `json:"isDocumentationLocal,omitempty"`

	// Flag to indicate if the current upgrade has been aborted.
	IsUpgradeAborted *bool `json:"isUpgradeAborted,omitempty"`

	// Specifies the KMS Server Id.
	// This can only be set when the encryption is enabled on cluster.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// Specifies the language and locale for this Cohesity Cluster.
	LanguageLocale *string `json:"languageLocale,omitempty"`

	// License State Information.
	//
	// Specifies the Licensing State information.
	LicenseState struct {
		LicenseState
	} `json:"licenseState,omitempty"`

	// Domain name for SMB local authentication.
	LocalAuthDomainName *string `json:"localAuthDomainName,omitempty"`

	// Specifies whether to enable local groups on cluster. Once it is enabled,
	// it cannot be disabled.
	LocalGroupsEnabled *bool `json:"localGroupsEnabled,omitempty"`

	// Specifies metadata fault tolerance setting for the cluster. This denotes
	// the number of simultaneous failures[node] supported by metadata services
	// like gandalf and scribe.
	MetadataFaultToleranceFactor *int32 `json:"metadataFaultToleranceFactor,omitempty"`

	// Specifies minimum failure domains needed in the cluster.
	MinimumFailureDomainsNeeded *int32 `json:"minimumFailureDomainsNeeded,omitempty"`

	// Specifies if multi tenancy is enabled in the cluster. Authentication &
	// Authorization will always use tenant_id, however, some UI elements may be
	// disabled when multi tenancy is disabled.
	MultiTenancyEnabled *bool `json:"multiTenancyEnabled,omitempty"`

	// Specifies the name of the Cohesity Cluster.
	Name *string `json:"name,omitempty"`

	// Specifies the number of Nodes in the Cohesity Cluster.
	NodeCount *int64 `json:"nodeCount,omitempty"`

	// IP addresses of nodes in the cluster
	NodeIps *string `json:"nodeIps,omitempty"`

	// Specifies if the ntp/primary secondary scheme should be disabled for this
	// cluster.
	NtpSettings *NtpSettingsConfig `json:"ntpSettings,omitempty"`

	// Specifies the patch version applied to cluster.
	PatchVersion *string `json:"patchVersion,omitempty"`

	// Specifies the rebalance delay in seconds for cluster PcieSSD storage tier.
	PcieSsdTierRebalanceDelaySecs *int32 `json:"pcieSsdTierRebalanceDelaySecs,omitempty"`

	// Specifies if protorpc encryption is enabled or not.
	ProtoRPCEncryptionEnabled *bool `json:"protoRpcEncryptionEnabled,omitempty"`

	// The subnet reserved for ProxyVM
	ProxyVMSubnet *string `json:"proxyVMSubnet,omitempty"`

	// If 'true', Cohesity's Remote Tunnel is enabled.
	// Cohesity can access the Cluster and provide remote assistance
	// via a Remote Tunnel.
	ReverseTunnelEnabled *bool `json:"reverseTunnelEnabled,omitempty"`

	// ReverseTunnelEndTimeMsecs specifies the end time in milliseconds since
	// epoch until when the reverse tunnel will stay enabled.
	ReverseTunnelEndTimeMsecs *int64 `json:"reverseTunnelEndTimeMsecs,omitempty"`

	// Specifies the list of domain names for S3
	// Virtual Hosted Style Paths. If set, all the Cohesity S3 Views in the
	// cluster can be accessed using any of the specified domain names.
	S3VirtualHostedDomainNames []string `json:"s3VirtualHostedDomainNames"`

	// Specifies the admission control for cluster SATAHDD storage tier.
	SataHddTierAdmissionControl *int32 `json:"sataHddTierAdmissionControl,omitempty"`

	// Specifies the time series schema info of the cluster.
	SchemaInfoList []*SchemaInfo `json:"schemaInfoList"`

	// Specifies if Security Mode DOD is enabled or not.
	SecurityModeDod *bool `json:"securityModeDod,omitempty"`

	// Specifies if Active Directory should be disabled for authentication of SMB
	// shares. If 'true', Active Directory is disabled.
	SmbAdDisabled *bool `json:"smbAdDisabled,omitempty"`

	// Specifies whether SMB multichannel is enabled on the cluster. When this is
	// set to true, then any SMB3 multichannel enabled client can establish
	// multiple TCP connection per session to the Server.
	SmbMultichannelEnabled *bool `json:"smbMultichannelEnabled,omitempty"`

	// Specifies if split key host access is enabled.
	SplitKeyHostAccess *bool `json:"splitKeyHostAccess,omitempty"`

	// Specifies statistics about this Cohesity Cluster.
	Stats *ClusterStats `json:"stats,omitempty"`

	// TODO(mitch) StigMode is deprecated. Should it still be in this list??
	StigMode *bool `json:"stigMode,omitempty"`

	// Information about supported configuration. For example, it contains
	// minimum number of nodes supported for the cluster.
	SupportedConfig *SupportedConfig `json:"supportedConfig,omitempty"`

	// Syslog servers.
	SyslogServers []*OldSyslogServer `json:"syslogServers"`

	// Specifies the Cohesity release that this Cluster is being upgraded to
	// if an upgrade operation is in progress.
	TargetSoftwareVersion *string `json:"targetSoftwareVersion,omitempty"`

	// In case multi tenancy is enabled, this flag controls whether multiple
	// tenants can be placed on the same viewbox. Once set to true, this flag
	// should never become false.
	TenantViewboxSharingEnabled *bool `json:"tenantViewboxSharingEnabled,omitempty"`

	// Tiering Audit Log Configuration.
	TieringAuditLogConfig *TieringAuditLogConfiguration `json:"tieringAuditLogConfig,omitempty"`

	// Specifies the timezone to use for showing time in emails, reports,
	// filer audit logs, etc.
	Timezone *string `json:"timezone,omitempty"`

	// Specifies if the TLS is enabled on the remote cluster.
	TLSEnabled *bool `json:"tlsEnabled,omitempty"`

	// Trust Domain.
	TrustDomain *string `json:"trustDomain,omitempty"`

	// Specifies if the cluster is in Turbo mode.
	TurboMode *bool `json:"turboMode,omitempty"`

	// Error string to capture why the upgrade failed.
	UpgradeFailureErrorString *string `json:"upgradeFailureErrorString,omitempty"`

	// To use default ports 50051 & 21213
	UseDefaultAgentPorts *bool `json:"useDefaultAgentPorts,omitempty"`

	// Specifies whether to enable Heimdall which tells whether services should
	// use temporary fleet instances to mount disks by talking to Heimdall.
	UseHeimdall *bool `json:"useHeimdall,omitempty"`

	// UsedMetadataSpacePct measures the percentage about storage used for
	// metadata over the total storage available for metadata
	UsedMetadataSpacePct *float64 `json:"usedMetadataSpacePct,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmqpTargetConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppsSubnet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClaimType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentOperation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskCountByTier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEulaConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFaultToleranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilerAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHardwareInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLicenseState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNtpSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemaInfoList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyslogServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTieringAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateAmqpTargetConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AmqpTargetConfig) { // not required
		return nil
	}

	if m.AmqpTargetConfig != nil {
		if err := m.AmqpTargetConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amqpTargetConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amqpTargetConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateAppsSubnet(formats strfmt.Registry) error {
	if swag.IsZero(m.AppsSubnet) { // not required
		return nil
	}

	if m.AppsSubnet != nil {
		if err := m.AppsSubnet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appsSubnet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appsSubnet")
			}
			return err
		}
	}

	return nil
}

var clusterTypeClaimTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCohesity","kIBMStorageProtect"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeClaimTypePropEnum = append(clusterTypeClaimTypePropEnum, v)
	}
}

const (

	// ClusterClaimTypeKCohesity captures enum value "kCohesity"
	ClusterClaimTypeKCohesity string = "kCohesity"

	// ClusterClaimTypeKIBMStorageProtect captures enum value "kIBMStorageProtect"
	ClusterClaimTypeKIBMStorageProtect string = "kIBMStorageProtect"
)

// prop value enum
func (m *Cluster) validateClaimTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeClaimTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateClaimType(formats strfmt.Registry) error {
	if swag.IsZero(m.ClaimType) { // not required
		return nil
	}

	// value enum
	if err := m.validateClaimTypeEnum("claimType", "body", *m.ClaimType); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateClusterAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterAuditLogConfig) { // not required
		return nil
	}

	if m.ClusterAuditLogConfig != nil {
		if err := m.ClusterAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

var clusterTypeClusterSizePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSmall","kMedium","kLarge","kXLarge","kNextGen"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeClusterSizePropEnum = append(clusterTypeClusterSizePropEnum, v)
	}
}

const (

	// ClusterClusterSizeKSmall captures enum value "kSmall"
	ClusterClusterSizeKSmall string = "kSmall"

	// ClusterClusterSizeKMedium captures enum value "kMedium"
	ClusterClusterSizeKMedium string = "kMedium"

	// ClusterClusterSizeKLarge captures enum value "kLarge"
	ClusterClusterSizeKLarge string = "kLarge"

	// ClusterClusterSizeKXLarge captures enum value "kXLarge"
	ClusterClusterSizeKXLarge string = "kXLarge"

	// ClusterClusterSizeKNextGen captures enum value "kNextGen"
	ClusterClusterSizeKNextGen string = "kNextGen"
)

// prop value enum
func (m *Cluster) validateClusterSizeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeClusterSizePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateClusterSize(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterSize) { // not required
		return nil
	}

	// value enum
	if err := m.validateClusterSizeEnum("clusterSize", "body", *m.ClusterSize); err != nil {
		return err
	}

	return nil
}

var clusterTypeClusterTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kPhysical","kVirtualRobo","kMicrosoftCloud","kAmazonCloud","kGoogleCloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeClusterTypePropEnum = append(clusterTypeClusterTypePropEnum, v)
	}
}

const (

	// ClusterClusterTypeKPhysical captures enum value "kPhysical"
	ClusterClusterTypeKPhysical string = "kPhysical"

	// ClusterClusterTypeKVirtualRobo captures enum value "kVirtualRobo"
	ClusterClusterTypeKVirtualRobo string = "kVirtualRobo"

	// ClusterClusterTypeKMicrosoftCloud captures enum value "kMicrosoftCloud"
	ClusterClusterTypeKMicrosoftCloud string = "kMicrosoftCloud"

	// ClusterClusterTypeKAmazonCloud captures enum value "kAmazonCloud"
	ClusterClusterTypeKAmazonCloud string = "kAmazonCloud"

	// ClusterClusterTypeKGoogleCloud captures enum value "kGoogleCloud"
	ClusterClusterTypeKGoogleCloud string = "kGoogleCloud"
)

// prop value enum
func (m *Cluster) validateClusterTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeClusterTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateClusterType(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterType) { // not required
		return nil
	}

	// value enum
	if err := m.validateClusterTypeEnum("clusterType", "body", *m.ClusterType); err != nil {
		return err
	}

	return nil
}

var clusterTypeCurrentOperationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kRemoveNode","kUpgrade","kNone","kDestroy","kClean","kRestartServices","kRestartSystemServices"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeCurrentOperationPropEnum = append(clusterTypeCurrentOperationPropEnum, v)
	}
}

const (

	// ClusterCurrentOperationKRemoveNode captures enum value "kRemoveNode"
	ClusterCurrentOperationKRemoveNode string = "kRemoveNode"

	// ClusterCurrentOperationKUpgrade captures enum value "kUpgrade"
	ClusterCurrentOperationKUpgrade string = "kUpgrade"

	// ClusterCurrentOperationKNone captures enum value "kNone"
	ClusterCurrentOperationKNone string = "kNone"

	// ClusterCurrentOperationKDestroy captures enum value "kDestroy"
	ClusterCurrentOperationKDestroy string = "kDestroy"

	// ClusterCurrentOperationKClean captures enum value "kClean"
	ClusterCurrentOperationKClean string = "kClean"

	// ClusterCurrentOperationKRestartServices captures enum value "kRestartServices"
	ClusterCurrentOperationKRestartServices string = "kRestartServices"

	// ClusterCurrentOperationKRestartSystemServices captures enum value "kRestartSystemServices"
	ClusterCurrentOperationKRestartSystemServices string = "kRestartSystemServices"
)

// prop value enum
func (m *Cluster) validateCurrentOperationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeCurrentOperationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateCurrentOperation(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentOperation) { // not required
		return nil
	}

	// value enum
	if err := m.validateCurrentOperationEnum("currentOperation", "body", *m.CurrentOperation); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateDiskCountByTier(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskCountByTier) { // not required
		return nil
	}

	for i := 0; i < len(m.DiskCountByTier); i++ {
		if swag.IsZero(m.DiskCountByTier[i]) { // not required
			continue
		}

		if m.DiskCountByTier[i] != nil {
			if err := m.DiskCountByTier[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskCountByTier" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskCountByTier" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateEulaConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.EulaConfig) { // not required
		return nil
	}

	return nil
}

var clusterTypeFaultToleranceLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNode","kChassis","kRack"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeFaultToleranceLevelPropEnum = append(clusterTypeFaultToleranceLevelPropEnum, v)
	}
}

const (

	// ClusterFaultToleranceLevelKNode captures enum value "kNode"
	ClusterFaultToleranceLevelKNode string = "kNode"

	// ClusterFaultToleranceLevelKChassis captures enum value "kChassis"
	ClusterFaultToleranceLevelKChassis string = "kChassis"

	// ClusterFaultToleranceLevelKRack captures enum value "kRack"
	ClusterFaultToleranceLevelKRack string = "kRack"
)

// prop value enum
func (m *Cluster) validateFaultToleranceLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterTypeFaultToleranceLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateFaultToleranceLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.FaultToleranceLevel) { // not required
		return nil
	}

	// value enum
	if err := m.validateFaultToleranceLevelEnum("faultToleranceLevel", "body", *m.FaultToleranceLevel); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateFilerAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FilerAuditLogConfig) { // not required
		return nil
	}

	if m.FilerAuditLogConfig != nil {
		if err := m.FilerAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filerAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filerAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateHardwareInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.HardwareInfo) { // not required
		return nil
	}

	if m.HardwareInfo != nil {
		if err := m.HardwareInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hardwareInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hardwareInfo")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateLicenseState(formats strfmt.Registry) error {
	if swag.IsZero(m.LicenseState) { // not required
		return nil
	}

	return nil
}

func (m *Cluster) validateNtpSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.NtpSettings) { // not required
		return nil
	}

	if m.NtpSettings != nil {
		if err := m.NtpSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ntpSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ntpSettings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateSchemaInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.SchemaInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.SchemaInfoList); i++ {
		if swag.IsZero(m.SchemaInfoList[i]) { // not required
			continue
		}

		if m.SchemaInfoList[i] != nil {
			if err := m.SchemaInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateSupportedConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.SupportedConfig) { // not required
		return nil
	}

	if m.SupportedConfig != nil {
		if err := m.SupportedConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supportedConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("supportedConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateSyslogServers(formats strfmt.Registry) error {
	if swag.IsZero(m.SyslogServers) { // not required
		return nil
	}

	for i := 0; i < len(m.SyslogServers); i++ {
		if swag.IsZero(m.SyslogServers[i]) { // not required
			continue
		}

		if m.SyslogServers[i] != nil {
			if err := m.SyslogServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) validateTieringAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.TieringAuditLogConfig) { // not required
		return nil
	}

	if m.TieringAuditLogConfig != nil {
		if err := m.TieringAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tieringAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tieringAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmqpTargetConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAppsSubnet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDiskCountByTier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEulaConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilerAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHardwareInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLicenseState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNtpSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemaInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSyslogServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTieringAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateAmqpTargetConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AmqpTargetConfig != nil {

		if swag.IsZero(m.AmqpTargetConfig) { // not required
			return nil
		}

		if err := m.AmqpTargetConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amqpTargetConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amqpTargetConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateAppsSubnet(ctx context.Context, formats strfmt.Registry) error {

	if m.AppsSubnet != nil {

		if swag.IsZero(m.AppsSubnet) { // not required
			return nil
		}

		if err := m.AppsSubnet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appsSubnet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appsSubnet")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateClusterAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterAuditLogConfig != nil {

		if swag.IsZero(m.ClusterAuditLogConfig) { // not required
			return nil
		}

		if err := m.ClusterAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateDiskCountByTier(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "diskCountByTier", "body", []*CountByTier(m.DiskCountByTier)); err != nil {
		return err
	}

	for i := 0; i < len(m.DiskCountByTier); i++ {

		if m.DiskCountByTier[i] != nil {

			if swag.IsZero(m.DiskCountByTier[i]) { // not required
				return nil
			}

			if err := m.DiskCountByTier[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskCountByTier" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskCountByTier" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateEulaConfig(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *Cluster) contextValidateFilerAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FilerAuditLogConfig != nil {

		if swag.IsZero(m.FilerAuditLogConfig) { // not required
			return nil
		}

		if err := m.FilerAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filerAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filerAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateHardwareInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.HardwareInfo != nil {

		if swag.IsZero(m.HardwareInfo) { // not required
			return nil
		}

		if err := m.HardwareInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hardwareInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hardwareInfo")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateLicenseState(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *Cluster) contextValidateNtpSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.NtpSettings != nil {

		if swag.IsZero(m.NtpSettings) { // not required
			return nil
		}

		if err := m.NtpSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ntpSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ntpSettings")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSchemaInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SchemaInfoList); i++ {

		if m.SchemaInfoList[i] != nil {

			if swag.IsZero(m.SchemaInfoList[i]) { // not required
				return nil
			}

			if err := m.SchemaInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if swag.IsZero(m.Stats) { // not required
			return nil
		}

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSupportedConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.SupportedConfig != nil {

		if swag.IsZero(m.SupportedConfig) { // not required
			return nil
		}

		if err := m.SupportedConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supportedConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("supportedConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateSyslogServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SyslogServers); i++ {

		if m.SyslogServers[i] != nil {

			if swag.IsZero(m.SyslogServers[i]) { // not required
				return nil
			}

			if err := m.SyslogServers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Cluster) contextValidateTieringAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TieringAuditLogConfig != nil {

		if swag.IsZero(m.TieringAuditLogConfig) { // not required
			return nil
		}

		if err := m.TieringAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tieringAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tieringAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
