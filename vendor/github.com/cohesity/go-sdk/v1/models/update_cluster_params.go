// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UpdateClusterParams Update Cluster.
//
// Specifies the configuration settings that can be updated on the
// Cohesity Cluster.
//
// swagger:model UpdateClusterParams
type UpdateClusterParams struct {

	// Specifies the default AES Encryption mode on the cluster.
	AesEncryptionMode *string `json:"aesEncryptionMode,omitempty"`

	// Specifies the AMQP target config.
	AmqpTargetConfig *AMQPTargetConfig `json:"amqpTargetConfig,omitempty"`

	// The subnet for Athena apps.
	AppsSubnet *Subnet `json:"appsSubnet,omitempty"`

	// To attempt agent connection on port 21213 first
	AttemptAgentPortsUpgrade *bool `json:"attemptAgentPortsUpgrade,omitempty"`

	// Specifies whether UI banner is enabled on the cluster or not. When banner
	// is enabled, UI will make an additional API call to fetch the banner and
	// show at the login page.
	BannerEnabled *bool `json:"bannerEnabled,omitempty"`

	// Cluster Audit Log Configuration.
	ClusterAuditLogConfig *ClusterAuditLogConfiguration `json:"clusterAuditLogConfig,omitempty"`

	// Array of IP Addresses of DNS Servers.
	//
	// Specifies the IP addresses of the DNS Servers used by the Cohesity
	// Cluster.
	DNSServerIps []string `json:"dnsServerIps"`

	// Array of Domain Names.
	//
	// The first domain name specified in the array is the fully qualified
	// domain name assigned to the Cohesity Cluster. Any additional
	// domain names specified are used for the domain search list for
	// hostname look-up.
	DomainNames []string `json:"domainNames"`

	// Specifies if Cohesity can receive monitoring information from the
	// Cohesity Cluster.
	// If 'true', remote monitoring of the Cohesity Cluster is allowed.
	EnableActiveMonitoring *bool `json:"enableActiveMonitoring,omitempty"`

	// Specifies whether to enable downloading patches from Cohesity download
	// site.
	EnablePatchesDownload *bool `json:"enablePatchesDownload,omitempty"`

	// If 'true', Cohesity's upgrade server is polled for new releases.
	EnableUpgradePkgPolling *bool `json:"enableUpgradePkgPolling,omitempty"`

	// Specifies the period of time (in seconds) when encryption keys are rotated.
	// By default, the encryption keys are rotated every 77760000 seconds
	// (30 days).
	EncryptionKeyRotationPeriodSecs *int64 `json:"encryptionKeyRotationPeriodSecs,omitempty"`

	// Specifies the level which 'MetadataFaultToleranceFactor' applies to.
	// 'kNode' indicates 'MetadataFaultToleranceFactor' applies to Node level.
	// 'kChassis' indicates 'MetadataFaultToleranceFactor' applies to Chassis
	// level.
	// 'kRack' indicates 'MetadataFaultToleranceFactor' applies to Rack level.
	// Enum: ["kNode","kChassis","kRack"]
	FaultToleranceLevel *string `json:"faultToleranceLevel,omitempty"`

	// Filer Audit Log Configuration.
	FilerAuditLogConfig *FilerAuditLogConfiguration `json:"filerAuditLogConfig,omitempty"`

	// Specifies the gateway IP address.
	Gateway *string `json:"gateway,omitempty"`

	// Specifies whether Google Analytics is enabled.
	GoogleAnalyticsEnabled *bool `json:"googleAnalyticsEnabled,omitempty"`

	// Specifies what version of the documentation is used.
	// If 'true', the version of documentation stored locally on the Cohesity
	// Cluster is used.
	// If 'false', the documentation stored on a Cohesity Web Server
	// is used. The default is 'false'.
	// Cohesity recommends accessing the Help from the Cohesity Web site which
	// provides the newest and most complete version of Help.
	IsDocumentationLocal *bool `json:"isDocumentationLocal,omitempty"`

	// Specifies the KMS Server Id.
	// This can only be set when the encryption is enabled on cluster.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// Specifies the language and locale for this Cohesity Cluster.
	LanguageLocale *string `json:"languageLocale,omitempty"`

	// Domain name for SMB local authentication.
	LocalAuthDomainName *string `json:"localAuthDomainName,omitempty"`

	// Specifies whether to enable local groups on cluster. Once it is enabled,
	// it cannot be disabled.
	LocalGroupsEnabled *bool `json:"localGroupsEnabled,omitempty"`

	// Specifies metadata fault tolerance setting for the cluster. This denotes
	// the number of simultaneous failures[node] supported by metadata services
	// like gandalf and scribe.
	MetadataFaultToleranceFactor *int32 `json:"metadataFaultToleranceFactor,omitempty"`

	// Specifies if multi tenancy is enabled in the cluster. Authentication &
	// Authorization will always use tenant_id, however, some UI elements may be
	// disabled when multi tenancy is disabled.
	MultiTenancyEnabled *bool `json:"multiTenancyEnabled,omitempty"`

	// Specifies the name of the Cohesity Cluster.
	Name *string `json:"name,omitempty"`

	// Specifies if the ntp/primary secondary scheme should be disabled for this
	// cluster.
	NtpSettings *NtpSettingsConfig `json:"ntpSettings,omitempty"`

	// Specifies the rebalance delay in seconds for cluster PcieSSD storage tier.
	PcieSsdTierRebalanceDelaySecs *int32 `json:"pcieSsdTierRebalanceDelaySecs,omitempty"`

	// Specifies if protorpc encryption is enabled or not.
	ProtoRPCEncryptionEnabled *bool `json:"protoRpcEncryptionEnabled,omitempty"`

	// If 'true', Cohesity's Remote Tunnel is enabled.
	// Cohesity can access the Cluster and provide remote assistance
	// via a Remote Tunnel.
	ReverseTunnelEnabled *bool `json:"reverseTunnelEnabled,omitempty"`

	// ReverseTunnelEndTimeMsecs specifies the end time in milliseconds since
	// epoch until when the reverse tunnel will stay enabled.
	ReverseTunnelEndTimeMsecs *int64 `json:"reverseTunnelEndTimeMsecs,omitempty"`

	// Specifies the list of domain names for S3
	// Virtual Hosted Style Paths. If set, all the Cohesity S3 Views in the
	// cluster can be accessed using any of the specified domain names.
	S3VirtualHostedDomainNames []string `json:"s3VirtualHostedDomainNames"`

	// Specifies the admission control for cluster SATAHDD storage tier.
	SataHddTierAdmissionControl *int32 `json:"sataHddTierAdmissionControl,omitempty"`

	// Specifies if Security Mode DOD is enabled or not.
	SecurityModeDod *bool `json:"securityModeDod,omitempty"`

	// Specifies if Active Directory should be disabled for authentication of SMB
	// shares. If 'true', Active Directory is disabled.
	SmbAdDisabled *bool `json:"smbAdDisabled,omitempty"`

	// Specifies whether SMB multichannel is enabled on the cluster. When this is
	// set to true, then any SMB3 multichannel enabled client can establish
	// multiple TCP connection per session to the Server.
	SmbMultichannelEnabled *bool `json:"smbMultichannelEnabled,omitempty"`

	// TODO(mitch) StigMode is deprecated. Should it still be in this list??
	StigMode *bool `json:"stigMode,omitempty"`

	// Syslog servers.
	SyslogServers []*OldSyslogServer `json:"syslogServers"`

	// In case multi tenancy is enabled, this flag controls whether multiple
	// tenants can be placed on the same viewbox. Once set to true, this flag
	// should never become false.
	TenantViewboxSharingEnabled *bool `json:"tenantViewboxSharingEnabled,omitempty"`

	// Tiering Audit Log Configuration.
	TieringAuditLogConfig *TieringAuditLogConfiguration `json:"tieringAuditLogConfig,omitempty"`

	// Specifies the timezone to use for showing time in emails, reports,
	// filer audit logs, etc.
	Timezone *string `json:"timezone,omitempty"`

	// Specifies if the TLS is enabled on the remote cluster.
	TLSEnabled *bool `json:"tlsEnabled,omitempty"`

	// Specifies if the cluster is in Turbo mode.
	TurboMode *bool `json:"turboMode,omitempty"`

	// To use default ports 50051 & 21213
	UseDefaultAgentPorts *bool `json:"useDefaultAgentPorts,omitempty"`

	// Specifies whether to enable Heimdall which tells whether services should
	// use temporary fleet instances to mount disks by talking to Heimdall.
	UseHeimdall *bool `json:"useHeimdall,omitempty"`
}

// Validate validates this update cluster params
func (m *UpdateClusterParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmqpTargetConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppsSubnet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFaultToleranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilerAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNtpSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyslogServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTieringAuditLogConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateClusterParams) validateAmqpTargetConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AmqpTargetConfig) { // not required
		return nil
	}

	if m.AmqpTargetConfig != nil {
		if err := m.AmqpTargetConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amqpTargetConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amqpTargetConfig")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) validateAppsSubnet(formats strfmt.Registry) error {
	if swag.IsZero(m.AppsSubnet) { // not required
		return nil
	}

	if m.AppsSubnet != nil {
		if err := m.AppsSubnet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appsSubnet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appsSubnet")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) validateClusterAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterAuditLogConfig) { // not required
		return nil
	}

	if m.ClusterAuditLogConfig != nil {
		if err := m.ClusterAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

var updateClusterParamsTypeFaultToleranceLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNode","kChassis","kRack"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		updateClusterParamsTypeFaultToleranceLevelPropEnum = append(updateClusterParamsTypeFaultToleranceLevelPropEnum, v)
	}
}

const (

	// UpdateClusterParamsFaultToleranceLevelKNode captures enum value "kNode"
	UpdateClusterParamsFaultToleranceLevelKNode string = "kNode"

	// UpdateClusterParamsFaultToleranceLevelKChassis captures enum value "kChassis"
	UpdateClusterParamsFaultToleranceLevelKChassis string = "kChassis"

	// UpdateClusterParamsFaultToleranceLevelKRack captures enum value "kRack"
	UpdateClusterParamsFaultToleranceLevelKRack string = "kRack"
)

// prop value enum
func (m *UpdateClusterParams) validateFaultToleranceLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, updateClusterParamsTypeFaultToleranceLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UpdateClusterParams) validateFaultToleranceLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.FaultToleranceLevel) { // not required
		return nil
	}

	// value enum
	if err := m.validateFaultToleranceLevelEnum("faultToleranceLevel", "body", *m.FaultToleranceLevel); err != nil {
		return err
	}

	return nil
}

func (m *UpdateClusterParams) validateFilerAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FilerAuditLogConfig) { // not required
		return nil
	}

	if m.FilerAuditLogConfig != nil {
		if err := m.FilerAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filerAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filerAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) validateNtpSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.NtpSettings) { // not required
		return nil
	}

	if m.NtpSettings != nil {
		if err := m.NtpSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ntpSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ntpSettings")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) validateSyslogServers(formats strfmt.Registry) error {
	if swag.IsZero(m.SyslogServers) { // not required
		return nil
	}

	for i := 0; i < len(m.SyslogServers); i++ {
		if swag.IsZero(m.SyslogServers[i]) { // not required
			continue
		}

		if m.SyslogServers[i] != nil {
			if err := m.SyslogServers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateClusterParams) validateTieringAuditLogConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.TieringAuditLogConfig) { // not required
		return nil
	}

	if m.TieringAuditLogConfig != nil {
		if err := m.TieringAuditLogConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tieringAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tieringAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this update cluster params based on the context it is used
func (m *UpdateClusterParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmqpTargetConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAppsSubnet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilerAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNtpSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSyslogServers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTieringAuditLogConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateClusterParams) contextValidateAmqpTargetConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AmqpTargetConfig != nil {

		if swag.IsZero(m.AmqpTargetConfig) { // not required
			return nil
		}

		if err := m.AmqpTargetConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("amqpTargetConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("amqpTargetConfig")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) contextValidateAppsSubnet(ctx context.Context, formats strfmt.Registry) error {

	if m.AppsSubnet != nil {

		if swag.IsZero(m.AppsSubnet) { // not required
			return nil
		}

		if err := m.AppsSubnet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appsSubnet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appsSubnet")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) contextValidateClusterAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterAuditLogConfig != nil {

		if swag.IsZero(m.ClusterAuditLogConfig) { // not required
			return nil
		}

		if err := m.ClusterAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) contextValidateFilerAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FilerAuditLogConfig != nil {

		if swag.IsZero(m.FilerAuditLogConfig) { // not required
			return nil
		}

		if err := m.FilerAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filerAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filerAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) contextValidateNtpSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.NtpSettings != nil {

		if swag.IsZero(m.NtpSettings) { // not required
			return nil
		}

		if err := m.NtpSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ntpSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ntpSettings")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateClusterParams) contextValidateSyslogServers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SyslogServers); i++ {

		if m.SyslogServers[i] != nil {

			if swag.IsZero(m.SyslogServers[i]) { // not required
				return nil
			}

			if err := m.SyslogServers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("syslogServers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UpdateClusterParams) contextValidateTieringAuditLogConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.TieringAuditLogConfig != nil {

		if swag.IsZero(m.TieringAuditLogConfig) { // not required
			return nil
		}

		if err := m.TieringAuditLogConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tieringAuditLogConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tieringAuditLogConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdateClusterParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateClusterParams) UnmarshalBinary(b []byte) error {
	var res UpdateClusterParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
