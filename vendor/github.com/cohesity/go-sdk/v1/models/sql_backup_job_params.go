// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// SQLBackupJobParams SQL Backup Job Parameters.
//
// Message to capture additional backup job params specific to SQL.
//
// swagger:model SqlBackupJobParams
type SQLBackupJobParams struct {

	// Preference type for backing up databases that are part of an AAG.
	// Only applicable if 'use_aag_preferences_from_sql_server' is set to false.
	AagBackupPreferenceType *int32 `json:"aagBackupPreferenceType,omitempty"`

	// This is used to regulate certain gflag values from the UI. The values
	// passed by the user from the UI will be used for the respective gflags.
	AdvancedSettings *AdvancedSettings `json:"advancedSettings,omitempty"`

	// If set to true, only the volumes associated with databases should be
	// backed up. The user cannot select additional volumes at host level for
	// backup.
	//
	// If set to false, all the volumes on the host machine will be backed up.
	// In this case, the user can further select the exact set of volumes
	// using host level params.
	//
	// Note that the volumes associated with selected databases will always be
	// included in the backup.
	BackupDatabaseVolumesOnly *bool `json:"backupDatabaseVolumesOnly,omitempty"`

	// Set to true if system databases should be backed up.
	BackupSystemDbs *bool `json:"backupSystemDbs,omitempty"`

	// Whether backup should continue after encountering a page checksum error.
	ContinueAfterError *bool `json:"continueAfterError,omitempty"`

	// Whether backup checksums are enabled.
	EnableChecksum *bool `json:"enableChecksum,omitempty"`

	// If this is set to true, then incremental backup will be performed
	// after the server restarts, otherwise a full-backup will be done.
	EnableIncrementalBackupAfterRestart *bool `json:"enableIncrementalBackupAfterRestart,omitempty"`

	// The type of SQL full backup to be used for this job.
	FullBackupType *int32 `json:"fullBackupType,omitempty"`

	// Whether full backups should be copy-only.
	IsCopyOnlyFull *bool `json:"isCopyOnlyFull,omitempty"`

	// Whether log backups should be copy-only.
	IsCopyOnlyLog *bool `json:"isCopyOnlyLog,omitempty"`

	// The number of streams to be used for log backups in native sql backup
	// command. This is only applicable for native sql log backups. If this is
	// not specified, we use the value specified in
	// magneto_sql_num_streams_for_each_db_backup gflag.
	LogBackupNumStreams *int32 `json:"logBackupNumStreams,omitempty"`

	// 'with_clause' contains 'with clause' to be used for log backups in native
	// sql backup command. This is only applicable for native sql log backup.
	// Here user can specify multiple backup options. Example: "WITH BUFFERCOUNT
	// = 575, MAXTRANSFERSIZE = 2097152". If this is not specified, we use
	// the value specified in magneto_sql_native_backup_with_clause gflag.
	LogBackupWithClause *string `json:"logBackupWithClause,omitempty"`

	// The number of databases to be backed up per batch. This is only applicable
	// for file based sql backup. If this is not specified, we use the value
	// specified in magneto_vss_sql_app_file_batch_size gflag.
	NumDbsPerBatch *int32 `json:"numDbsPerBatch,omitempty"`

	// The number of streams to be used in native sql backup command. This is
	// only applicable for native sql backup. If this is not specified, we use
	// the value specified in magneto_sql_num_streams_for_each_db_backup gflag.
	NumStreams *int32 `json:"numStreams,omitempty"`

	// Set to true if we should use AAG preferences specified at the SQL server
	// host.
	UseAagPreferencesFromSQLServer *bool `json:"useAagPreferencesFromSqlServer,omitempty"`

	// Preference type for backing up user databases on the host.
	UserDbPreferenceType *int32 `json:"userDbPreferenceType,omitempty"`

	// 'with_clause' contains 'with clause' to be used in native sql backup
	// command. This is only applicable for native sql backup. Here user can
	// specify multiple backup options. Example: "WITH BUFFERCOUNT = 575,
	// MAXTRANSFERSIZE = 2097152". If this is not specified, we use the value
	// specified in magneto_sql_native_backup_with_clause gflag.
	WithClause *string `json:"withClause,omitempty"`
}

// Validate validates this Sql backup job params
func (m *SQLBackupJobParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdvancedSettings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLBackupJobParams) validateAdvancedSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.AdvancedSettings) { // not required
		return nil
	}

	if m.AdvancedSettings != nil {
		if err := m.AdvancedSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advancedSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advancedSettings")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this Sql backup job params based on the context it is used
func (m *SQLBackupJobParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdvancedSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLBackupJobParams) contextValidateAdvancedSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.AdvancedSettings != nil {

		if swag.IsZero(m.AdvancedSettings) { // not required
			return nil
		}

		if err := m.AdvancedSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("advancedSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("advancedSettings")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLBackupJobParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLBackupJobParams) UnmarshalBinary(b []byte) error {
	var res SQLBackupJobParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
