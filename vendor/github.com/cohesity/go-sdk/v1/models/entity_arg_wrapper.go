// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// EntityArgWrapper EntityArgWrapper is a wrapper for protobuf args needed by create, update and
// delete operations on backup sources.
//
// swagger:model EntityArgWrapper
type EntityArgWrapper struct {

	// Specifies the Bifrost realm to be associated with the source root.
	// Whenever needed, the workflows related to this source would then
	// only use Bifrosts from the specified realm.
	ConnectionID *int64 `json:"connectionId,omitempty"`

	// This helps to set the exchange dag backup preference.
	DagBackupPreference *ExchangeDAGBackupPreference `json:"dagBackupPreference,omitempty"`

	// If set, user has encrypted the credential with ecryption key.
	// It is assumed that credentials are first encrypted using
	// internal magento key and then encrypted using encryption key.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// Entity specifies the backup source to be updated (for update and delete
	// operations only).
	Entity *PrivateEntityProto `json:"entity,omitempty"`

	// EntityAccessInfo specifies the access info for the backup source.
	// Only needed for create and update operations.
	EntityInfo *EntityAccessInfo `json:"entityInfo,omitempty"`

	// ForceRegister is applicable to Physical Environment. By default, the agent
	// running on a physical host will fail the registration, if it is already
	// registered as part of another cluster. By setting this option to true,
	// agent can be forced to register with the current cluster. This is a hidden
	// parameter and should not be documented externally.
	ForceRegister *bool `json:"forceRegister,omitempty"`

	// Set to true if credentials are encrypted by internal magneto key.
	IsInternalEncrypted *bool `json:"isInternalEncrypted,omitempty"`

	// This is applicable only for physical hosts. This indicates the physical
	// host will be used as proxy host.
	IsProxyHost *bool `json:"isProxyHost,omitempty"`

	// Specifies the last time this source was updated.  If this is
	// passed into a PUT request, then the backend will validate that the
	// timestamp passed in matches the time that the source was
	// actually last modified. If the two timestamps do not match, then the
	// request will be rejected with a stale error.
	LastModificationTimeUsecs *int64 `json:"lastModificationTimeUsecs,omitempty"`

	// ReRegister is applicable to Physical Environment. By default, the
	// agent running on a physical host will fail the registration, if it is
	// already registered with the cluster. By setting this option to true, agent
	// can be re-registered with the current cluster.
	ReRegister *bool `json:"reRegister,omitempty"`

	// RegisteredEntityParams contains all params specified by the user while
	// registering the entity.
	RegisteredEntityParams *RegisteredEntityParams `json:"registeredEntityParams,omitempty"`

	// RestoreConfig is applicable to Physical Environment. The ReRegister option
	// needs to be true if RestoreConfig is true. By setting this option to true,
	// the agent configuration can be restored.
	RestoreConfig *bool `json:"restoreConfig,omitempty"`

	// RetryEntityRegistration will force to retry a physical host registration.
	RetryEntityRegistration *bool `json:"retryEntityRegistration,omitempty"`

	// This controls whether to use source side dedup on the source or not.
	// This is only applicable to sources which support source side dedup
	// (e.g., Linux physical servers).
	SourceSideDedupEnabled *bool `json:"sourceSideDedupEnabled,omitempty"`

	// ThrottlingPolicy is the throttling policy that should be applied to the
	// entity when pulling data from the primary storage.
	ThrottlingPolicy *ThrottlingPolicy `json:"throttlingPolicy,omitempty"`

	// This option is available only for VMWare VM entities. It indicates that
	// persistent agent is available on the VM.
	VMUsesPersistentAgent *bool `json:"vmUsesPersistentAgent,omitempty"`
}

// Validate validates this entity arg wrapper
func (m *EntityArgWrapper) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDagBackupPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredEntityParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThrottlingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EntityArgWrapper) validateDagBackupPreference(formats strfmt.Registry) error {
	if swag.IsZero(m.DagBackupPreference) { // not required
		return nil
	}

	if m.DagBackupPreference != nil {
		if err := m.DagBackupPreference.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dagBackupPreference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dagBackupPreference")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) validateEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.Entity) { // not required
		return nil
	}

	if m.Entity != nil {
		if err := m.Entity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entity")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) validateEntityInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityInfo) { // not required
		return nil
	}

	if m.EntityInfo != nil {
		if err := m.EntityInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entityInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entityInfo")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) validateRegisteredEntityParams(formats strfmt.Registry) error {
	if swag.IsZero(m.RegisteredEntityParams) { // not required
		return nil
	}

	if m.RegisteredEntityParams != nil {
		if err := m.RegisteredEntityParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registeredEntityParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registeredEntityParams")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) validateThrottlingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ThrottlingPolicy) { // not required
		return nil
	}

	if m.ThrottlingPolicy != nil {
		if err := m.ThrottlingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingPolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this entity arg wrapper based on the context it is used
func (m *EntityArgWrapper) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDagBackupPreference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntityInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegisteredEntityParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThrottlingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EntityArgWrapper) contextValidateDagBackupPreference(ctx context.Context, formats strfmt.Registry) error {

	if m.DagBackupPreference != nil {

		if swag.IsZero(m.DagBackupPreference) { // not required
			return nil
		}

		if err := m.DagBackupPreference.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dagBackupPreference")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dagBackupPreference")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) contextValidateEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.Entity != nil {

		if swag.IsZero(m.Entity) { // not required
			return nil
		}

		if err := m.Entity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entity")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) contextValidateEntityInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.EntityInfo != nil {

		if swag.IsZero(m.EntityInfo) { // not required
			return nil
		}

		if err := m.EntityInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entityInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entityInfo")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) contextValidateRegisteredEntityParams(ctx context.Context, formats strfmt.Registry) error {

	if m.RegisteredEntityParams != nil {

		if swag.IsZero(m.RegisteredEntityParams) { // not required
			return nil
		}

		if err := m.RegisteredEntityParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registeredEntityParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registeredEntityParams")
			}
			return err
		}
	}

	return nil
}

func (m *EntityArgWrapper) contextValidateThrottlingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.ThrottlingPolicy != nil {

		if swag.IsZero(m.ThrottlingPolicy) { // not required
			return nil
		}

		if err := m.ThrottlingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EntityArgWrapper) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EntityArgWrapper) UnmarshalBinary(b []byte) error {
	var res EntityArgWrapper
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
