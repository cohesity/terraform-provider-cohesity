// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ServiceGflags Service Gflags.
//
// Specifies the gflags for a service.
//
// swagger:model ServiceGflags
type ServiceGflags struct {

	// Specifies a list of gflags for this service.
	Gflags []*Gflag `json:"gflags"`

	// Specifies the name of the service.
	// 'kApollo' is a service for reclaiming freed disk sectors on Nodes in the
	// SnapFS distributed file system.
	// 'kBridge' is a service for managing the SnapFS distributed file system.
	// 'kGenie' is a service that is responsible for monitoring hardware health
	// on the Cluster.
	// 'kGenieGofer' is a service that links the Genie service to other services
	// on the Cluster.
	// 'kMagneto' is the data protection service of the Cohesity Data Platform.
	// 'kIris' is the service which serves REST API calls to the UI, CLI, and any
	// scripts written by customers.
	// 'kIrisProxy' is a service that links the Iris service to other services
	// on the Cluster.
	// 'kScribe' is the service responsible for storing filesystem metadata.
	// 'kStats' is the service that is responsible for retrieving and aggregating
	// disk metrics across the Cluster.
	// 'kYoda' is an elastic search indexing service.
	// 'kAlerts' is a publisher and subscribing service for alerts.
	// 'kKeychain' is a service for managing disk encryption keys.
	// 'kLogWatcher' is a service that scans the log directory and reduces
	// the number of logs if required.
	// 'kStatsCollector' is a service that periodically logs system stats.
	// 'kGandalf' is a distributed lock service and coordination manager.
	// 'kNexus' indicates the Nexus service. This is the service that is
	// responsible for creation of Clusters and configuration of Nodes and
	// networking.
	// 'kNexusProxy' is a service that links the Nexus service to other services
	// on the Cluster.
	// 'kStorageProxy' is a service for accessing data on external entities.
	// 'kRtClient' is a reverse tunneling client service.
	// 'kVaultProxy' is a service for managing external targets that Clusters
	// can be backed up to.
	// 'kSmbProxy' is an SMB protocol service.
	// 'kBridgeProxy' is the service that links the Bridge service to other
	// services on the Cluster.
	// 'kLibrarian' is an elastic search indexing service.
	// 'kGroot' is a service for managing replication of SQL databases across
	// multiple nodes in a Cluster.
	// 'kEagleAgent' is a service that is responsible for retrieving information
	// on Cluster health.
	// 'kAthena' is a service for running distributed containerized applications
	// on the Cohesity Data Platform.
	// 'kBifrostBroker' is a service for communicating with the Cohesity proxies
	// for multitenancy.
	// 'kSmb2Proxy' is a new SMB protocol service.
	// 'kOs' can be specified in order to do a full reboot.
	// 'kAtom' is a service for receiving data for the Continuous Data Protection.
	// 'kPatch' is a service for downloading and applying patches.
	// 'kCompass' is a service for serving dns request for external and internal
	// traffic.
	// 'kEtlServer' is a service responsible for ETling data for globalsearch.
	// 'kIcebox' is service that links Icebox service to other services on cluster.
	// kScribe, kStats, kYoda, kAlerts, kKeychain, kLogWatcher, kStatsCollecter,
	// kGandalf, kNexus, kNexusProxy, kStorageProxy, kRtClient, kVaultProxy,
	// kSmbProxy, kBridgeProxy, kLibrarian, kGroot, kEagleAgent, kAthena,
	// kBifrostBroker, kSmb2Proxy, kOs, kAtom, kIcebox
	// Enum: ["kApollo","kBridge","kGenie","kGenieGofer","kMagneto","kIris","kIrisProxy"]
	ServiceName *string `json:"serviceName,omitempty"`
}

// Validate validates this service gflags
func (m *ServiceGflags) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGflags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServiceGflags) validateGflags(formats strfmt.Registry) error {
	if swag.IsZero(m.Gflags) { // not required
		return nil
	}

	for i := 0; i < len(m.Gflags); i++ {
		if swag.IsZero(m.Gflags[i]) { // not required
			continue
		}

		if m.Gflags[i] != nil {
			if err := m.Gflags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gflags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("gflags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var serviceGflagsTypeServiceNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kApollo","kBridge","kGenie","kGenieGofer","kMagneto","kIris","kIrisProxy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serviceGflagsTypeServiceNamePropEnum = append(serviceGflagsTypeServiceNamePropEnum, v)
	}
}

const (

	// ServiceGflagsServiceNameKApollo captures enum value "kApollo"
	ServiceGflagsServiceNameKApollo string = "kApollo"

	// ServiceGflagsServiceNameKBridge captures enum value "kBridge"
	ServiceGflagsServiceNameKBridge string = "kBridge"

	// ServiceGflagsServiceNameKGenie captures enum value "kGenie"
	ServiceGflagsServiceNameKGenie string = "kGenie"

	// ServiceGflagsServiceNameKGenieGofer captures enum value "kGenieGofer"
	ServiceGflagsServiceNameKGenieGofer string = "kGenieGofer"

	// ServiceGflagsServiceNameKMagneto captures enum value "kMagneto"
	ServiceGflagsServiceNameKMagneto string = "kMagneto"

	// ServiceGflagsServiceNameKIris captures enum value "kIris"
	ServiceGflagsServiceNameKIris string = "kIris"

	// ServiceGflagsServiceNameKIrisProxy captures enum value "kIrisProxy"
	ServiceGflagsServiceNameKIrisProxy string = "kIrisProxy"
)

// prop value enum
func (m *ServiceGflags) validateServiceNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serviceGflagsTypeServiceNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServiceGflags) validateServiceName(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceName) { // not required
		return nil
	}

	// value enum
	if err := m.validateServiceNameEnum("serviceName", "body", *m.ServiceName); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this service gflags based on the context it is used
func (m *ServiceGflags) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGflags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServiceGflags) contextValidateGflags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Gflags); i++ {

		if m.Gflags[i] != nil {

			if swag.IsZero(m.Gflags[i]) { // not required
				return nil
			}

			if err := m.Gflags[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gflags" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("gflags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ServiceGflags) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServiceGflags) UnmarshalBinary(b []byte) error {
	var res ServiceGflags
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
