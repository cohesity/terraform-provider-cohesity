// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ArchivalInfoBase archival info base
//
// swagger:model ArchivalInfoBase
type ArchivalInfoBase struct {

	// WORM related properties for this archive.
	ArchiveWormProperties *ArchiveWORMProperties `json:"archiveWormProperties,omitempty"`

	// Average logical bytes transfer rate in bytes per second as seen by Icebox.
	AvgLogicalTransferRateBps *int64 `json:"avgLogicalTransferRateBps,omitempty"`

	// Number of physical bytes transferred for this archival so far. This takes
	// into account compression/padding and encryption (if any). If an archive
	// task is cancelled, this and above 'logical_bytes_transferred' field will
	// contain the number of bytes transferred when cancellation was issued to
	// Icebox. Actual cancellation of the archive task is performed
	// asynchronously in the background by Icebox. While task is being cancelled,
	// Icebox might have transferred more data to the archive target. So this
	// below field may not accurately represent the total bytes transferred.
	BytesTransferred *int64 `json:"bytesTransferred,omitempty"`

	// Folder of the cloud domain the snapshot resides in, if this is a
	// cloud domain format archive.
	CloudDomainFolder *string `json:"cloudDomainFolder,omitempty"`

	// Time when this archival ended. If not set, then the archival has not ended
	// yet.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Mapping from global hash string id of protected entity to front end size
	// info calculated by icebox during archival. Currently it only applies to
	// object protection archive in DMaaS.
	EntityStringIDToFrontEndSizeInfoMap map[string]SizeInfo `json:"entityStringIdToFrontEndSizeInfoMap,omitempty"`

	// If the archival has completed, the following indicates whether there was
	// an error in its completion.
	Error *PrivateErrorProto `json:"error,omitempty"`

	// Set to true if this is a CAD archive in the cloud domain format.
	IsCadArchive *bool `json:"isCadArchive,omitempty"`

	// Whether this is a cloud domain archive.
	IsCloudDomainArchive *bool `json:"isCloudDomainArchive,omitempty"`

	// Whether this is an incremental archive. If set to true, this is an
	// incremental archive, otherwise this is a full archive.
	IsIncrementalArchive *bool `json:"isIncrementalArchive,omitempty"`

	// Number of logical bytes transferred for this archival so far. This
	// value can never exceed the value of the above field 'logical_size_bytes'.
	LogicalBytesTransferred *int64 `json:"logicalBytesTransferred,omitempty"`

	// Total logical size of the archive, before compression and encryption.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// If the copy task that this ArchivalInfoBase is a part of was created to
	// only extend the expiration time of a previous successful archive task,
	// this field will contain the UID of that previous archive task.
	OriginalTaskUID *UniversalIDProto `json:"originalTaskUid,omitempty"`

	// The root path of the progress monitor for this task.
	ProgressMonitorTaskPath *string `json:"progressMonitorTaskPath,omitempty"`

	// Time when this archival was started. If not set, then archival has not
	// been started yet.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Message to display in the UI if any manual intervention is needed to make
	// forward progress for the archival task. This message is mainly relevant
	// for tape based archival tasks where a backup admin might be asked to load
	// new media when the tape library does not have any more media to use.
	UserActionRequiredMsg *string `json:"userActionRequiredMsg,omitempty"`
}

// Validate validates this archival info base
func (m *ArchivalInfoBase) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArchiveWormProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityStringIDToFrontEndSizeInfoMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalTaskUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ArchivalInfoBase) validateArchiveWormProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchiveWormProperties) { // not required
		return nil
	}

	if m.ArchiveWormProperties != nil {
		if err := m.ArchiveWormProperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveWormProperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archiveWormProperties")
			}
			return err
		}
	}

	return nil
}

func (m *ArchivalInfoBase) validateEntityStringIDToFrontEndSizeInfoMap(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityStringIDToFrontEndSizeInfoMap) { // not required
		return nil
	}

	for k := range m.EntityStringIDToFrontEndSizeInfoMap {

		if err := validate.Required("entityStringIdToFrontEndSizeInfoMap"+"."+k, "body", m.EntityStringIDToFrontEndSizeInfoMap[k]); err != nil {
			return err
		}
		if val, ok := m.EntityStringIDToFrontEndSizeInfoMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("entityStringIdToFrontEndSizeInfoMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("entityStringIdToFrontEndSizeInfoMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *ArchivalInfoBase) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *ArchivalInfoBase) validateOriginalTaskUID(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginalTaskUID) { // not required
		return nil
	}

	if m.OriginalTaskUID != nil {
		if err := m.OriginalTaskUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originalTaskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("originalTaskUid")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this archival info base based on the context it is used
func (m *ArchivalInfoBase) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateArchiveWormProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntityStringIDToFrontEndSizeInfoMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginalTaskUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ArchivalInfoBase) contextValidateArchiveWormProperties(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchiveWormProperties != nil {

		if swag.IsZero(m.ArchiveWormProperties) { // not required
			return nil
		}

		if err := m.ArchiveWormProperties.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveWormProperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archiveWormProperties")
			}
			return err
		}
	}

	return nil
}

func (m *ArchivalInfoBase) contextValidateEntityStringIDToFrontEndSizeInfoMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.EntityStringIDToFrontEndSizeInfoMap {

		if val, ok := m.EntityStringIDToFrontEndSizeInfoMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ArchivalInfoBase) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {

		if swag.IsZero(m.Error) { // not required
			return nil
		}

		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *ArchivalInfoBase) contextValidateOriginalTaskUID(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginalTaskUID != nil {

		if swag.IsZero(m.OriginalTaskUID) { // not required
			return nil
		}

		if err := m.OriginalTaskUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originalTaskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("originalTaskUid")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ArchivalInfoBase) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ArchivalInfoBase) UnmarshalBinary(b []byte) error {
	var res ArchivalInfoBase
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
