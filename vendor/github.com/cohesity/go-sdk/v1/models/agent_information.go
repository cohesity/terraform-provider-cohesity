// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AgentInformation Agent Information.
//
// Specifies information about the Agent software running on the server or
// the Virtual Machine.
//
// swagger:model AgentInformation
type AgentInformation struct {

	// Specifies the version if Cristie BMR product is installed on the host.
	CbmrVersion *string `json:"cbmrVersion,omitempty"`

	// Specifies the status of FileCbt driver associated with the agent.
	FileCbtInfo *CbtInfo `json:"fileCbtInfo,omitempty"`

	// Specifies the host type where the agent is running. This is only set for
	// persistent agents.
	// 'kLinux' indicates the Linux operating system.
	// 'kWindows' indicates the Microsoft Windows operating system.
	// 'kAix' indicates the IBM AIX operating system.
	// 'kSolaris' indicates the Oracle Solaris operating system.
	// 'kSapHana' indicates the Sap Hana database system developed by SAP SE.
	// 'kSapOracle' indicates the Sap Oracle database system developed by SAP SE.
	// 'kCockroachDB' indicates the CockroachDB database system.
	// 'kMySQL' indicates the MySQL database system.
	// 'kSapSybase' indicates the SapSybase database system.
	// 'kSapMaxDB' indicates the SapMaxDB database system.
	// 'kSapSybaseIQ' indicates the SapSybaseIQ database system.
	// 'kDB2' indicates the DB2 database system.
	// 'kSapASE' indicates the SapASE database system.
	// 'kMariaDB' indicates the MariaDB database system.
	// 'kPostgreSQL' indicates the PostgreSQL database system.
	// 'kHPUX' indicates the HPUX database system.
	// 'kVOS' indicates the VOS database system.
	// 'kOther' indicates the other types of operating system.
	// Enum: ["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]
	HostType *string `json:"hostType,omitempty"`

	// Specifies the agent's id.
	ID *int64 `json:"id,omitempty"`

	// Specifies the agent's name.
	Name *string `json:"name,omitempty"`

	// Specifies whether oracle multi node multi channel is supported or not.
	OracleMultiNodeChannelSupported *bool `json:"oracleMultiNodeChannelSupported,omitempty"`

	// Specifies registration information for an Agent.
	RegistrationInfo *RegisteredSourceInfo `json:"registrationInfo,omitempty"`

	// Specifies whether source side dedup is enabled or not.
	SourceSideDedupEnabled *bool `json:"sourceSideDedupEnabled,omitempty"`

	// Specifies the agent status.
	// Specifies the status of the agent running on a physical source.
	// 'kUnknown' indicates the Agent is not known. No attempt to connect
	// to the Agent has occurred.
	// 'kUnreachable' indicates the Agent is not reachable.
	// 'kHealthy' indicates the Agent is healthy.
	// 'kDegraded' indicates the Agent is running but in a degraded state.
	// Enum: ["kUnknown","kUnreachable","kHealthy","kDegraded"]
	Status *string `json:"status,omitempty"`

	// Specifies additional details about the agent status.
	StatusMessage *string `json:"statusMessage,omitempty"`

	// Specifies the upgradability of the agent running on the physical server.
	// Specifies the upgradability of the agent running on the physical server.
	// 'kUpgradable' indicates the Agent can be upgraded to the agent software
	// version on the cluster.
	// 'kCurrent' indicates the Agent is running the latest version.
	// 'kUnknown' indicates the Agent's version is not known.
	// 'kNonUpgradableInvalidVersion' indicates the Agent's version is invalid.
	// 'kNonUpgradableAgentIsNewer' indicates the Agent's version is newer than
	// the agent software version the cluster.
	// 'kNonUpgradableAgentIsOld' indicates the Agent's version is too old that
	// does not support upgrades.
	// Enum: ["kUpgradable","kCurrent","kUnknown","kNonUpgradableInvalidVersion","kNonUpgradableAgentIsNewer","kNonUpgradableAgentIsOld"]
	Upgradability *string `json:"upgradability,omitempty"`

	// Specifies the status of the upgrade of the agent on a physical server.
	// Specifies the status of the upgrade of the agent on a physical server.
	// 'kIdle' indicates there is no agent upgrade in progress.
	// 'kAccepted' indicates the Agent upgrade is accepted.
	// 'kStarted' indicates the Agent upgrade is in progress.
	// 'kFinished' indicates the Agent upgrade is completed.
	// 'kScheduled' indicates that the Agent is scheduled for upgrade.
	// Enum: ["kIdle","kAccepted","kStarted","kFinished","kScheduled"]
	UpgradeStatus *string `json:"upgradeStatus,omitempty"`

	// Specifies detailed message about the agent upgrade failure. This field
	// is not set for successful upgrade.
	UpgradeStatusMessage *string `json:"upgradeStatusMessage,omitempty"`

	// Specifies the version of the Agent software.
	Version *string `json:"version,omitempty"`

	// Specifies the status of VolCbt driver associated with the agent.
	VolCbtInfo *CbtInfo `json:"volCbtInfo,omitempty"`
}

// Validate validates this agent information
func (m *AgentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFileCbtInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegistrationInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpgradability(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpgradeStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolCbtInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AgentInformation) validateFileCbtInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.FileCbtInfo) { // not required
		return nil
	}

	if m.FileCbtInfo != nil {
		if err := m.FileCbtInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileCbtInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileCbtInfo")
			}
			return err
		}
	}

	return nil
}

var agentInformationTypeHostTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		agentInformationTypeHostTypePropEnum = append(agentInformationTypeHostTypePropEnum, v)
	}
}

const (

	// AgentInformationHostTypeKLinux captures enum value "kLinux"
	AgentInformationHostTypeKLinux string = "kLinux"

	// AgentInformationHostTypeKWindows captures enum value "kWindows"
	AgentInformationHostTypeKWindows string = "kWindows"

	// AgentInformationHostTypeKAix captures enum value "kAix"
	AgentInformationHostTypeKAix string = "kAix"

	// AgentInformationHostTypeKSolaris captures enum value "kSolaris"
	AgentInformationHostTypeKSolaris string = "kSolaris"

	// AgentInformationHostTypeKSapHana captures enum value "kSapHana"
	AgentInformationHostTypeKSapHana string = "kSapHana"

	// AgentInformationHostTypeKSapOracle captures enum value "kSapOracle"
	AgentInformationHostTypeKSapOracle string = "kSapOracle"

	// AgentInformationHostTypeKCockroachDB captures enum value "kCockroachDB"
	AgentInformationHostTypeKCockroachDB string = "kCockroachDB"

	// AgentInformationHostTypeKMySQL captures enum value "kMySQL"
	AgentInformationHostTypeKMySQL string = "kMySQL"

	// AgentInformationHostTypeKOther captures enum value "kOther"
	AgentInformationHostTypeKOther string = "kOther"

	// AgentInformationHostTypeKSapSybase captures enum value "kSapSybase"
	AgentInformationHostTypeKSapSybase string = "kSapSybase"

	// AgentInformationHostTypeKSapMaxDB captures enum value "kSapMaxDB"
	AgentInformationHostTypeKSapMaxDB string = "kSapMaxDB"

	// AgentInformationHostTypeKSapSybaseIQ captures enum value "kSapSybaseIQ"
	AgentInformationHostTypeKSapSybaseIQ string = "kSapSybaseIQ"

	// AgentInformationHostTypeKDB2 captures enum value "kDB2"
	AgentInformationHostTypeKDB2 string = "kDB2"

	// AgentInformationHostTypeKSapASE captures enum value "kSapASE"
	AgentInformationHostTypeKSapASE string = "kSapASE"

	// AgentInformationHostTypeKMariaDB captures enum value "kMariaDB"
	AgentInformationHostTypeKMariaDB string = "kMariaDB"

	// AgentInformationHostTypeKPostgreSQL captures enum value "kPostgreSQL"
	AgentInformationHostTypeKPostgreSQL string = "kPostgreSQL"

	// AgentInformationHostTypeKVOS captures enum value "kVOS"
	AgentInformationHostTypeKVOS string = "kVOS"

	// AgentInformationHostTypeKHPUX captures enum value "kHPUX"
	AgentInformationHostTypeKHPUX string = "kHPUX"
)

// prop value enum
func (m *AgentInformation) validateHostTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, agentInformationTypeHostTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AgentInformation) validateHostType(formats strfmt.Registry) error {
	if swag.IsZero(m.HostType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHostTypeEnum("hostType", "body", *m.HostType); err != nil {
		return err
	}

	return nil
}

func (m *AgentInformation) validateRegistrationInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.RegistrationInfo) { // not required
		return nil
	}

	if m.RegistrationInfo != nil {
		if err := m.RegistrationInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registrationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registrationInfo")
			}
			return err
		}
	}

	return nil
}

var agentInformationTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUnknown","kUnreachable","kHealthy","kDegraded"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		agentInformationTypeStatusPropEnum = append(agentInformationTypeStatusPropEnum, v)
	}
}

const (

	// AgentInformationStatusKUnknown captures enum value "kUnknown"
	AgentInformationStatusKUnknown string = "kUnknown"

	// AgentInformationStatusKUnreachable captures enum value "kUnreachable"
	AgentInformationStatusKUnreachable string = "kUnreachable"

	// AgentInformationStatusKHealthy captures enum value "kHealthy"
	AgentInformationStatusKHealthy string = "kHealthy"

	// AgentInformationStatusKDegraded captures enum value "kDegraded"
	AgentInformationStatusKDegraded string = "kDegraded"
)

// prop value enum
func (m *AgentInformation) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, agentInformationTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AgentInformation) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

var agentInformationTypeUpgradabilityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUpgradable","kCurrent","kUnknown","kNonUpgradableInvalidVersion","kNonUpgradableAgentIsNewer","kNonUpgradableAgentIsOld"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		agentInformationTypeUpgradabilityPropEnum = append(agentInformationTypeUpgradabilityPropEnum, v)
	}
}

const (

	// AgentInformationUpgradabilityKUpgradable captures enum value "kUpgradable"
	AgentInformationUpgradabilityKUpgradable string = "kUpgradable"

	// AgentInformationUpgradabilityKCurrent captures enum value "kCurrent"
	AgentInformationUpgradabilityKCurrent string = "kCurrent"

	// AgentInformationUpgradabilityKUnknown captures enum value "kUnknown"
	AgentInformationUpgradabilityKUnknown string = "kUnknown"

	// AgentInformationUpgradabilityKNonUpgradableInvalidVersion captures enum value "kNonUpgradableInvalidVersion"
	AgentInformationUpgradabilityKNonUpgradableInvalidVersion string = "kNonUpgradableInvalidVersion"

	// AgentInformationUpgradabilityKNonUpgradableAgentIsNewer captures enum value "kNonUpgradableAgentIsNewer"
	AgentInformationUpgradabilityKNonUpgradableAgentIsNewer string = "kNonUpgradableAgentIsNewer"

	// AgentInformationUpgradabilityKNonUpgradableAgentIsOld captures enum value "kNonUpgradableAgentIsOld"
	AgentInformationUpgradabilityKNonUpgradableAgentIsOld string = "kNonUpgradableAgentIsOld"
)

// prop value enum
func (m *AgentInformation) validateUpgradabilityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, agentInformationTypeUpgradabilityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AgentInformation) validateUpgradability(formats strfmt.Registry) error {
	if swag.IsZero(m.Upgradability) { // not required
		return nil
	}

	// value enum
	if err := m.validateUpgradabilityEnum("upgradability", "body", *m.Upgradability); err != nil {
		return err
	}

	return nil
}

var agentInformationTypeUpgradeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kIdle","kAccepted","kStarted","kFinished","kScheduled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		agentInformationTypeUpgradeStatusPropEnum = append(agentInformationTypeUpgradeStatusPropEnum, v)
	}
}

const (

	// AgentInformationUpgradeStatusKIdle captures enum value "kIdle"
	AgentInformationUpgradeStatusKIdle string = "kIdle"

	// AgentInformationUpgradeStatusKAccepted captures enum value "kAccepted"
	AgentInformationUpgradeStatusKAccepted string = "kAccepted"

	// AgentInformationUpgradeStatusKStarted captures enum value "kStarted"
	AgentInformationUpgradeStatusKStarted string = "kStarted"

	// AgentInformationUpgradeStatusKFinished captures enum value "kFinished"
	AgentInformationUpgradeStatusKFinished string = "kFinished"

	// AgentInformationUpgradeStatusKScheduled captures enum value "kScheduled"
	AgentInformationUpgradeStatusKScheduled string = "kScheduled"
)

// prop value enum
func (m *AgentInformation) validateUpgradeStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, agentInformationTypeUpgradeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AgentInformation) validateUpgradeStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.UpgradeStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateUpgradeStatusEnum("upgradeStatus", "body", *m.UpgradeStatus); err != nil {
		return err
	}

	return nil
}

func (m *AgentInformation) validateVolCbtInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VolCbtInfo) { // not required
		return nil
	}

	if m.VolCbtInfo != nil {
		if err := m.VolCbtInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volCbtInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("volCbtInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this agent information based on the context it is used
func (m *AgentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFileCbtInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegistrationInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolCbtInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AgentInformation) contextValidateFileCbtInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.FileCbtInfo != nil {

		if swag.IsZero(m.FileCbtInfo) { // not required
			return nil
		}

		if err := m.FileCbtInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileCbtInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileCbtInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AgentInformation) contextValidateRegistrationInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.RegistrationInfo != nil {

		if swag.IsZero(m.RegistrationInfo) { // not required
			return nil
		}

		if err := m.RegistrationInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registrationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registrationInfo")
			}
			return err
		}
	}

	return nil
}

func (m *AgentInformation) contextValidateVolCbtInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.VolCbtInfo != nil {

		if swag.IsZero(m.VolCbtInfo) { // not required
			return nil
		}

		if err := m.VolCbtInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("volCbtInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("volCbtInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AgentInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AgentInformation) UnmarshalBinary(b []byte) error {
	var res AgentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
