// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProtectionSourceSnapshotInformation Protection Source Snapshot.
//
// Specifies details about a Snapshot that backups up a leaf
// Protection Source Object.
//
// swagger:model ProtectionSourceSnapshotInformation
type ProtectionSourceSnapshotInformation struct {

	// Array of Snapshot Copy Tasks.
	//
	// Specifies a list of copy tasks (such as replication and
	// archival tasks).
	CopyTasks []*SnapshotCopyTask `json:"copyTasks"`

	// Specifies the id of the Protection Job.
	JobID *int64 `json:"jobId,omitempty"`

	// Specifies the name of the Protection Job.
	JobName *string `json:"jobName,omitempty"`

	// Specifies the id of the Job Run.
	JobRunID *int64 `json:"jobRunId,omitempty"`

	// Specifies the start time of the Job which this object is part of.
	// The time is specified in Unix epoch Timestamp (in microseconds).
	JobRunStartTimeUsecs *int64 `json:"jobRunStartTimeUsecs,omitempty"`

	// Specifies the end time of the last Run of this object's snapshot.
	// The time is specified in Unix epoch Timestamp (in microseconds).
	LastRunEndTimeUsecs *int64 `json:"lastRunEndTimeUsecs,omitempty"`

	// Specifies the start time of the last Run of this object's snapshot.
	// The time is specified in Unix epoch Timestamp (in microseconds).
	LastRunStartTimeUsecs *int64 `json:"lastRunStartTimeUsecs,omitempty"`

	// Specifies warning or error information when the Job Run is not
	// successful.
	Message *string `json:"message,omitempty"`

	// Specifies the total number of bytes read.
	NumBytesRead *int64 `json:"numBytesRead,omitempty"`

	// Specifies the total number of logical bytes that are protected. The
	// logical size is when the data is fully hydrated or expanded.
	NumLogicalBytesProtected *int64 `json:"numLogicalBytesProtected,omitempty"`

	// Specifies an opaque string to pass into the next request to get
	// the next set of Snapshots for pagination purposes. If null, this
	// is the last set of Snapshots or the number of Snapshots returned
	// is equal to or less than the specified pageCount.
	PaginationCookie *uint64 `json:"paginationCookie,omitempty"`

	// Specifies the type of the Job Run.
	// 'kSuccess' indicates that the Job Run was successful.
	// 'kRunning' indicates that the Job Run is currently running.
	// 'kWarning' indicates that the Job Run was successful but warnings were
	// issued.
	// 'kCancelled' indicates that the Job Run was canceled.
	// 'kError' indicates the Job Run encountered an error and did not run to
	// completion.
	// Enum: ["kSuccess","kRunning","kWarning","kCancelled","kError"]
	RunStatus *string `json:"runStatus,omitempty"`

	// Specifies the status of the Job Run.
	// 'kRegular' indicates an incremental (CBT) backup. Incremental backups
	// utilizing CBT (if supported) are captured of the target protection
	// objects.
	// The first run of a kRegular schedule captures all the blocks.
	// 'kFull' indicates a full (no CBT) backup. A complete backup
	// (all blocks) of the target protection objects are always captured and
	// Change Block Tracking (CBT) is not utilized.
	// 'kLog' indicates a Database Log backup. Capture the database
	// transaction logs to allow rolling back to a specific point in time.
	// 'kSystem' indicates system volume backup. It produces an image
	// for bare metal recovery.
	// Enum: ["kRegular","kFull","kLog","kSystem"]
	RunType *string `json:"runType,omitempty"`
}

// Validate validates this protection source snapshot information
func (m *ProtectionSourceSnapshotInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCopyTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProtectionSourceSnapshotInformation) validateCopyTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.CopyTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.CopyTasks); i++ {
		if swag.IsZero(m.CopyTasks[i]) { // not required
			continue
		}

		if m.CopyTasks[i] != nil {
			if err := m.CopyTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copyTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copyTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var protectionSourceSnapshotInformationTypeRunStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSuccess","kRunning","kWarning","kCancelled","kError"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionSourceSnapshotInformationTypeRunStatusPropEnum = append(protectionSourceSnapshotInformationTypeRunStatusPropEnum, v)
	}
}

const (

	// ProtectionSourceSnapshotInformationRunStatusKSuccess captures enum value "kSuccess"
	ProtectionSourceSnapshotInformationRunStatusKSuccess string = "kSuccess"

	// ProtectionSourceSnapshotInformationRunStatusKRunning captures enum value "kRunning"
	ProtectionSourceSnapshotInformationRunStatusKRunning string = "kRunning"

	// ProtectionSourceSnapshotInformationRunStatusKWarning captures enum value "kWarning"
	ProtectionSourceSnapshotInformationRunStatusKWarning string = "kWarning"

	// ProtectionSourceSnapshotInformationRunStatusKCancelled captures enum value "kCancelled"
	ProtectionSourceSnapshotInformationRunStatusKCancelled string = "kCancelled"

	// ProtectionSourceSnapshotInformationRunStatusKError captures enum value "kError"
	ProtectionSourceSnapshotInformationRunStatusKError string = "kError"
)

// prop value enum
func (m *ProtectionSourceSnapshotInformation) validateRunStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionSourceSnapshotInformationTypeRunStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionSourceSnapshotInformation) validateRunStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.RunStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateRunStatusEnum("runStatus", "body", *m.RunStatus); err != nil {
		return err
	}

	return nil
}

var protectionSourceSnapshotInformationTypeRunTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kRegular","kFull","kLog","kSystem"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionSourceSnapshotInformationTypeRunTypePropEnum = append(protectionSourceSnapshotInformationTypeRunTypePropEnum, v)
	}
}

const (

	// ProtectionSourceSnapshotInformationRunTypeKRegular captures enum value "kRegular"
	ProtectionSourceSnapshotInformationRunTypeKRegular string = "kRegular"

	// ProtectionSourceSnapshotInformationRunTypeKFull captures enum value "kFull"
	ProtectionSourceSnapshotInformationRunTypeKFull string = "kFull"

	// ProtectionSourceSnapshotInformationRunTypeKLog captures enum value "kLog"
	ProtectionSourceSnapshotInformationRunTypeKLog string = "kLog"

	// ProtectionSourceSnapshotInformationRunTypeKSystem captures enum value "kSystem"
	ProtectionSourceSnapshotInformationRunTypeKSystem string = "kSystem"
)

// prop value enum
func (m *ProtectionSourceSnapshotInformation) validateRunTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionSourceSnapshotInformationTypeRunTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionSourceSnapshotInformation) validateRunType(formats strfmt.Registry) error {
	if swag.IsZero(m.RunType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRunTypeEnum("runType", "body", *m.RunType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this protection source snapshot information based on the context it is used
func (m *ProtectionSourceSnapshotInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCopyTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProtectionSourceSnapshotInformation) contextValidateCopyTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CopyTasks); i++ {

		if m.CopyTasks[i] != nil {

			if swag.IsZero(m.CopyTasks[i]) { // not required
				return nil
			}

			if err := m.CopyTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copyTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copyTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProtectionSourceSnapshotInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProtectionSourceSnapshotInformation) UnmarshalBinary(b []byte) error {
	var res ProtectionSourceSnapshotInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
