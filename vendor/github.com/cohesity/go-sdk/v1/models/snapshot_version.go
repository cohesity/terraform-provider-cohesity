// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SnapshotVersion Snapshot Version.
//
// Specifies information about snapshots of a backup object.
//
// swagger:model SnapshotVersion
type SnapshotVersion struct {

	// Specifies the number of the attempts made by the Job Run
	// to capture a snapshot of the object. For example, if an snapshot
	// is successfully captured after three attempts, this field equals 3.
	AttemptNumber *int64 `json:"attemptNumber,omitempty"`

	// Specifies the size of the data captured from the source object.
	// For a full backup (where Change Block Tracking is not utilized)
	// this field is equal to logicalSizeBytes. For an incremental backup
	// (where Change Block Tracking is utilized), this field specifies
	// the size of the data that has changed since the last backup.
	DeltaSizeBytes *int64 `json:"deltaSizeBytes,omitempty"`

	// Specifies the indexing status of the snapshot.
	// Specifies the indexing status of the snapshot.
	// 'kStarted' indicates that indexing has started.
	// 'kDone' indicates that indexing has been completed according to the type
	// of object.
	// 'kNoIndex' indicates that the snapshot cannot be indexed. This is the case
	// during archival restore.
	// 'kIceboxRestoreStarted' indicates that indexing is started from an
	// archive.
	// 'kIceboxRestoreError' indicates that an error occurred during restore
	// from archiveand there is no index present.
	// 'kSkipped' indicates that indexing is skipped due to indexing backlog.
	// Enum: ["kStarted","kDone","kNoIndex","kIceboxRestoreStarted","kIceboxRestoreError","kSkipped"]
	IndexingStatus *string `json:"indexingStatus,omitempty"`

	// Specifies if an app-consistent snapshot was captured. For example,
	// was the VM was quiesced before the snapshot was captured.
	IsAppConsistent *bool `json:"isAppConsistent,omitempty"`

	// Specifies if the snapshot is a full backup. For example, all blocks
	// of the VM is captured and Change Block Tracking is not utilized.
	IsFullBackup *bool `json:"isFullBackup,omitempty"`

	// Specifies the id of the Job Run that captured the snapshot.
	JobRunID *int64 `json:"jobRunId,omitempty"`

	// Specifies the local path relative to the View, without the
	// ViewBox/View prefix.
	LocalMountPath *string `json:"localMountPath,omitempty"`

	// Specifies the size of the snapshot if the data
	// is fully hydrated or expanded and not reduced
	// by change-block tracking, compression and deduplication.
	// For example if a VMDK of size 100GB is created with thin provisioning
	// and the disk size to store the VMDK is 20GB.
	// The logical size of this object is 100GB and the physical size is 20GB.
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// Specifies the amount of data actually used on the disk to store this
	// object after being reduced by change-block tracking, compression and
	// deduplication.
	PhysicalSizeBytes *int64 `json:"physicalSizeBytes,omitempty"`

	// Specifies the total amount of disk space used to store this
	// object on the primary storage. For example the
	// total amount of disk space used to store the VM files
	// (such as the VMDK files) on the primary datastore.
	PrimaryPhysicalSizeBytes *int64 `json:"primaryPhysicalSizeBytes,omitempty"`

	// Specifies the list of replication information about the current snapshot.
	ReplicaInfoList []*ReplicaInfo `json:"replicaInfoList"`

	// Specifies the time when the Job Run starts capturing a snapshot.
	// Specified as a Unix epoch Timestamp (in microseconds).
	StartedTimeUsecs *int64 `json:"startedTimeUsecs,omitempty"`
}

// Validate validates this snapshot version
func (m *SnapshotVersion) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIndexingStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicaInfoList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var snapshotVersionTypeIndexingStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kStarted","kDone","kNoIndex","kIceboxRestoreStarted","kIceboxRestoreError","kSkipped"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		snapshotVersionTypeIndexingStatusPropEnum = append(snapshotVersionTypeIndexingStatusPropEnum, v)
	}
}

const (

	// SnapshotVersionIndexingStatusKStarted captures enum value "kStarted"
	SnapshotVersionIndexingStatusKStarted string = "kStarted"

	// SnapshotVersionIndexingStatusKDone captures enum value "kDone"
	SnapshotVersionIndexingStatusKDone string = "kDone"

	// SnapshotVersionIndexingStatusKNoIndex captures enum value "kNoIndex"
	SnapshotVersionIndexingStatusKNoIndex string = "kNoIndex"

	// SnapshotVersionIndexingStatusKIceboxRestoreStarted captures enum value "kIceboxRestoreStarted"
	SnapshotVersionIndexingStatusKIceboxRestoreStarted string = "kIceboxRestoreStarted"

	// SnapshotVersionIndexingStatusKIceboxRestoreError captures enum value "kIceboxRestoreError"
	SnapshotVersionIndexingStatusKIceboxRestoreError string = "kIceboxRestoreError"

	// SnapshotVersionIndexingStatusKSkipped captures enum value "kSkipped"
	SnapshotVersionIndexingStatusKSkipped string = "kSkipped"
)

// prop value enum
func (m *SnapshotVersion) validateIndexingStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, snapshotVersionTypeIndexingStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SnapshotVersion) validateIndexingStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.IndexingStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateIndexingStatusEnum("indexingStatus", "body", *m.IndexingStatus); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotVersion) validateReplicaInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicaInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.ReplicaInfoList); i++ {
		if swag.IsZero(m.ReplicaInfoList[i]) { // not required
			continue
		}

		if m.ReplicaInfoList[i] != nil {
			if err := m.ReplicaInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("replicaInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("replicaInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this snapshot version based on the context it is used
func (m *SnapshotVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateReplicaInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapshotVersion) contextValidateReplicaInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ReplicaInfoList); i++ {

		if m.ReplicaInfoList[i] != nil {

			if swag.IsZero(m.ReplicaInfoList[i]) { // not required
				return nil
			}

			if err := m.ReplicaInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("replicaInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("replicaInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapshotVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapshotVersion) UnmarshalBinary(b []byte) error {
	var res SnapshotVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
