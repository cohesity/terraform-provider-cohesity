// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PhysicalProtectionSource Physical Protection Source.
//
// Specifies a Protection Source in a Physical environment.
//
// swagger:model PhysicalProtectionSource
type PhysicalProtectionSource struct {

	// Array of Agents on the Physical Protection Source.
	//
	// Specifiles the agents running on the Physical Protection Source and the
	// status information.
	Agents []*AgentInformation `json:"agents"`

	// Specifies the type of cluster resource this source represents.
	ClusterSourceType *string `json:"clusterSourceType,omitempty"`

	// Specifies the hostname.
	HostName *string `json:"hostName,omitempty"`

	// Specifies the environment type for the host.
	// 'kLinux' indicates the Linux operating system.
	// 'kWindows' indicates the Microsoft Windows operating system.
	// 'kAix' indicates the IBM AIX operating system.
	// 'kSolaris' indicates the Oracle Solaris operating system.
	// 'kSapHana' indicates the Sap Hana database system developed by SAP SE.
	// 'kSapOracle' indicates the Sap Oracle database system developed by SAP SE.
	// 'kCockroachDB' indicates the CockroachDB database system.
	// 'kMySQL' indicates the MySQL database system.
	// 'kSapSybase' indicates the SapSybase database system.
	// 'kSapMaxDB' indicates the SapMaxDB database system.
	// 'kSapSybaseIQ' indicates the SapSybaseIQ database system.
	// 'kDB2' indicates the DB2 database system.
	// 'kSapASE' indicates the SapASE database system.
	// 'kMariaDB' indicates the MariaDB database system.
	// 'kPostgreSQL' indicates the PostgreSQL database system.
	// 'kHPUX' indicates the HPUX database system.
	// 'kVOS' indicates the VOS database system.
	// 'kOther' indicates the other types of operating system.
	// Enum: ["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]
	HostType *string `json:"hostType,omitempty"`

	// Specifies a unique id of a Physical Protection Source.
	// The id is unique across Cohesity Clusters.
	ID struct {
		UniversalID
	} `json:"id,omitempty"`

	// Specifies if the physical host is a proxy host.
	IsProxyHost *bool `json:"isProxyHost,omitempty"`

	// Specifies the total memory on the host in bytes.
	MemorySizeBytes *int64 `json:"memorySizeBytes,omitempty"`

	// Specifies a human readable name of the Protection Source.
	Name *string `json:"name,omitempty"`

	// Cached networking info. This establishes physical-->agent linkage for
	// the Cluster case.
	NetworkingInfo *NetworkingInformation `json:"networkingInfo,omitempty"`

	// Specifies the number of processors on the host.
	NumProcessors *int64 `json:"numProcessors,omitempty"`

	// Specifies a human readable name of the OS of the Protection Source.
	OsName *string `json:"osName,omitempty"`

	// Specifies the type of managed Object in a Physical Protection Source.
	// 'kGroup' indicates the EH container.
	// 'kHost' indicates a single physical server.
	// 'kWindowsCluster' indicates a Microsoft Windows cluster.
	// 'kOracleRACCluster' indicates an Oracle Real Application Cluster(RAC).
	// 'kOracleAPCluster' indicates an Oracle Active-Passive Cluster.
	// 'kUnixCluster' indicates a RedHat Pacemaker or any UnixCluster.
	// kUnixCluster
	// Enum: ["kGroup","kHost","kWindowsCluster","kOracleRACCluster","kOracleAPCluster"]
	Type *string `json:"type,omitempty"`

	// Specifies cluster version for VCS host.
	VcsVersion *string `json:"vcsVersion,omitempty"`

	// Array of Physical Volumes.
	//
	// Specifies the volumes available on the physical host.
	// These fields are populated only for the kPhysicalHost type.
	Volumes []*PhysicalVolume `json:"volumes"`

	// Specifies the list of writers available on the physical
	// host. These fields are populated only for the kPhysicalHost
	// type, particularly when the host is windows
	Vsswriters []*VssWriter `json:"vsswriters"`
}

// Validate validates this physical protection source
func (m *PhysicalProtectionSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkingInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVsswriters(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PhysicalProtectionSource) validateAgents(formats strfmt.Registry) error {
	if swag.IsZero(m.Agents) { // not required
		return nil
	}

	for i := 0; i < len(m.Agents); i++ {
		if swag.IsZero(m.Agents[i]) { // not required
			continue
		}

		if m.Agents[i] != nil {
			if err := m.Agents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var physicalProtectionSourceTypeHostTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		physicalProtectionSourceTypeHostTypePropEnum = append(physicalProtectionSourceTypeHostTypePropEnum, v)
	}
}

const (

	// PhysicalProtectionSourceHostTypeKLinux captures enum value "kLinux"
	PhysicalProtectionSourceHostTypeKLinux string = "kLinux"

	// PhysicalProtectionSourceHostTypeKWindows captures enum value "kWindows"
	PhysicalProtectionSourceHostTypeKWindows string = "kWindows"

	// PhysicalProtectionSourceHostTypeKAix captures enum value "kAix"
	PhysicalProtectionSourceHostTypeKAix string = "kAix"

	// PhysicalProtectionSourceHostTypeKSolaris captures enum value "kSolaris"
	PhysicalProtectionSourceHostTypeKSolaris string = "kSolaris"

	// PhysicalProtectionSourceHostTypeKSapHana captures enum value "kSapHana"
	PhysicalProtectionSourceHostTypeKSapHana string = "kSapHana"

	// PhysicalProtectionSourceHostTypeKSapOracle captures enum value "kSapOracle"
	PhysicalProtectionSourceHostTypeKSapOracle string = "kSapOracle"

	// PhysicalProtectionSourceHostTypeKCockroachDB captures enum value "kCockroachDB"
	PhysicalProtectionSourceHostTypeKCockroachDB string = "kCockroachDB"

	// PhysicalProtectionSourceHostTypeKMySQL captures enum value "kMySQL"
	PhysicalProtectionSourceHostTypeKMySQL string = "kMySQL"

	// PhysicalProtectionSourceHostTypeKOther captures enum value "kOther"
	PhysicalProtectionSourceHostTypeKOther string = "kOther"

	// PhysicalProtectionSourceHostTypeKSapSybase captures enum value "kSapSybase"
	PhysicalProtectionSourceHostTypeKSapSybase string = "kSapSybase"

	// PhysicalProtectionSourceHostTypeKSapMaxDB captures enum value "kSapMaxDB"
	PhysicalProtectionSourceHostTypeKSapMaxDB string = "kSapMaxDB"

	// PhysicalProtectionSourceHostTypeKSapSybaseIQ captures enum value "kSapSybaseIQ"
	PhysicalProtectionSourceHostTypeKSapSybaseIQ string = "kSapSybaseIQ"

	// PhysicalProtectionSourceHostTypeKDB2 captures enum value "kDB2"
	PhysicalProtectionSourceHostTypeKDB2 string = "kDB2"

	// PhysicalProtectionSourceHostTypeKSapASE captures enum value "kSapASE"
	PhysicalProtectionSourceHostTypeKSapASE string = "kSapASE"

	// PhysicalProtectionSourceHostTypeKMariaDB captures enum value "kMariaDB"
	PhysicalProtectionSourceHostTypeKMariaDB string = "kMariaDB"

	// PhysicalProtectionSourceHostTypeKPostgreSQL captures enum value "kPostgreSQL"
	PhysicalProtectionSourceHostTypeKPostgreSQL string = "kPostgreSQL"

	// PhysicalProtectionSourceHostTypeKVOS captures enum value "kVOS"
	PhysicalProtectionSourceHostTypeKVOS string = "kVOS"

	// PhysicalProtectionSourceHostTypeKHPUX captures enum value "kHPUX"
	PhysicalProtectionSourceHostTypeKHPUX string = "kHPUX"
)

// prop value enum
func (m *PhysicalProtectionSource) validateHostTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, physicalProtectionSourceTypeHostTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PhysicalProtectionSource) validateHostType(formats strfmt.Registry) error {
	if swag.IsZero(m.HostType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHostTypeEnum("hostType", "body", *m.HostType); err != nil {
		return err
	}

	return nil
}

func (m *PhysicalProtectionSource) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	return nil
}

func (m *PhysicalProtectionSource) validateNetworkingInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkingInfo) { // not required
		return nil
	}

	if m.NetworkingInfo != nil {
		if err := m.NetworkingInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("networkingInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("networkingInfo")
			}
			return err
		}
	}

	return nil
}

var physicalProtectionSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kGroup","kHost","kWindowsCluster","kOracleRACCluster","kOracleAPCluster"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		physicalProtectionSourceTypeTypePropEnum = append(physicalProtectionSourceTypeTypePropEnum, v)
	}
}

const (

	// PhysicalProtectionSourceTypeKGroup captures enum value "kGroup"
	PhysicalProtectionSourceTypeKGroup string = "kGroup"

	// PhysicalProtectionSourceTypeKHost captures enum value "kHost"
	PhysicalProtectionSourceTypeKHost string = "kHost"

	// PhysicalProtectionSourceTypeKWindowsCluster captures enum value "kWindowsCluster"
	PhysicalProtectionSourceTypeKWindowsCluster string = "kWindowsCluster"

	// PhysicalProtectionSourceTypeKOracleRACCluster captures enum value "kOracleRACCluster"
	PhysicalProtectionSourceTypeKOracleRACCluster string = "kOracleRACCluster"

	// PhysicalProtectionSourceTypeKOracleAPCluster captures enum value "kOracleAPCluster"
	PhysicalProtectionSourceTypeKOracleAPCluster string = "kOracleAPCluster"
)

// prop value enum
func (m *PhysicalProtectionSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, physicalProtectionSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PhysicalProtectionSource) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *PhysicalProtectionSource) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PhysicalProtectionSource) validateVsswriters(formats strfmt.Registry) error {
	if swag.IsZero(m.Vsswriters) { // not required
		return nil
	}

	for i := 0; i < len(m.Vsswriters); i++ {
		if swag.IsZero(m.Vsswriters[i]) { // not required
			continue
		}

		if m.Vsswriters[i] != nil {
			if err := m.Vsswriters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vsswriters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vsswriters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this physical protection source based on the context it is used
func (m *PhysicalProtectionSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAgents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkingInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVsswriters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PhysicalProtectionSource) contextValidateAgents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Agents); i++ {

		if m.Agents[i] != nil {

			if swag.IsZero(m.Agents[i]) { // not required
				return nil
			}

			if err := m.Agents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PhysicalProtectionSource) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *PhysicalProtectionSource) contextValidateNetworkingInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkingInfo != nil {

		if swag.IsZero(m.NetworkingInfo) { // not required
			return nil
		}

		if err := m.NetworkingInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("networkingInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("networkingInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PhysicalProtectionSource) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {

			if swag.IsZero(m.Volumes[i]) { // not required
				return nil
			}

			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PhysicalProtectionSource) contextValidateVsswriters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vsswriters); i++ {

		if m.Vsswriters[i] != nil {

			if swag.IsZero(m.Vsswriters[i]) { // not required
				return nil
			}

			if err := m.Vsswriters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vsswriters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vsswriters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PhysicalProtectionSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PhysicalProtectionSource) UnmarshalBinary(b []byte) error {
	var res PhysicalProtectionSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
