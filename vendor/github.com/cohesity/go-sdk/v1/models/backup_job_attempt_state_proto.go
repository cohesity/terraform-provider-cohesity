// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// BackupJobAttemptStateProto This message contains persistent information about a specific backup
// instance attempt. It could either be active, or could have finished.
//
// swagger:model BackupJobAttemptStateProto
type BackupJobAttemptStateProto struct {

	// A list of active tasks for the job run attempt.
	ActiveTasks []*BackupTaskStateProto `json:"activeTasks"`

	// Contains basic information about the backup run attempt.
	Base *BackupJobTaskStateBaseProto `json:"base,omitempty"`

	// A list of sources that the job should not backup. These sources can be at
	// any level in the entity hierarchy.
	ExcludeSources []*BackupJobProtoExcludeSource `json:"excludeSources"`

	// A list of sources that the job should not backup. These sources can be at
	// any level in the entity hierarchy.
	// TODO(Chinmaya): Remove after removing references.
	ExcludeSourcesDEPRECATED []*PrivateEntityProto `json:"excludeSources_DEPRECATED"`

	// This will be set to true if the backup attempt was started despite a
	// scheduling failure (in this case, the attempt will abort early). We do
	// this so that the user can see that the attempt is marked as failed and
	// also so that they can get alerts when we fail to schedule.
	FailedToSchedule *bool `json:"failedToSchedule,omitempty"`

	// A list of finished tasks for the job run attempt. Also contains failed
	// and cancelled tasks.
	FinishedTasks []*BackupTaskStateProto `json:"finishedTasks"`

	// The start time corresponding to the first attempt of this backup job run.
	FirstAttemptStartTimeUsecs *int64 `json:"firstAttemptStartTimeUsecs,omitempty"`

	// The maximum number of attempts allowed for this run.
	// This is normally a property of the backup job, but we capture it here
	// at the beginning of a backup run since the value stored in the backup job
	// can change while a run (and its attempts) is ongoing.
	MaxAttempts *int32 `json:"maxAttempts,omitempty"`

	// Number of backup tasks that were cancelled.
	NumCancelledTasks *int64 `json:"numCancelledTasks,omitempty"`

	// Number of backup tasks that failed.
	NumFailedTasks *int64 `json:"numFailedTasks,omitempty"`

	// Number of backup tasks that were skipped.
	NumSkippedTasks *int64 `json:"numSkippedTasks,omitempty"`

	// Number of backup tasks that were successful.
	NumSuccessfulTasks *int64 `json:"numSuccessfulTasks,omitempty"`

	// TODO(mark): Mark this field as deprecated once Iris stops using it.
	// Whether the backup snapshots created by this attempt have been deleted
	// (due to either retention policies or because the user asked us to).
	SnapshotsDeleted *bool `json:"snapshotsDeleted,omitempty"`

	// Whether all required stats counters and containers have been created for
	// this job.
	StatsContainersCreated *bool `json:"statsContainersCreated,omitempty"`

	// Id of the task that manages the storage based snapshots of entities
	// backed up in this attempt. This field will be set only if storage based
	// snapshots is enabled for the backup run this attempt state proto is part
	// of.
	StorageSnapshotTaskID *int64 `json:"storageSnapshotTaskId,omitempty"`
}

// Validate validates this backup job attempt state proto
func (m *BackupJobAttemptStateProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActiveTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeSourcesDEPRECATED(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinishedTasks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobAttemptStateProto) validateActiveTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.ActiveTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.ActiveTasks); i++ {
		if swag.IsZero(m.ActiveTasks[i]) { // not required
			continue
		}

		if m.ActiveTasks[i] != nil {
			if err := m.ActiveTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobAttemptStateProto) validateBase(formats strfmt.Registry) error {
	if swag.IsZero(m.Base) { // not required
		return nil
	}

	if m.Base != nil {
		if err := m.Base.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("base")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("base")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobAttemptStateProto) validateExcludeSources(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeSources) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludeSources); i++ {
		if swag.IsZero(m.ExcludeSources[i]) { // not required
			continue
		}

		if m.ExcludeSources[i] != nil {
			if err := m.ExcludeSources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobAttemptStateProto) validateExcludeSourcesDEPRECATED(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeSourcesDEPRECATED) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludeSourcesDEPRECATED); i++ {
		if swag.IsZero(m.ExcludeSourcesDEPRECATED[i]) { // not required
			continue
		}

		if m.ExcludeSourcesDEPRECATED[i] != nil {
			if err := m.ExcludeSourcesDEPRECATED[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobAttemptStateProto) validateFinishedTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.FinishedTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.FinishedTasks); i++ {
		if swag.IsZero(m.FinishedTasks[i]) { // not required
			continue
		}

		if m.FinishedTasks[i] != nil {
			if err := m.FinishedTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this backup job attempt state proto based on the context it is used
func (m *BackupJobAttemptStateProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActiveTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludeSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludeSourcesDEPRECATED(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinishedTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobAttemptStateProto) contextValidateActiveTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ActiveTasks); i++ {

		if m.ActiveTasks[i] != nil {

			if swag.IsZero(m.ActiveTasks[i]) { // not required
				return nil
			}

			if err := m.ActiveTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobAttemptStateProto) contextValidateBase(ctx context.Context, formats strfmt.Registry) error {

	if m.Base != nil {

		if swag.IsZero(m.Base) { // not required
			return nil
		}

		if err := m.Base.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("base")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("base")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobAttemptStateProto) contextValidateExcludeSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludeSources); i++ {

		if m.ExcludeSources[i] != nil {

			if swag.IsZero(m.ExcludeSources[i]) { // not required
				return nil
			}

			if err := m.ExcludeSources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobAttemptStateProto) contextValidateExcludeSourcesDEPRECATED(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludeSourcesDEPRECATED); i++ {

		if m.ExcludeSourcesDEPRECATED[i] != nil {

			if swag.IsZero(m.ExcludeSourcesDEPRECATED[i]) { // not required
				return nil
			}

			if err := m.ExcludeSourcesDEPRECATED[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobAttemptStateProto) contextValidateFinishedTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FinishedTasks); i++ {

		if m.FinishedTasks[i] != nil {

			if swag.IsZero(m.FinishedTasks[i]) { // not required
				return nil
			}

			if err := m.FinishedTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupJobAttemptStateProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupJobAttemptStateProto) UnmarshalBinary(b []byte) error {
	var res BackupJobAttemptStateProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
