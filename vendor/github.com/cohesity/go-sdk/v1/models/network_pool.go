// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NetworkPool Specifies the network pool config of an Isilon Access Zone.
//
// swagger:model NetworkPool
type NetworkPool struct {

	// Specifies the enum for the IP address families.
	// 'kUnknown' indicates IP address families are unknown.
	// 'kIPv4' indicates IP addresses used are from IPv4 family.
	// 'kIPv6' indicates IP addresses used are from IPv6 family.
	// Enum: ["kUnknown","kIPv4","kIPv6"]
	AddressFamily *string `json:"addressFamily,omitempty"`

	// Specifies the enum for IP allocation method.
	// 'kUnknownAllocMethod' indicates allocation method is unknown.
	// 'kStaticAllocMethod' indicates static allocation method for IP addresses.
	// 'kDynamicAllocMethod' indicates dynamic allocation method for IP addresses.
	// Enum: ["kUnknownAllocMethod","kStaticAllocMethod","kDynamicAllocMethod"]
	AllocationMethod *string `json:"allocationMethod,omitempty"`

	// Specifies the groupnet name of the network pool.
	Groupnet *string `json:"groupnet,omitempty"`

	// Specifies the unique identifier of the network pool.
	ID *string `json:"id,omitempty"`

	// Specifies the name of the network pool.
	Name *string `json:"name,omitempty"`

	// Specifies the IP address range.
	Ranges []*NetworkPoolRange `json:"ranges"`

	// Specifies the SmartConnect zone name of the network pool.
	SmartConnectDNSZone *string `json:"smartConnectDnsZone,omitempty"`

	// Specifies the subnet name of the network pool.
	Subnet *string `json:"subnet,omitempty"`
}

// Validate validates this network pool
func (m *NetworkPool) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddressFamily(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllocationMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRanges(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var networkPoolTypeAddressFamilyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUnknown","kIPv4","kIPv6"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		networkPoolTypeAddressFamilyPropEnum = append(networkPoolTypeAddressFamilyPropEnum, v)
	}
}

const (

	// NetworkPoolAddressFamilyKUnknown captures enum value "kUnknown"
	NetworkPoolAddressFamilyKUnknown string = "kUnknown"

	// NetworkPoolAddressFamilyKIPV4 captures enum value "kIPv4"
	NetworkPoolAddressFamilyKIPV4 string = "kIPv4"

	// NetworkPoolAddressFamilyKIPV6 captures enum value "kIPv6"
	NetworkPoolAddressFamilyKIPV6 string = "kIPv6"
)

// prop value enum
func (m *NetworkPool) validateAddressFamilyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, networkPoolTypeAddressFamilyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NetworkPool) validateAddressFamily(formats strfmt.Registry) error {
	if swag.IsZero(m.AddressFamily) { // not required
		return nil
	}

	// value enum
	if err := m.validateAddressFamilyEnum("addressFamily", "body", *m.AddressFamily); err != nil {
		return err
	}

	return nil
}

var networkPoolTypeAllocationMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUnknownAllocMethod","kStaticAllocMethod","kDynamicAllocMethod"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		networkPoolTypeAllocationMethodPropEnum = append(networkPoolTypeAllocationMethodPropEnum, v)
	}
}

const (

	// NetworkPoolAllocationMethodKUnknownAllocMethod captures enum value "kUnknownAllocMethod"
	NetworkPoolAllocationMethodKUnknownAllocMethod string = "kUnknownAllocMethod"

	// NetworkPoolAllocationMethodKStaticAllocMethod captures enum value "kStaticAllocMethod"
	NetworkPoolAllocationMethodKStaticAllocMethod string = "kStaticAllocMethod"

	// NetworkPoolAllocationMethodKDynamicAllocMethod captures enum value "kDynamicAllocMethod"
	NetworkPoolAllocationMethodKDynamicAllocMethod string = "kDynamicAllocMethod"
)

// prop value enum
func (m *NetworkPool) validateAllocationMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, networkPoolTypeAllocationMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NetworkPool) validateAllocationMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.AllocationMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateAllocationMethodEnum("allocationMethod", "body", *m.AllocationMethod); err != nil {
		return err
	}

	return nil
}

func (m *NetworkPool) validateRanges(formats strfmt.Registry) error {
	if swag.IsZero(m.Ranges) { // not required
		return nil
	}

	for i := 0; i < len(m.Ranges); i++ {
		if swag.IsZero(m.Ranges[i]) { // not required
			continue
		}

		if m.Ranges[i] != nil {
			if err := m.Ranges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ranges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ranges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this network pool based on the context it is used
func (m *NetworkPool) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRanges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkPool) contextValidateRanges(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ranges); i++ {

		if m.Ranges[i] != nil {

			if swag.IsZero(m.Ranges[i]) { // not required
				return nil
			}

			if err := m.Ranges[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ranges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ranges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *NetworkPool) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkPool) UnmarshalBinary(b []byte) error {
	var res NetworkPool
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
