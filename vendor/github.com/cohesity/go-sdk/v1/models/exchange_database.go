// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ExchangeDatabase Information about Exchange mailbox Database that is common for standalone or
// DAG enabled database copy.
//
// swagger:model ExchangeDatabase
type ExchangeDatabase struct {

	// There is a current VSS backup that is in progress for this database on
	// this node or on another DAG node. If another backup is dispatched, it will
	// fail.
	BackupInProgress *bool `json:"backupInProgress,omitempty"`

	// Whether backing up this DB is supported or not due to system or
	// implementation limitations. If the value is false, reason
	// string below can be used to say why its not supported. At least one reason
	// should be present when this value is false.
	BackupSupported *bool `json:"backupSupported,omitempty"`

	// Last backup times.
	BackupTimes *ExchangeDatabaseBackupTimes `json:"backupTimes,omitempty"`

	// Free form text for the reasons why backup is not supported for this DB.
	// This is valid only if backup_supported = false. The first element in
	// this vector is the top reason why its not supported. For example, if the
	// db is dismounted for error cases, subsequent elements may show missing EDB
	// file.
	BackupUnsupportedReasonVec []string `json:"backupUnsupportedReasonVec"`

	// Content index state for the database. If indexing state is not success,
	// then logs will not be truncated in the database after VSS backup.
	ContentIndexState *int32 `json:"contentIndexState,omitempty"`

	// When this DB was created in local time.
	CreatedDate *LocalTime `json:"createdDate,omitempty"`

	// EDB info.
	Edb *ExchangeEDBInfo `json:"edb,omitempty"`

	// This indicates whether only full backup of this database is supported. For
	// example when circular logging is enabled, only full backup will be
	// supported as Exchange will recycle logs. This flag is valid only when
	// 'backup_support' = true.
	FullBackupOnly *bool `json:"fullBackupOnly,omitempty"`

	// Identity of the database.
	ID *ExchangeDatabaseIdentity `json:"id,omitempty"`

	// LOG and checkpoint info.
	Log *ExchangeLogInfo `json:"log,omitempty"`

	// Master server type of the database. Tells whether its standalone/DAG.
	MasterType *int32 `json:"masterType,omitempty"`

	// There is a current run of Exchange DB maintenance in progress at this
	// time. VSS backup should not have issue with online maintenance. So this
	// info is captured for debugging purpose.
	OnlineMaintenanceInProgress *bool `json:"onlineMaintenanceInProgress,omitempty"`

	// This is a special type of db: Recovery database. Exchange does not support
	// backing this type of db.
	Recovery *bool `json:"recovery,omitempty"`

	// Replay Lag Time in hours configured in Exchange Admin Console for the
	// database. This value is specific to an Exchange server node.
	ReplayLagHours *uint32 `json:"replayLagHours,omitempty"`

	// Computed state of the database.
	State *int32 `json:"state,omitempty"`

	// Database type. Mailbox, Public folder, etc.
	Type *int32 `json:"type,omitempty"`
}

// Validate validates this exchange database
func (m *ExchangeDatabase) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackupTimes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdb(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ExchangeDatabase) validateBackupTimes(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupTimes) { // not required
		return nil
	}

	if m.BackupTimes != nil {
		if err := m.BackupTimes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupTimes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupTimes")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if m.CreatedDate != nil {
		if err := m.CreatedDate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdDate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createdDate")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) validateEdb(formats strfmt.Registry) error {
	if swag.IsZero(m.Edb) { // not required
		return nil
	}

	if m.Edb != nil {
		if err := m.Edb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("edb")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("edb")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if m.ID != nil {
		if err := m.ID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) validateLog(formats strfmt.Registry) error {
	if swag.IsZero(m.Log) { // not required
		return nil
	}

	if m.Log != nil {
		if err := m.Log.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this exchange database based on the context it is used
func (m *ExchangeDatabase) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBackupTimes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedDate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEdb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ExchangeDatabase) contextValidateBackupTimes(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupTimes != nil {

		if swag.IsZero(m.BackupTimes) { // not required
			return nil
		}

		if err := m.BackupTimes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupTimes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupTimes")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) contextValidateCreatedDate(ctx context.Context, formats strfmt.Registry) error {

	if m.CreatedDate != nil {

		if swag.IsZero(m.CreatedDate) { // not required
			return nil
		}

		if err := m.CreatedDate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdDate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createdDate")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) contextValidateEdb(ctx context.Context, formats strfmt.Registry) error {

	if m.Edb != nil {

		if swag.IsZero(m.Edb) { // not required
			return nil
		}

		if err := m.Edb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("edb")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("edb")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if m.ID != nil {

		if swag.IsZero(m.ID) { // not required
			return nil
		}

		if err := m.ID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *ExchangeDatabase) contextValidateLog(ctx context.Context, formats strfmt.Registry) error {

	if m.Log != nil {

		if swag.IsZero(m.Log) { // not required
			return nil
		}

		if err := m.Log.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("log")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("log")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ExchangeDatabase) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ExchangeDatabase) UnmarshalBinary(b []byte) error {
	var res ExchangeDatabase
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
