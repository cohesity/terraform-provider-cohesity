// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProtectionJobRequestBody Protection Job Request.
//
// Specifies information about a Protection Job.
//
// swagger:model ProtectionJobRequestBody
type ProtectionJobRequestBody struct {

	// If true, the Cohesity Cluster aborts any currently executing Job Runs
	// of this Protection Job when a QuietTime period specified for this Job
	// starts, even if the Job Run started before the QuietTime
	// period began.
	// If false, a Job Run continues to execute, if the Job Run started before
	// the QuietTime period starts.
	AbortInBlackoutPeriod *bool `json:"abortInBlackoutPeriod,omitempty"`

	// Alerting configuration can be used to specify optional details for the
	// alerts triggered by this job.
	AlertingConfig *AlertingConfig `json:"alertingConfig,omitempty"`

	// Array of Job Events.
	//
	// During Job Runs, the following Job Events are generated:
	// 1) Job succeeds 2) Job fails
	// 3) Job violates the SLA
	// These Job Events can cause Alerts to be generated.
	// 'kSuccess' means the Protection Job succeeded.
	// 'kFailure' means the Protection Job failed.
	// 'kSlaViolation' means the Protection Job took longer than the time period
	// specified in the SLA.
	AlertingPolicy []string `json:"alertingPolicy"`

	// If this fiels is set to true, then we wil allow parallel runs for the job
	// for the adapters which support parallel runs.
	AllowParallelRuns *bool `json:"allowParallelRuns,omitempty"`

	// Specifies Cloud specific parameters applicable in various scenarios.
	CloudParameters *CloudParameters `json:"cloudParameters,omitempty"`

	// Whether to continue backing up on quiesce failure.
	ContinueOnQuiesceFailure *bool `json:"continueOnQuiesceFailure,omitempty"`

	// Specifies whether to create a remote view name to use for view overwrite.
	// This field is deprecated. Remote view names will automatically be used
	// for all view jobs with replication policy. Use RemoteViewConfigList to
	// setup remote view names.
	// deprecated: true
	CreateRemoteView *bool `json:"createRemoteView,omitempty"`

	// Specifies policy for a data migration job. It contains inline schedule to
	// run the data migration job. In addition to this, it also contains
	// retention policy that should be applied to files after they have been
	// moved to cohesity cluster. It is present only in case data migration job.
	DataMigrationPolicy *DataMigrationPolicy `json:"dataMigrationPolicy,omitempty"`

	// List of source ids for which source side dedup is disabled from the backup
	// job.
	DedupDisabledSourceIds []int64 `json:"dedupDisabledSourceIds"`

	// Specifies a text description about the Protection Job.
	Description *string `json:"description,omitempty"`

	// Specifies the epoch time (in microseconds) after which the Protection Job
	// becomes dormant.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies the environment type (such as kVMware or kSQL)
	// of the Protection Source this Job is protecting.
	// Supported environment types such as 'kView', 'kSQL', 'kVMware', etc.
	// NOTE: 'kPuppeteer' refers to Cohesity's Remote Adapter.
	// 'kVMware' indicates the VMware Protection Source environment.
	// 'kHyperV' indicates the HyperV Protection Source environment.
	// 'kSQL' indicates the SQL Protection Source environment.
	// 'kView' indicates the View Protection Source environment.
	// 'kPuppeteer' indicates the Cohesity's Remote Adapter.
	// 'kPhysical' indicates the physical Protection Source environment.
	// 'kPure' indicates the Pure Storage Protection Source environment.
	// 'kNimble' indicates the Nimble Storage Protection Source environment.
	// 'kAzure' indicates the Microsoft's Azure Protection Source environment.
	// 'kNetapp' indicates the Netapp Protection Source environment.
	// 'kAgent' indicates the Agent Protection Source environment.
	// 'kGenericNas' indicates the Generic Network Attached Storage Protection
	// Source environment.
	// 'kAcropolis' indicates the Acropolis Protection Source environment.
	// 'kPhysicalFiles' indicates the Physical Files Protection Source environment.
	// 'kIbmFlashSystem' indicates the IBM Flash System Protection Source environment.
	// 'kIsilon' indicates the Dell EMC's Isilon Protection Source environment.
	// 'kGPFS' indicates IBM's GPFS Protection Source environment.
	// 'kKVM' indicates the KVM Protection Source environment.
	// 'kAWS' indicates the AWS Protection Source environment.
	// 'kExchange' indicates the Exchange Protection Source environment.
	// 'kHyperVVSS' indicates the HyperV VSS Protection Source
	// environment.
	// 'kOracle' indicates the Oracle Protection Source environment.
	// 'kGCP' indicates the Google Cloud Platform Protection Source environment.
	// 'kFlashBlade' indicates the Flash Blade Protection Source environment.
	// 'kAWSNative' indicates the AWS Native Protection Source environment.
	// 'kO365' indicates the Office 365 Protection Source environment.
	// 'kO365Outlook' indicates Office 365 outlook Protection Source environment.
	// 'kHyperFlex' indicates the Hyper Flex Protection Source environment.
	// 'kGCPNative' indicates the GCP Native Protection Source environment.
	// 'kAzureNative' indicates the Azure Native Protection Source environment.
	// 'kKubernetes' indicates a Kubernetes Protection Source environment.
	// 'kElastifile' indicates Elastifile Protection Source environment.
	// 'kAD' indicates Active Directory Protection Source environment.
	// 'kRDSSnapshotManager' indicates AWS RDS Protection Source environment.
	// 'kCassandra' indicates Cassandra Protection Source environment.
	// 'kMongoDB' indicates MongoDB Protection Source environment.
	// 'kCouchbase' indicates Couchbase Protection Source environment.
	// 'kHdfs' indicates Hdfs Protection Source environment.
	// 'kHive' indicates Hive Protection Source environment.
	// 'kHBase' indicates HBase Protection Source environment.
	// 'kUDA' indicates Universal Data Adapter Protection Source environment.
	// 'kSAPHANA' indicates SAP HANA protection source environment.
	// 'kO365Teams' indicates the Office365 Teams Protection Source environment.
	// 'kO365Group' indicates the Office365 Groups Protection Source environment.
	// 'kO365Exchange' indicates the Office365 Mailbox Protection Source environment.
	// 'kO365OneDrive' indicates the Office365 OneDrive Protection Source environment.
	// 'kO365Sharepoint' indicates the Office365 SharePoint Protection Source environment.
	// 'kO365PublicFolders' indicates the Office365 PublicFolders Protection Source environment.
	// kIbmFlashSystem, kAzure, kNetapp, kAgent, kGenericNas, kAcropolis,
	// kPhysicalFiles, kIsilon, kGPFS, kKVM, kAWS, kExchange, kHyperVVSS, kOracle,
	// kGCP, kFlashBlade, kAWSNative, kO365, kO365Outlook, kHyperFlex, kGCPNative,
	// kAzureNative, kKubernetes, kElastifile, kAD, kRDSSnapshotManager,
	// kCassandra, kMongoDB, kCouchbase, kHdfs, kHive, kHBase, kUDA, kSAPHANA,
	// kO365Teams, kO365Group, kO365Exchange, kO365OneDrive, kO365Sharepoint,
	// kO365PublicFolders
	// Enum: ["kVMware","kHyperV","kSQL","kView","kPuppeteer","kPhysical","kPure","kNimble"]
	Environment *string `json:"environment,omitempty"`

	// Specifies additional settings that are applicable to all Sources in
	// the Protection Job that are of specified environment type. For example,
	// you can specify to exclude a disk from backup for all 'kVMware'
	// Protection Sources in the Protection Job. If a setting conflicts with
	// sourceSpecialParameters, then sourceSpecialParameters will be used.
	EnvironmentParameters *EnvironmentTypeJobParameters `json:"environmentParameters,omitempty"`

	// Array of arrays of label IDs that specify labels to
	// exclude. Optionally specify a list of labels to exclude from
	// protecting by listing protection source ids of labels in this two
	// dimensional array. Using this two dimensional array of label IDs, the
	// Cluster generates a list of namespaces to exclude from protecting,
	// which are derived from intersections of the inner arrays
	// and union of the outer array.
	ExcludeLabelIds [][]int64 `json:"excludeLabelIds"`

	// Array of Excluded Source Objects.
	//
	// List of Object ids from a Protection Source that should not be
	// protected and are excluded from being backed up by the Protection Job.
	// Leaf and non-leaf Objects may be in this list and an Object in this list
	// must have an ancestor in the sourceId list.
	ExcludeSourceIds []int64 `json:"excludeSourceIds"`

	// Array of Arrays of VM Tag Ids that Specify VMs to Exclude.
	//
	// Optionally specify a list of VMs to exclude from protecting by listing
	// Protection Source ids of VM Tags in this two dimensional array.
	// Using this two dimensional array of Tag ids, the Cluster
	// generates a list of VMs to exclude from protecting,
	// which are derived from intersections of the inner arrays
	// and union of the outer array, as shown by the following example.
	// For example a Datacenter is selected to be protected but you want to
	// exclude all the 'Former Employees' VMs in the East and West but
	// keep all the VMs for 'Former Employees' in the South which are
	// also stored in this Datacenter, by specifying the
	// following tag id array:
	// [ [1000, 2221], [1000, 3031] ],
	// where 1000 is the 'Former Employee' VM Tag id,
	// 2221 is the 'East' VM Tag id and 3031 is the 'West' VM Tag id.
	// The first inner array [1000, 2221] produces a list of VMs that are
	// both tagged with 'Former Employees' and 'East' (an intersection).
	// The second inner array [1000, 3031] produces a list of VMs that are both
	// tagged with 'Former Employees' and 'West' (an intersection).
	// The outer array combines the list of VMs from the two inner
	// arrays. The list of resulting VMs are excluded from being protected
	// this Job.
	ExcludeVMTagIds [][]int64 `json:"excludeVmTagIds"`

	// If specified, this setting is number of minutes that a Job Run
	// of a Full (no CBT) backup schedule is expected to complete, which is
	// known as a Service-Level Agreement (SLA).
	// A SLA violation is reported when the run time of a Job Run exceeds
	// the SLA time period specified for this backup schedule.
	FullProtectionSLATimeMins *int64 `json:"fullProtectionSlaTimeMins,omitempty"`

	// Full (no CBT) Protection Schedule Start Time.
	//
	// Specifies the time of day to start the Full Protection Schedule.
	// This is optional and only applicable if the Protection Policy defines
	// a monthly or a daily Full (no CBT) Protection Schedule.
	// Default value is 02:00 AM.
	// deprecated: true
	FullProtectionStartTime struct {
		TimeOfDay
	} `json:"fullProtectionStartTime,omitempty"`

	// Specifies the errors which we can ignore from showing to the user.
	IgnorableErrorsInErrorDb []int32 `json:"ignorableErrorsInErrorDb"`

	// If specified, this setting is number of minutes that a Job Run
	// of a CBT-based backup schedule is expected to complete, which
	// is known as a Service-Level Agreement (SLA).
	// A SLA violation is reported when the run time of a Job Run exceeds
	// the SLA time period specified for this backup schedule.
	IncrementalProtectionSLATimeMins *int64 `json:"incrementalProtectionSlaTimeMins,omitempty"`

	// CBT-based Protection Schedule Start Time.
	//
	// Specifies the time of day to start the CBT-based Protection Schedule.
	// This is optional and only applicable if the Protection Policy defines
	// a monthly or a daily CBT-based Protection Schedule.
	// Default value is 02:00 AM.
	// deprecated: true
	IncrementalProtectionStartTime struct {
		TimeOfDay
	} `json:"incrementalProtectionStartTime,omitempty"`

	// Specifies the settings for indexing files found in an Object
	// (such as a VM) so these files can be searched and recovered.
	// In addition, it specifies inclusion and exclusion rules that determine
	// the directories to index.
	IndexingPolicy *IndexingPolicy `json:"indexingPolicy,omitempty"`

	// Specifies if this is a direct archive backup job.
	IsDirectArchiveEnabled *bool `json:"isDirectArchiveEnabled,omitempty"`

	// Specifies if native format should be used for archiving, applicable for
	// only direct archive jobs.
	IsNativeFormat *bool `json:"isNativeFormat,omitempty"`

	// Specifies if the Protection Job is paused, which means that no new
	// Job Runs are started but any existing Job Runs continue to execute.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Array of array of label IDs that specify labels to protect.
	// Optionally specify a list of labels to protect by listing
	// protection source ids of labels in this two dimensional array.
	// Using this two dimensional array of label IDs, the cluster
	// generates a list of namespaces to protect, which are derived from
	// intersections of the inner arrays and union of the outer array.
	LabelIds [][]int64 `json:"labelIds"`

	// Specifies whether to leverage nutanix API to take snapshots for this
	// backup job. To leverage nutanix snapshot a prism endpoint on which the
	// vcenter is registered as a management server has to be registered as a
	// source. If nutanix snapshot can not be taken, job will fall back to
	// default mode.
	LeverageNutanixSnapshots *bool `json:"leverageNutanixSnapshots,omitempty"`

	// If this field is set to true, then the backup for the objects will be
	// performed using dedicated storage area network (SAN) instead of LAN or
	// managment network.
	LeverageSanTransport *bool `json:"leverageSanTransport,omitempty"`

	// Specifies whether to leverage the storage array based snapshots for this
	// backup job. To leverage storage snapshots, the storage array has to be
	// registered as a source. If storage based snapshots can not be taken, job
	// will fallback to the default backup method.
	LeverageStorageSnapshots *bool `json:"leverageStorageSnapshots,omitempty"`

	// Specifies whether to leverage Hyperflex as the storage snapshot array
	LeverageStorageSnapshotsForHyperflex *bool `json:"leverageStorageSnapshotsForHyperflex,omitempty"`

	// If specified, this setting is number of minutes that a Job Run
	// of a Log backup schedule is expected to complete, which is
	// known as a Service-Level Agreement (SLA).
	// A SLA violation is reported when the run time of a Job Run exceeds
	// the SLA time period specified for this backup schedule.
	LogProtectionSLATimeMins *int64 `json:"logProtectionSlaTimeMins,omitempty"`

	// Specifies the last time this Job was updated.  If this is
	// passed into a PUT request, then the backend will validate that the
	// timestamp passed in matches the time that the protection group was
	// actually last modified. If the two timestamps do not match, then the
	// request will be rejected with a stale error.
	ModificationTimeUsecs *int64 `json:"modificationTimeUsecs,omitempty"`

	// Specifies the name of the Protection Job.
	// Required: true
	Name *string `json:"name"`

	// Specifies the id of the registered Protection Source that is the
	// parent of the Objects that may be protected by this Job.
	// For example when a vCenter Server is registered on a Cohesity Cluster,
	// the Cohesity Cluster assigns a unique id to this field that represents
	// the vCenter Server.
	ParentSourceID *int64 `json:"parentSourceId,omitempty"`

	// Specifies whether brick based dedupe should be performed or not.
	PerformBrickBasedDedup *bool `json:"performBrickBasedDedup,omitempty"`

	// Specifies whether source side dedupe should be performed or not.
	PerformSourceSideDedup *bool `json:"performSourceSideDedup,omitempty"`

	// Specifies the unique id of the Protection Policy associated with
	// the Protection Job. The Policy provides retry settings,
	// Protection Schedules, Priority, SLA, etc.
	// The Job defines the Storage Domain (View Box), the Objects to Protect
	// (if applicable), Start Time, Indexing settings, etc.
	// Required: true
	PolicyID *string `json:"policyId"`

	// Specifies the script associated with the backup job. This field must be
	// specified for 'kPhysical' jobs. This script will be executed post backup
	// run.
	PostBackupScript struct {
		BackupScript
	} `json:"postBackupScript,omitempty"`

	// Specifies the script associated with the backup job. This field must be
	// specified for 'kPhysical' jobs. This script will be executed pre backup
	// run. The 'remoteScript' field will be used for remote adapter jobs and
	// 'preBackupScript' field will be used for 'kPhysical' jobs.
	PreBackupScript struct {
		BackupScript
	} `json:"preBackupScript,omitempty"`

	// Specifies the priority of execution for a Protection Job.
	// Cohesity supports concurrent backups but if the number of Jobs exceeds
	// the ability to process Jobs, the specified priority determines the
	// execution Job priority.
	// This field also specifies the replication priority.
	// 'kLow' indicates lowest execution priority for a Protection job.
	// 'kMedium' indicates medium execution priority for a Protection job.
	// 'kHigh' indicates highest execution priority for a Protection job.
	// Enum: ["kLow","kMedium","kHigh"]
	Priority *string `json:"priority,omitempty"`

	// Specifies the QoS policy type to use for this Protection Job.
	// 'kBackupHDD' indicates the Cohesity Cluster writes data directly to
	// the HDD tier for this Protection Job. This is the recommended setting.
	// 'kBackupSSD' indicates the Cohesity Cluster writes data directly to
	// the SSD tier for this Protection Job. Only specify this policy if
	// you need fast ingest speed for a small number of Protection Jobs.
	// 'kTestAndDevHigh' indicated the test and dev workload.
	// 'kBackupAll' indicates the Cohesity Cluster writes data directly to
	// the HDD tier and the SSD tier for this Protection Job.
	// Enum: ["kBackupHDD","kBackupSSD","kTestAndDevHigh","kBackupAll"]
	QosType *string `json:"qosType,omitempty"`

	// Indicates if the App-Consistent option is enabled for this Job.
	// If the option is enabled, the Cohesity Cluster quiesces
	// the file system and applications before taking
	// Application-Consistent Snapshots. VMware Tools must be installed
	// on the guest Operating System.
	Quiesce *bool `json:"quiesce,omitempty"`

	// For a Remote Adapter 'kPuppeteer' Job, this field specifies the
	// settings about the remote script that will be executed by this Job.
	// Only specify this field for Remote Adapter 'kPuppeteer' Jobs.
	RemoteScript struct {
		RemoteJobScript
	} `json:"remoteScript,omitempty"`

	// Sepcifies the remote view names for the views that are being protected in
	// the view job. Use this field only when job has a replication policy.
	RemoteViewConfigList []*RemoteViewConfig `json:"remoteViewConfigList"`

	// Specifies the remote view name to use for view overwrite.
	// This field is deprecated. Remote view names will automatically be used
	// for all view jobs with replication policy. Use RemoteViewConfigList to
	// setup remote view names.
	// deprecated: true
	RemoteViewName *string `json:"remoteViewName,omitempty"`

	// Array of Protected Source Objects.
	//
	// Specifies the list of Object ids from the Protection Source to
	// protect (or back up) by the Protection Job.
	// An Object in this list may be descendant of another Object in this list.
	// For example a Datacenter could be selected but its child Host excluded.
	// However, a child VM under the Host could be explicitly
	// selected to be protected. Both the Datacenter and the VM are listed.
	SourceIds []int64 `json:"sourceIds"`

	// Array of Special Source Parameters.
	//
	// Specifies additional settings that can apply to a subset of the
	// Sources listed in the Protection Job. For example, you can specify a list
	// of files and folders to protect instead of protecting the entire Physical
	// Server. If this field's setting conflicts with environmentParameters,
	// then this setting will be used. Specific volume selections must be passed
	// in here to take effect.
	// Required: true
	SourceSpecialParameters []*SourceSpecialParameter `json:"sourceSpecialParameters"`

	// Array of Protected Source Objects.
	//
	// Specifies the list of Object ids along with Object names from the
	// Protection Source to protect (or back up) by the Protection Job.
	// Contains the one-to-one mapping of Source ids defined in "SourceIds" to
	// the corresponding Source names. Only one of Sources or SourceIds will be
	// returned depending on IncludeSourceNames. Sources will only be returned
	// when IncludeSourceNames is set to true and the environment is O365.
	Sources []*SourceInfo `json:"sources"`

	// Protection Schedule Start Time.
	//
	// Specifies the time of day to start the Protection Schedule.
	// This is optional and only applicable if the Protection Policy defines
	// a monthly or a daily Protection Schedule.
	// Default value is 02:00 AM.
	StartTime struct {
		TimeOfDay
	} `json:"startTime,omitempty"`

	// Specifies task level timeouts for a job.
	TaskTimeouts []*CancellationTimeoutParams `json:"taskTimeouts"`

	// Specifies the timezone to use when calculating time for this
	// Protection Job such as the Job start time.
	// Specify the timezone in the following format: "Area/Location",
	// for example: "America/New_York".
	Timezone *string `json:"timezone,omitempty"`

	// Tags associated with the job. User can specify tags/keywords that can
	// indexed by Yoda and can be later searched in UI. For example, user can
	// create a 'kPuppeteer' job to backup Oracle DB for 'payroll' department.
	// User can specify following tags: 'payroll', 'Oracle_DB'.
	UserSpecifiedTags []string `json:"userSpecifiedTags"`

	// Specifies the Storage Domain (View Box) id where this Job writes data.
	// Required: true
	ViewBoxID *int64 `json:"viewBoxId"`

	// For a Remote Adapter 'kPuppeteer' Job or a 'kView' Job, this field
	// specifies a View name that should be protected. Specify this field when
	// creating a Protection Job for the first time for a View. If this field
	// is specified, ParentSourceId, SourceIds, and ExcludeSourceIds should not
	// be specified.
	// This field is deprecated for view backups. Use sourceIds to specify list
	// of view ids instead.
	ViewName *string `json:"viewName,omitempty"`

	// Array of Arrays of VMs Tags Ids that Specify VMs to Protect.
	//
	// Optionally specify a list of VMs to protect by listing
	// Protection Source ids of VM Tags in this two dimensional array.
	// Using this two dimensional array of Tag ids, the Cluster
	// generates a list of VMs to protect which are derived from
	// intersections of the inner arrays and union of the outer array,
	// as shown by the following example.
	// To protect only 'Eng' VMs in the East and all the VMs in the West,
	// specify the following tag id array:
	// [ [1101, 2221], [3031] ],
	// where 1101 is the 'Eng' VM Tag id, 2221 is the 'East' VM Tag id and
	// 3031 is the 'West' VM Tag id. The inner array [1101, 2221] produces a
	// list of VMs that are both tagged with 'Eng' and 'East'
	// (an intersection). The outer array combines the list from the inner
	// array with list of VMs tagged with 'West' (a union). The list
	// of resulting VMs are protected by this Job.
	VMTagIds [][]int64 `json:"vmTagIds"`
}

// Validate validates this protection job request body
func (m *ProtectionJobRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertingConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataMigrationPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvironmentParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFullProtectionStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIncrementalProtectionStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePriority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQosType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteViewConfigList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceSpecialParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskTimeouts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewBoxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProtectionJobRequestBody) validateAlertingConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertingConfig) { // not required
		return nil
	}

	if m.AlertingConfig != nil {
		if err := m.AlertingConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertingConfig")
			}
			return err
		}
	}

	return nil
}

var protectionJobRequestBodyAlertingPolicyItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSuccess","kFailure","kSlaViolation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionJobRequestBodyAlertingPolicyItemsEnum = append(protectionJobRequestBodyAlertingPolicyItemsEnum, v)
	}
}

func (m *ProtectionJobRequestBody) validateAlertingPolicyItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionJobRequestBodyAlertingPolicyItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionJobRequestBody) validateAlertingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertingPolicy) { // not required
		return nil
	}

	for i := 0; i < len(m.AlertingPolicy); i++ {

		// value enum
		if err := m.validateAlertingPolicyItemsEnum("alertingPolicy"+"."+strconv.Itoa(i), "body", m.AlertingPolicy[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) validateCloudParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudParameters) { // not required
		return nil
	}

	if m.CloudParameters != nil {
		if err := m.CloudParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudParameters")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateDataMigrationPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DataMigrationPolicy) { // not required
		return nil
	}

	if m.DataMigrationPolicy != nil {
		if err := m.DataMigrationPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataMigrationPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataMigrationPolicy")
			}
			return err
		}
	}

	return nil
}

var protectionJobRequestBodyTypeEnvironmentPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kVMware","kHyperV","kSQL","kView","kPuppeteer","kPhysical","kPure","kNimble"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionJobRequestBodyTypeEnvironmentPropEnum = append(protectionJobRequestBodyTypeEnvironmentPropEnum, v)
	}
}

const (

	// ProtectionJobRequestBodyEnvironmentKVMware captures enum value "kVMware"
	ProtectionJobRequestBodyEnvironmentKVMware string = "kVMware"

	// ProtectionJobRequestBodyEnvironmentKHyperV captures enum value "kHyperV"
	ProtectionJobRequestBodyEnvironmentKHyperV string = "kHyperV"

	// ProtectionJobRequestBodyEnvironmentKSQL captures enum value "kSQL"
	ProtectionJobRequestBodyEnvironmentKSQL string = "kSQL"

	// ProtectionJobRequestBodyEnvironmentKView captures enum value "kView"
	ProtectionJobRequestBodyEnvironmentKView string = "kView"

	// ProtectionJobRequestBodyEnvironmentKPuppeteer captures enum value "kPuppeteer"
	ProtectionJobRequestBodyEnvironmentKPuppeteer string = "kPuppeteer"

	// ProtectionJobRequestBodyEnvironmentKPhysical captures enum value "kPhysical"
	ProtectionJobRequestBodyEnvironmentKPhysical string = "kPhysical"

	// ProtectionJobRequestBodyEnvironmentKPure captures enum value "kPure"
	ProtectionJobRequestBodyEnvironmentKPure string = "kPure"

	// ProtectionJobRequestBodyEnvironmentKNimble captures enum value "kNimble"
	ProtectionJobRequestBodyEnvironmentKNimble string = "kNimble"
)

// prop value enum
func (m *ProtectionJobRequestBody) validateEnvironmentEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionJobRequestBodyTypeEnvironmentPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionJobRequestBody) validateEnvironment(formats strfmt.Registry) error {
	if swag.IsZero(m.Environment) { // not required
		return nil
	}

	// value enum
	if err := m.validateEnvironmentEnum("environment", "body", *m.Environment); err != nil {
		return err
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateEnvironmentParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.EnvironmentParameters) { // not required
		return nil
	}

	if m.EnvironmentParameters != nil {
		if err := m.EnvironmentParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("environmentParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("environmentParameters")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateFullProtectionStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.FullProtectionStartTime) { // not required
		return nil
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateIncrementalProtectionStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.IncrementalProtectionStartTime) { // not required
		return nil
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateIndexingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IndexingPolicy) { // not required
		return nil
	}

	if m.IndexingPolicy != nil {
		if err := m.IndexingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ProtectionJobRequestBody) validatePolicyID(formats strfmt.Registry) error {

	if err := validate.Required("policyId", "body", m.PolicyID); err != nil {
		return err
	}

	return nil
}

func (m *ProtectionJobRequestBody) validatePostBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PostBackupScript) { // not required
		return nil
	}

	return nil
}

func (m *ProtectionJobRequestBody) validatePreBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PreBackupScript) { // not required
		return nil
	}

	return nil
}

var protectionJobRequestBodyTypePriorityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLow","kMedium","kHigh"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionJobRequestBodyTypePriorityPropEnum = append(protectionJobRequestBodyTypePriorityPropEnum, v)
	}
}

const (

	// ProtectionJobRequestBodyPriorityKLow captures enum value "kLow"
	ProtectionJobRequestBodyPriorityKLow string = "kLow"

	// ProtectionJobRequestBodyPriorityKMedium captures enum value "kMedium"
	ProtectionJobRequestBodyPriorityKMedium string = "kMedium"

	// ProtectionJobRequestBodyPriorityKHigh captures enum value "kHigh"
	ProtectionJobRequestBodyPriorityKHigh string = "kHigh"
)

// prop value enum
func (m *ProtectionJobRequestBody) validatePriorityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionJobRequestBodyTypePriorityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionJobRequestBody) validatePriority(formats strfmt.Registry) error {
	if swag.IsZero(m.Priority) { // not required
		return nil
	}

	// value enum
	if err := m.validatePriorityEnum("priority", "body", *m.Priority); err != nil {
		return err
	}

	return nil
}

var protectionJobRequestBodyTypeQosTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kBackupHDD","kBackupSSD","kTestAndDevHigh","kBackupAll"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionJobRequestBodyTypeQosTypePropEnum = append(protectionJobRequestBodyTypeQosTypePropEnum, v)
	}
}

const (

	// ProtectionJobRequestBodyQosTypeKBackupHDD captures enum value "kBackupHDD"
	ProtectionJobRequestBodyQosTypeKBackupHDD string = "kBackupHDD"

	// ProtectionJobRequestBodyQosTypeKBackupSSD captures enum value "kBackupSSD"
	ProtectionJobRequestBodyQosTypeKBackupSSD string = "kBackupSSD"

	// ProtectionJobRequestBodyQosTypeKTestAndDevHigh captures enum value "kTestAndDevHigh"
	ProtectionJobRequestBodyQosTypeKTestAndDevHigh string = "kTestAndDevHigh"

	// ProtectionJobRequestBodyQosTypeKBackupAll captures enum value "kBackupAll"
	ProtectionJobRequestBodyQosTypeKBackupAll string = "kBackupAll"
)

// prop value enum
func (m *ProtectionJobRequestBody) validateQosTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionJobRequestBodyTypeQosTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionJobRequestBody) validateQosType(formats strfmt.Registry) error {
	if swag.IsZero(m.QosType) { // not required
		return nil
	}

	// value enum
	if err := m.validateQosTypeEnum("qosType", "body", *m.QosType); err != nil {
		return err
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateRemoteScript(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteScript) { // not required
		return nil
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateRemoteViewConfigList(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteViewConfigList) { // not required
		return nil
	}

	for i := 0; i < len(m.RemoteViewConfigList); i++ {
		if swag.IsZero(m.RemoteViewConfigList[i]) { // not required
			continue
		}

		if m.RemoteViewConfigList[i] != nil {
			if err := m.RemoteViewConfigList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("remoteViewConfigList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("remoteViewConfigList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) validateSourceSpecialParameters(formats strfmt.Registry) error {

	if err := validate.Required("sourceSpecialParameters", "body", m.SourceSpecialParameters); err != nil {
		return err
	}

	for i := 0; i < len(m.SourceSpecialParameters); i++ {
		if swag.IsZero(m.SourceSpecialParameters[i]) { // not required
			continue
		}

		if m.SourceSpecialParameters[i] != nil {
			if err := m.SourceSpecialParameters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sourceSpecialParameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sourceSpecialParameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) validateSources(formats strfmt.Registry) error {
	if swag.IsZero(m.Sources) { // not required
		return nil
	}

	for i := 0; i < len(m.Sources); i++ {
		if swag.IsZero(m.Sources[i]) { // not required
			continue
		}

		if m.Sources[i] != nil {
			if err := m.Sources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	return nil
}

func (m *ProtectionJobRequestBody) validateTaskTimeouts(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskTimeouts) { // not required
		return nil
	}

	for i := 0; i < len(m.TaskTimeouts); i++ {
		if swag.IsZero(m.TaskTimeouts[i]) { // not required
			continue
		}

		if m.TaskTimeouts[i] != nil {
			if err := m.TaskTimeouts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taskTimeouts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taskTimeouts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) validateViewBoxID(formats strfmt.Registry) error {

	if err := validate.Required("viewBoxId", "body", m.ViewBoxID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this protection job request body based on the context it is used
func (m *ProtectionJobRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAlertingConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataMigrationPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnvironmentParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFullProtectionStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIncrementalProtectionStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIndexingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePostBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePreBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteViewConfigList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceSpecialParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaskTimeouts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProtectionJobRequestBody) contextValidateAlertingConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AlertingConfig != nil {

		if swag.IsZero(m.AlertingConfig) { // not required
			return nil
		}

		if err := m.AlertingConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertingConfig")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateCloudParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudParameters != nil {

		if swag.IsZero(m.CloudParameters) { // not required
			return nil
		}

		if err := m.CloudParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudParameters")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateDataMigrationPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.DataMigrationPolicy != nil {

		if swag.IsZero(m.DataMigrationPolicy) { // not required
			return nil
		}

		if err := m.DataMigrationPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataMigrationPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataMigrationPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateEnvironmentParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.EnvironmentParameters != nil {

		if swag.IsZero(m.EnvironmentParameters) { // not required
			return nil
		}

		if err := m.EnvironmentParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("environmentParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("environmentParameters")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateFullProtectionStartTime(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateIncrementalProtectionStartTime(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateIndexingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.IndexingPolicy != nil {

		if swag.IsZero(m.IndexingPolicy) { // not required
			return nil
		}

		if err := m.IndexingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidatePostBackupScript(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProtectionJobRequestBody) contextValidatePreBackupScript(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateRemoteScript(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateRemoteViewConfigList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RemoteViewConfigList); i++ {

		if m.RemoteViewConfigList[i] != nil {

			if swag.IsZero(m.RemoteViewConfigList[i]) { // not required
				return nil
			}

			if err := m.RemoteViewConfigList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("remoteViewConfigList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("remoteViewConfigList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateSourceSpecialParameters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SourceSpecialParameters); i++ {

		if m.SourceSpecialParameters[i] != nil {

			if swag.IsZero(m.SourceSpecialParameters[i]) { // not required
				return nil
			}

			if err := m.SourceSpecialParameters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sourceSpecialParameters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sourceSpecialParameters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Sources); i++ {

		if m.Sources[i] != nil {

			if swag.IsZero(m.Sources[i]) { // not required
				return nil
			}

			if err := m.Sources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateStartTime(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ProtectionJobRequestBody) contextValidateTaskTimeouts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaskTimeouts); i++ {

		if m.TaskTimeouts[i] != nil {

			if swag.IsZero(m.TaskTimeouts[i]) { // not required
				return nil
			}

			if err := m.TaskTimeouts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taskTimeouts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taskTimeouts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProtectionJobRequestBody) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProtectionJobRequestBody) UnmarshalBinary(b []byte) error {
	var res ProtectionJobRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
