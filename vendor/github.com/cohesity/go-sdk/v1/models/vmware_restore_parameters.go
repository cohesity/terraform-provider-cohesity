// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VmwareRestoreParameters VmWare Restore Parameters.
//
// Specifies the information required for recovering or cloning VmWare VMs.
//
// swagger:model VmwareRestoreParameters
type VmwareRestoreParameters struct {

	// Specifies additional datastores where the object should be recovered to.
	AdditionalDatastoreIds []int64 `json:"additionalDatastoreIds"`

	// Specifies whether to attempt differential restore.
	AttemptDifferentialRestore *bool `json:"attemptDifferentialRestore,omitempty"`

	// Specifies the folder where the restore datastore should be created.
	// This is applicable only when the VMs are being cloned.
	DatastoreFolderID *int64 `json:"datastoreFolderId,omitempty"`

	// Specifies the datastore where the object's files should be
	// recovered to.
	// This field is mandatory to recover objects to a different
	// resource pool or to a different parent source.
	// If not specified, objects are recovered to their
	// original datastore locations in the parent source.
	DatastoreID *int64 `json:"datastoreId,omitempty"`

	// Specifies whether the network should be detached from the
	// recovered or cloned VMs.
	DetachNetwork *bool `json:"detachNetwork,omitempty"`

	// Specifies whether the network should be left in disabled state.
	// Attached network is enabled by default. Set this flag to true to
	// disable it.
	DisableNetwork *bool `json:"disableNetwork,omitempty"`

	// Specifies a network configuration to be attached to the cloned or
	// recovered object.
	// For kCloneVMs and kRecoverVMs tasks, original network configuration
	// is detached if the cloned or recovered object is kept under a different
	// parent Protection Source or a different Resource Pool.
	// By default, for kRecoverVMs task, original network configuration is
	// preserved if the recovered object is kept under the same parent
	// Protection Source and the same Resource Pool.
	// Specify this field to override the preserved network configuration or
	// to attach a new network configuration to the cloned or recovered objects.
	// You can get the networkId of the kNetwork object by setting
	// includeNetworks to 'true' in the GET /public/protectionSources operation.
	// In the response, get the id of the desired kNetwork object, the resource
	// pool, and the registered parent Protection Source.
	NetworkID *int64 `json:"networkId,omitempty"`

	// Specifies the parameters for mapping the source and target
	// networks. This field can be used if restoring to a different
	// parent source.
	// This will replace the NetworkId and DisableNetwork that are
	// used to provide configuration for a single network. Unless the
	// support for mapping is available for all the entities old keys
	// can be used to attach a new network.
	// Supports 'kVMware' for now.
	NetworkMappings []*NetworkMapping `json:"networkMappings"`

	// Specifies the Org VDC Network to be used for this recovery.
	OrgVdcNetwork *OrgVdcNetworkParams `json:"orgVdcNetwork,omitempty"`

	// Specifies whether to overwrite the existing VM for a recovery when
	// rename parameters are not given.
	OverwriteExistingVM *bool `json:"overwriteExistingVm,omitempty"`

	// Specifies whether to power off and rename the existing VM as deprecated
	// for recovery when rename parameters are not given.
	PowerOffAndRenameExistingVM *bool `json:"powerOffAndRenameExistingVm,omitempty"`

	// Specifies the power state of the cloned or recovered objects.
	// By default, the cloned or recovered objects are powered off.
	PoweredOn *bool `json:"poweredOn,omitempty"`

	// Specifies a prefix to prepended to the source object name to derive a
	// new name for the recovered or cloned object.
	// By default, cloned or recovered objects retain their original name.
	// Length of this field is limited to 8 characters.
	Prefix *string `json:"prefix,omitempty"`

	// Specifies whether or not to preserve the custom attributes during the
	// clone operation. The default behavior is 'true'.
	PreserveCustomAttributesDuringClone *bool `json:"preserveCustomAttributesDuringClone,omitempty"`

	// Specifies whether to preserve mac address for the cloned/recovered
	// VM. This option is applicable only for alternate location recovery/clone
	// operation.
	PreserveMacAddress *bool `json:"preserveMacAddress,omitempty"`

	// Specifies whether or not to preserve tags during the clone operation. The
	// default behavior is 'true'.
	PreserveTags *bool `json:"preserveTags,omitempty"`

	// Specifies the type of recovery process to be performed. If unspecified,
	// then an instant recovery will be performed.
	// Specifies the recovery process type to be used..
	// 'kInstantRecovery' indicates that an instant recovery should be performed.
	// 'kCopyRecovery' indicates that a copy recovery should be performed.
	// Enum: ["kInstantRecovery","kCopyRecovery"]
	RecoveryProcessType *string `json:"recoveryProcessType,omitempty"`

	// Specifies the resource pool where the cloned or recovered objects are
	// attached. This field is mandatory for kCloneVMs Restore Tasks always.
	// For kRecoverVMs Restore Tasks, this field is mandatory only if
	// newParentId field is specified. If this field is not specified,
	// recovered objects are attached to the original resource pool under the
	// original parent.
	ResourcePoolID *int64 `json:"resourcePoolId,omitempty"`

	// Specifies the name of the destination storage profile while restoring to
	// an alternate VCD location.
	StorageProfileName *string `json:"storageProfileName,omitempty"`

	// Specifies the UUID of the storage profile while restoring to an alternate
	// VCD location.
	StorageProfileVcdUUID *string `json:"storageProfileVcdUuid,omitempty"`

	// Specifies a suffix to appended to the original source object name
	// to derive a new name for the recovered or cloned object.
	// By default, cloned or recovered objects retain their original name.
	// Length of this field is limited to 8 characters.
	Suffix *string `json:"suffix,omitempty"`

	// Specifies the ID of the vApp to which a VM should be restored.
	VAppID *int64 `json:"vAppId,omitempty"`

	// Specifies the ID of the VDC to which a VM should be restored.
	VdcID *int64 `json:"vdcId,omitempty"`

	// Specifies a folder where the VMs should be restored. This is applicable
	// only when the VMs are being restored to an alternate location or if clone
	// is being performed.
	VMFolderID *int64 `json:"vmFolderId,omitempty"`
}

// Validate validates this vmware restore parameters
func (m *VmwareRestoreParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrgVdcNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecoveryProcessType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VmwareRestoreParameters) validateNetworkMappings(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkMappings) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkMappings); i++ {
		if swag.IsZero(m.NetworkMappings[i]) { // not required
			continue
		}

		if m.NetworkMappings[i] != nil {
			if err := m.NetworkMappings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkMappings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("networkMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VmwareRestoreParameters) validateOrgVdcNetwork(formats strfmt.Registry) error {
	if swag.IsZero(m.OrgVdcNetwork) { // not required
		return nil
	}

	if m.OrgVdcNetwork != nil {
		if err := m.OrgVdcNetwork.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orgVdcNetwork")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("orgVdcNetwork")
			}
			return err
		}
	}

	return nil
}

var vmwareRestoreParametersTypeRecoveryProcessTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kInstantRecovery","kCopyRecovery"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vmwareRestoreParametersTypeRecoveryProcessTypePropEnum = append(vmwareRestoreParametersTypeRecoveryProcessTypePropEnum, v)
	}
}

const (

	// VmwareRestoreParametersRecoveryProcessTypeKInstantRecovery captures enum value "kInstantRecovery"
	VmwareRestoreParametersRecoveryProcessTypeKInstantRecovery string = "kInstantRecovery"

	// VmwareRestoreParametersRecoveryProcessTypeKCopyRecovery captures enum value "kCopyRecovery"
	VmwareRestoreParametersRecoveryProcessTypeKCopyRecovery string = "kCopyRecovery"
)

// prop value enum
func (m *VmwareRestoreParameters) validateRecoveryProcessTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vmwareRestoreParametersTypeRecoveryProcessTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VmwareRestoreParameters) validateRecoveryProcessType(formats strfmt.Registry) error {
	if swag.IsZero(m.RecoveryProcessType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecoveryProcessTypeEnum("recoveryProcessType", "body", *m.RecoveryProcessType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this vmware restore parameters based on the context it is used
func (m *VmwareRestoreParameters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateNetworkMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrgVdcNetwork(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VmwareRestoreParameters) contextValidateNetworkMappings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkMappings); i++ {

		if m.NetworkMappings[i] != nil {

			if swag.IsZero(m.NetworkMappings[i]) { // not required
				return nil
			}

			if err := m.NetworkMappings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkMappings" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("networkMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VmwareRestoreParameters) contextValidateOrgVdcNetwork(ctx context.Context, formats strfmt.Registry) error {

	if m.OrgVdcNetwork != nil {

		if swag.IsZero(m.OrgVdcNetwork) { // not required
			return nil
		}

		if err := m.OrgVdcNetwork.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orgVdcNetwork")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("orgVdcNetwork")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VmwareRestoreParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VmwareRestoreParameters) UnmarshalBinary(b []byte) error {
	var res VmwareRestoreParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
