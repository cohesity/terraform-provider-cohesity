// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// BackupJobPreOrPostScript A message to encapsulate the pre and post scripts associated with a backup
// job. Pre script is executed before backup run of a job starts. Post script
// is executed after backup run of a job finishes.
// Currently, pre and post script is only supported for backup job of type
// 'kPuppeteer' and agent-based backup jobs.
//
// swagger:model BackupJobPreOrPostScript
type BackupJobPreOrPostScript struct {

	// Script specific to the incremental/regular backup. If the script is not
	// specified, incremental backup run will fail.
	// For agent-based backup jobs, only following script is considered. The
	// script file will be looked in the agent installation directory. If the
	// file is not present, then it will be logged in Pulse and backup job
	// continues without throwing any error/warning.
	BackupScript *ScriptPathAndParams `json:"backupScript,omitempty"`

	// Script specific to the full backup. If the script is not specified, full
	// backup run will fail.
	FullBackupScript *ScriptPathAndParams `json:"fullBackupScript,omitempty"`

	// Script specific to the log backup. If the script is not specified, log
	// backup run will fail.
	LogBackupScript *ScriptPathAndParams `json:"logBackupScript,omitempty"`

	// Connector params for the host on which script is executed. This field is
	// mandatory for job of type kPuppeteer and optional for other job types.
	RemoteHostParams *RemoteHostConnectorParams `json:"remoteHostParams,omitempty"`
}

// Validate validates this backup job pre or post script
func (m *BackupJobPreOrPostScript) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFullBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteHostParams(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobPreOrPostScript) validateBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupScript) { // not required
		return nil
	}

	if m.BackupScript != nil {
		if err := m.BackupScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobPreOrPostScript) validateFullBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.FullBackupScript) { // not required
		return nil
	}

	if m.FullBackupScript != nil {
		if err := m.FullBackupScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fullBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fullBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobPreOrPostScript) validateLogBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.LogBackupScript) { // not required
		return nil
	}

	if m.LogBackupScript != nil {
		if err := m.LogBackupScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobPreOrPostScript) validateRemoteHostParams(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteHostParams) { // not required
		return nil
	}

	if m.RemoteHostParams != nil {
		if err := m.RemoteHostParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteHostParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteHostParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup job pre or post script based on the context it is used
func (m *BackupJobPreOrPostScript) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFullBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteHostParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobPreOrPostScript) contextValidateBackupScript(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupScript != nil {

		if swag.IsZero(m.BackupScript) { // not required
			return nil
		}

		if err := m.BackupScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobPreOrPostScript) contextValidateFullBackupScript(ctx context.Context, formats strfmt.Registry) error {

	if m.FullBackupScript != nil {

		if swag.IsZero(m.FullBackupScript) { // not required
			return nil
		}

		if err := m.FullBackupScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fullBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fullBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobPreOrPostScript) contextValidateLogBackupScript(ctx context.Context, formats strfmt.Registry) error {

	if m.LogBackupScript != nil {

		if swag.IsZero(m.LogBackupScript) { // not required
			return nil
		}

		if err := m.LogBackupScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobPreOrPostScript) contextValidateRemoteHostParams(ctx context.Context, formats strfmt.Registry) error {

	if m.RemoteHostParams != nil {

		if swag.IsZero(m.RemoteHostParams) { // not required
			return nil
		}

		if err := m.RemoteHostParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteHostParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteHostParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupJobPreOrPostScript) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupJobPreOrPostScript) UnmarshalBinary(b []byte) error {
	var res BackupJobPreOrPostScript
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
