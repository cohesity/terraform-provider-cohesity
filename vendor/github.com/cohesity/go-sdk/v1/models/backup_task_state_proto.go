// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// BackupTaskStateProto Persistent state for a single task. This could either be incremental, or the
// full-state of a task.
//
// swagger:model BackupTaskStateProto
type BackupTaskStateProto struct {

	// Denotes the target for action executor(Bridge / BridgeProxy) on which task
	// on slave should execute actions.
	ActionExecutorTargetType *int32 `json:"actionExecutorTargetType,omitempty"`

	// Adapters can utilize this field to establish initial flags for backup
	// operations. For instance, if a critical decision must be maintained
	// consistently throughout the entire backup task, Adapters can use this
	// field to set and persist relevant information at the start of the backup.
	AdapterSpecificFlags *AdapterSpecificFlagsProto `json:"adapterSpecificFlags,omitempty"`

	// Any environment specific additional parameters associated with a backup
	// task.
	AdditionalParams *BackupTaskAdditionalParams `json:"additionalParams,omitempty"`

	// The incarnation id of the agent assigned to this task. If -1, the agent
	// incarnation id hasn't been assigned yet.
	AgentIncarnationID *int64 `json:"agentIncarnationId,omitempty"`

	// The state of application specific entities (if any) that are being
	// backed up by this task. Note that this is populated for Iris on the fly.
	AppEntityStateVec []*AppEntityState `json:"appEntityStateVec"`

	// True if the backed up data has been verified. Only valid if the status of
	// the task is kFinished.
	BackupVerified *bool `json:"backupVerified,omitempty"`

	// Vector of BackupViewInfo to hold view names for each entity being backed
	// up in this Backup Task.
	BackupViewInfoVec []*BackupTaskStateProtoBackupViewInfo `json:"backupViewInfoVec"`

	// Contains basic information about the backup task.
	Base *BackupJobTaskStateBaseProto `json:"base,omitempty"`

	// Contains information about the snapshot that should be used by the current
	// task to backup the source entity.
	CurrentSnapshotInfo *SnapshotInfoProto `json:"currentSnapshotInfo,omitempty"`

	// Stats for each of the entities that was backed up in this task. Key is the
	// entity id. This map will include all types of entities (ex: app entities
	// for database backups).
	//
	// Note that this map is required to contain all the leaf level entities
	// that are backed up. Non-leaf level entities can be included when there is
	// no ambiguity (in cases where hierarchy rooted a non-leaf entity is a tree
	// and not a DAG).
	EntityBackupStats interface{} `json:"entityBackupStats,omitempty"`

	// in progress state
	InProgressState *BackupTaskStateProtoInProgressTaskStateProto `json:"inProgressState,omitempty"`

	// Whether to limit resource hogging by a single task.
	// If set, permit on dummy entity is requested to limit resource hogging.
	// Due to the flag controlled limit in the number of these
	// permits, number of parallel subtasks can be controlled, in turn limiting
	// resource hogging by one large task.
	// This field can be deprecated once fairness is introduced in resource
	// manager.
	// Note: This is only applicable to VMWare for now.
	LimitResourceHoggingBySingleTask *bool `json:"limitResourceHoggingBySingleTask,omitempty"`

	// The registered vCenter or ESXi host under which the source corresponding
	// to this backup task is running.
	ParentSource *PrivateEntityProto `json:"parentSource,omitempty"`

	// Contains  backed up size of base.sources(0) by last successful task.
	PreviousBackupSize *int64 `json:"previousBackupSize,omitempty"`

	// Start time of the job that created the snapshot in the above
	// 'previous_snapshot_info'.
	PreviousRunStartTimeUsecs *int64 `json:"previousRunStartTimeUsecs,omitempty"`

	// Contains information about the snapshot used by the last task that
	// successfully backed up base.sources(0).
	PreviousSnapshotInfo *SnapshotInfoProto `json:"previousSnapshotInfo,omitempty"`

	// The job from which the previous snapshot information is taken.
	PreviousSnapshotJobUID *UniversalIDProto `json:"previousSnapshotJobUid,omitempty"`

	// The name of the QoS principal to use when backing up data.
	QosPrincipalName *string `json:"qosPrincipalName,omitempty"`

	// Records whether querying changed blocks failed.
	QueryChangedBlocksError *bool `json:"queryChangedBlocksError,omitempty"`

	// If a newer successful snapshot for the source is available than the one
	// that was selected during run creation, consider reselecting the previous
	// snapshot. It's possible that during the creation of the initial run, there
	// was an ongoing previous run that wasn't taken into account. However, by
	// the time this task was scheduled, the previous run had been successfully
	// completed, making it a viable option for selection.
	ReconsiderChosenPrevSnapshot *bool `json:"reconsiderChosenPrevSnapshot,omitempty"`

	// If this backup task was received via an incoming replication from another
	// cluster, and the replication failed with an error, this field will contain
	// the details of the replication error. If this field is set, the snapshots
	// for the sources may not exist on SnapFS, and hence this task should be
	// considered as failed task.
	RxReplicationError *PrivateErrorProto `json:"rxReplicationError,omitempty"`

	// Records whether utilizing SAN transport failed.
	SanTransportError *bool `json:"sanTransportError,omitempty"`

	// Constituent id (and the gandalf session id) where this task has been
	// scheduled. If -1, the task is not running at any slave. It's possible
	// that the task was previously scheduled, but is now being re-scheduled.
	ScheduledConstituentID *int64 `json:"scheduledConstituentId,omitempty"`

	// scheduled gandalf session Id
	ScheduledGandalfSessionID *int64 `json:"scheduledGandalfSessionId,omitempty"`

	// Denotes the setting type of whether the slave task stores its checkpoint
	// state in scribe.
	SlaveTaskStateInScribeSetting *int32 `json:"slaveTaskStateInScribeSetting,omitempty"`

	// Whether the local snapshot for the task has been deleted.
	SnapshotDeleted *bool `json:"snapshotDeleted,omitempty"`

	// Contains delta changes to the snapshot for the current task. Only one of
	// current_snapshot_info and snapshot_delta can be set in the
	// BackupSnapshotProto in a persistent record.
	SnapshotDelta SnapshotDeltaProto `json:"snapshotDelta,omitempty"`

	// Vector of SnapshotViewInfo to hold view names for each entity being backed
	// up in this Backup Task.
	SnapshotViewInfoVec []*BackupTaskStateProtoSnapshotViewInfo `json:"snapshotViewInfoVec"`

	// An optional space usage policy configured while registering the entity.
	SpaceUsagePolicy *SpaceUsagePolicy `json:"spaceUsagePolicy,omitempty"`

	// The container id that stats for this task should be written to. This
	// container records total physical bytes written for the task.
	StatsContainerID *int64 `json:"statsContainerId,omitempty"`

	// Contains the info about the storage snapshot of an entity. 'error' field
	// within this proto should be used to determine whether the storage snapshot
	// succeeded or not. If not, regular method should be used to backup the
	// entity.
	StorageSnapshotInfo *EntitySnapshotInfoProto `json:"storageSnapshotInfo,omitempty"`

	// A cluster wide unique task instance id for a task (under a job).
	TaskID *int64 `json:"taskId,omitempty"`

	// This value is incremented when a task is restarted on a slave when the
	// backup source host changes.
	// TODO(gaurav): Deprecate this field after all clusters have migrated to
	// 5.1.
	TaskVersion *int32 `json:"taskVersion,omitempty"`

	// A way to connect to the source (vCenter managing the VM in case of VMware
	// VMs).
	TransientConnectorParams *ConnectorParams `json:"transientConnectorParams,omitempty"`

	// The datacenter under which the VM corresponding to this backup task is
	// located. This is set only for the VMware env.
	TransientDatacenterEntity *PrivateEntityProto `json:"transientDatacenterEntity,omitempty"`

	// The host on which the source corresponding to this backup task is
	// currently known to be running (for example, an ESXi host in a VMware
	// environment).
	TransientHostEntity *PrivateEntityProto `json:"transientHostEntity,omitempty"`

	// A way to connect to the VCD source. It is only populated in VCD
	// environment.
	TransientVcdConnectorParams *ConnectorParams `json:"transientVcdConnectorParams,omitempty"`

	// Whether to use the UUID of the virtual disk when computing its encoded
	// filename.
	// NOTE: This is only applicable in a VMware environment.
	UseUUIDForEncodedFilename *bool `json:"useUuidForEncodedFilename,omitempty"`

	// Whether to use the UUID of the virtual disk when matching it with a
	// virtual disk of the previous snapshot.
	// NOTE: This is only applicable in a VMware environment.
	UseUUIDToMatchPreviousVmdk *bool `json:"useUuidToMatchPreviousVmdk,omitempty"`

	// If populated, Contains info on the vApp this entity belongs to.
	// Note: This is populated only for environments of type kvCloudDirector.
	VappInfo *BackupTaskStateVappInfoProto `json:"vappInfo,omitempty"`
}

// Validate validates this backup task state proto
func (m *BackupTaskStateProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdapterSpecificFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdditionalParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppEntityStateVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupViewInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentSnapshotInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInProgressState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreviousSnapshotInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreviousSnapshotJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRxReplicationError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotViewInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpaceUsagePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageSnapshotInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransientConnectorParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransientDatacenterEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransientHostEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransientVcdConnectorParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVappInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupTaskStateProto) validateAdapterSpecificFlags(formats strfmt.Registry) error {
	if swag.IsZero(m.AdapterSpecificFlags) { // not required
		return nil
	}

	if m.AdapterSpecificFlags != nil {
		if err := m.AdapterSpecificFlags.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adapterSpecificFlags")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("adapterSpecificFlags")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateAdditionalParams(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalParams) { // not required
		return nil
	}

	if m.AdditionalParams != nil {
		if err := m.AdditionalParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateAppEntityStateVec(formats strfmt.Registry) error {
	if swag.IsZero(m.AppEntityStateVec) { // not required
		return nil
	}

	for i := 0; i < len(m.AppEntityStateVec); i++ {
		if swag.IsZero(m.AppEntityStateVec[i]) { // not required
			continue
		}

		if m.AppEntityStateVec[i] != nil {
			if err := m.AppEntityStateVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("appEntityStateVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("appEntityStateVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupTaskStateProto) validateBackupViewInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupViewInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.BackupViewInfoVec); i++ {
		if swag.IsZero(m.BackupViewInfoVec[i]) { // not required
			continue
		}

		if m.BackupViewInfoVec[i] != nil {
			if err := m.BackupViewInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backupViewInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backupViewInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupTaskStateProto) validateBase(formats strfmt.Registry) error {
	if swag.IsZero(m.Base) { // not required
		return nil
	}

	if m.Base != nil {
		if err := m.Base.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("base")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("base")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateCurrentSnapshotInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentSnapshotInfo) { // not required
		return nil
	}

	if m.CurrentSnapshotInfo != nil {
		if err := m.CurrentSnapshotInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currentSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("currentSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateInProgressState(formats strfmt.Registry) error {
	if swag.IsZero(m.InProgressState) { // not required
		return nil
	}

	if m.InProgressState != nil {
		if err := m.InProgressState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inProgressState")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("inProgressState")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateParentSource(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentSource) { // not required
		return nil
	}

	if m.ParentSource != nil {
		if err := m.ParentSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parentSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parentSource")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validatePreviousSnapshotInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.PreviousSnapshotInfo) { // not required
		return nil
	}

	if m.PreviousSnapshotInfo != nil {
		if err := m.PreviousSnapshotInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("previousSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("previousSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validatePreviousSnapshotJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.PreviousSnapshotJobUID) { // not required
		return nil
	}

	if m.PreviousSnapshotJobUID != nil {
		if err := m.PreviousSnapshotJobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("previousSnapshotJobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("previousSnapshotJobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateRxReplicationError(formats strfmt.Registry) error {
	if swag.IsZero(m.RxReplicationError) { // not required
		return nil
	}

	if m.RxReplicationError != nil {
		if err := m.RxReplicationError.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rxReplicationError")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rxReplicationError")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateSnapshotViewInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotViewInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.SnapshotViewInfoVec); i++ {
		if swag.IsZero(m.SnapshotViewInfoVec[i]) { // not required
			continue
		}

		if m.SnapshotViewInfoVec[i] != nil {
			if err := m.SnapshotViewInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshotViewInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshotViewInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupTaskStateProto) validateSpaceUsagePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.SpaceUsagePolicy) { // not required
		return nil
	}

	if m.SpaceUsagePolicy != nil {
		if err := m.SpaceUsagePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spaceUsagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spaceUsagePolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateStorageSnapshotInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageSnapshotInfo) { // not required
		return nil
	}

	if m.StorageSnapshotInfo != nil {
		if err := m.StorageSnapshotInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storageSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storageSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateTransientConnectorParams(formats strfmt.Registry) error {
	if swag.IsZero(m.TransientConnectorParams) { // not required
		return nil
	}

	if m.TransientConnectorParams != nil {
		if err := m.TransientConnectorParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientConnectorParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientConnectorParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateTransientDatacenterEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.TransientDatacenterEntity) { // not required
		return nil
	}

	if m.TransientDatacenterEntity != nil {
		if err := m.TransientDatacenterEntity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientDatacenterEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientDatacenterEntity")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateTransientHostEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.TransientHostEntity) { // not required
		return nil
	}

	if m.TransientHostEntity != nil {
		if err := m.TransientHostEntity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientHostEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientHostEntity")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateTransientVcdConnectorParams(formats strfmt.Registry) error {
	if swag.IsZero(m.TransientVcdConnectorParams) { // not required
		return nil
	}

	if m.TransientVcdConnectorParams != nil {
		if err := m.TransientVcdConnectorParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientVcdConnectorParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientVcdConnectorParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) validateVappInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VappInfo) { // not required
		return nil
	}

	if m.VappInfo != nil {
		if err := m.VappInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vappInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vappInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup task state proto based on the context it is used
func (m *BackupTaskStateProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdapterSpecificFlags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdditionalParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAppEntityStateVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupViewInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrentSnapshotInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInProgressState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePreviousSnapshotInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePreviousSnapshotJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRxReplicationError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotViewInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpaceUsagePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageSnapshotInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransientConnectorParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransientDatacenterEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransientHostEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransientVcdConnectorParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVappInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupTaskStateProto) contextValidateAdapterSpecificFlags(ctx context.Context, formats strfmt.Registry) error {

	if m.AdapterSpecificFlags != nil {

		if swag.IsZero(m.AdapterSpecificFlags) { // not required
			return nil
		}

		if err := m.AdapterSpecificFlags.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adapterSpecificFlags")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("adapterSpecificFlags")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateAdditionalParams(ctx context.Context, formats strfmt.Registry) error {

	if m.AdditionalParams != nil {

		if swag.IsZero(m.AdditionalParams) { // not required
			return nil
		}

		if err := m.AdditionalParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateAppEntityStateVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AppEntityStateVec); i++ {

		if m.AppEntityStateVec[i] != nil {

			if swag.IsZero(m.AppEntityStateVec[i]) { // not required
				return nil
			}

			if err := m.AppEntityStateVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("appEntityStateVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("appEntityStateVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateBackupViewInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BackupViewInfoVec); i++ {

		if m.BackupViewInfoVec[i] != nil {

			if swag.IsZero(m.BackupViewInfoVec[i]) { // not required
				return nil
			}

			if err := m.BackupViewInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backupViewInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backupViewInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateBase(ctx context.Context, formats strfmt.Registry) error {

	if m.Base != nil {

		if swag.IsZero(m.Base) { // not required
			return nil
		}

		if err := m.Base.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("base")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("base")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateCurrentSnapshotInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CurrentSnapshotInfo != nil {

		if swag.IsZero(m.CurrentSnapshotInfo) { // not required
			return nil
		}

		if err := m.CurrentSnapshotInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currentSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("currentSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateInProgressState(ctx context.Context, formats strfmt.Registry) error {

	if m.InProgressState != nil {

		if swag.IsZero(m.InProgressState) { // not required
			return nil
		}

		if err := m.InProgressState.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inProgressState")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("inProgressState")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateParentSource(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentSource != nil {

		if swag.IsZero(m.ParentSource) { // not required
			return nil
		}

		if err := m.ParentSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parentSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parentSource")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidatePreviousSnapshotInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.PreviousSnapshotInfo != nil {

		if swag.IsZero(m.PreviousSnapshotInfo) { // not required
			return nil
		}

		if err := m.PreviousSnapshotInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("previousSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("previousSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidatePreviousSnapshotJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.PreviousSnapshotJobUID != nil {

		if swag.IsZero(m.PreviousSnapshotJobUID) { // not required
			return nil
		}

		if err := m.PreviousSnapshotJobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("previousSnapshotJobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("previousSnapshotJobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateRxReplicationError(ctx context.Context, formats strfmt.Registry) error {

	if m.RxReplicationError != nil {

		if swag.IsZero(m.RxReplicationError) { // not required
			return nil
		}

		if err := m.RxReplicationError.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rxReplicationError")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rxReplicationError")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateSnapshotViewInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SnapshotViewInfoVec); i++ {

		if m.SnapshotViewInfoVec[i] != nil {

			if swag.IsZero(m.SnapshotViewInfoVec[i]) { // not required
				return nil
			}

			if err := m.SnapshotViewInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshotViewInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshotViewInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateSpaceUsagePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.SpaceUsagePolicy != nil {

		if swag.IsZero(m.SpaceUsagePolicy) { // not required
			return nil
		}

		if err := m.SpaceUsagePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spaceUsagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spaceUsagePolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateStorageSnapshotInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageSnapshotInfo != nil {

		if swag.IsZero(m.StorageSnapshotInfo) { // not required
			return nil
		}

		if err := m.StorageSnapshotInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storageSnapshotInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storageSnapshotInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateTransientConnectorParams(ctx context.Context, formats strfmt.Registry) error {

	if m.TransientConnectorParams != nil {

		if swag.IsZero(m.TransientConnectorParams) { // not required
			return nil
		}

		if err := m.TransientConnectorParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientConnectorParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientConnectorParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateTransientDatacenterEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.TransientDatacenterEntity != nil {

		if swag.IsZero(m.TransientDatacenterEntity) { // not required
			return nil
		}

		if err := m.TransientDatacenterEntity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientDatacenterEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientDatacenterEntity")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateTransientHostEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.TransientHostEntity != nil {

		if swag.IsZero(m.TransientHostEntity) { // not required
			return nil
		}

		if err := m.TransientHostEntity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientHostEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientHostEntity")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateTransientVcdConnectorParams(ctx context.Context, formats strfmt.Registry) error {

	if m.TransientVcdConnectorParams != nil {

		if swag.IsZero(m.TransientVcdConnectorParams) { // not required
			return nil
		}

		if err := m.TransientVcdConnectorParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transientVcdConnectorParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transientVcdConnectorParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupTaskStateProto) contextValidateVappInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.VappInfo != nil {

		if swag.IsZero(m.VappInfo) { // not required
			return nil
		}

		if err := m.VappInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vappInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vappInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupTaskStateProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupTaskStateProto) UnmarshalBinary(b []byte) error {
	var res BackupTaskStateProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
