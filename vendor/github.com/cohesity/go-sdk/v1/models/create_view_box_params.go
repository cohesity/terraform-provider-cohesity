// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateViewBoxParams Storage Domain (View Box) Request.
//
// Provides details about the Storage Domain (View Box).
//
// swagger:model CreateViewBoxParams
type CreateViewBoxParams struct {

	// Specifies an active directory domain that this view box is mapped to.
	AdDomainName *string `json:"adDomainName,omitempty"`

	// Specifies the default brick size used by the viewbox.
	BrickSize *int32 `json:"brickSize,omitempty"`

	// Array of Subnets.
	//
	// Specifies the Subnets from which this Storage Domain (View Box) accepts
	// requests.
	ClientSubnetWhiteList []*Subnet `json:"clientSubnetWhiteList"`

	// Specifies the cloud down water-fall threshold percentage. This indicates
	// how full should a viewbox at least be before we down water-fall its data
	// to cloud tier. If this field is set, the physical quota limit must be set
	// also and will be used as viewbox capacity.
	CloudDownWaterfallThresholdPct *int32 `json:"cloudDownWaterfallThresholdPct,omitempty"`

	// Specifies the cloud down water-fall threshold seconds. This indicates
	// what's the time threshold on water-falling data to cloud tier.
	CloudDownWaterfallThresholdSecs *int32 `json:"cloudDownWaterfallThresholdSecs,omitempty"`

	// Specifies the Cluster Partition id where the Storage Domain (View Box) is
	// located.
	// Required: true
	ClusterPartitionID *int64 `json:"clusterPartitionId"`

	// Specifies an optional quota policy/limits that are inherited by all users
	// within the views in this viewbox.
	DefaultUserQuotaPolicy struct {
		QuotaPolicy
	} `json:"defaultUserQuotaPolicy,omitempty"`

	// Specifies an optional default logical quota limit (in bytes)
	// for the Views in this Storage Domain (View Box).
	// (Logical data is when the data is fully hydrated and expanded.)
	// However, this inherited quota can be overwritten at the View level.
	// A new write is not allowed if the Storage Domain (View Box) will exceed
	// the specified quota.
	// However, it takes time for the Cohesity Cluster to calculate
	// the usage across Nodes, so the limit may be exceeded by a small amount.
	// In addition, if the limit is increased or data is removed,
	// there may be delay before the Cohesity Cluster allows more data
	// to be written to the Storage Domain (View Box), as the Cluster is
	// calculating the usage across Nodes.
	DefaultViewQuotaPolicy struct {
		QuotaPolicy
	} `json:"defaultViewQuotaPolicy,omitempty"`

	// Specifies whether DEK(Data Encryption Key) rotation is enabled for this
	// viewbox. This is applicable only when the viewbox uses AWS or similar KMS
	// in which the KEK (Key Encryption Key) is not created and maintained by
	// Cohesity. For Internal KMS and keys stored in Safenet servers, DEK
	// rotation will not be performed.
	DekRotationEnabled *bool `json:"dekRotationEnabled,omitempty"`

	// Specifies whether this viewbox can be used as a staging area while copying
	// a largedataset that can't fit on the cluster to an external target. The
	// amount of data that can be stored on the viewbox can be specified using
	// 'physical_quota'.
	DirectArchiveEnabled *bool `json:"directArchiveEnabled,omitempty"`

	// Specifies the Kerberos domain that this view box is mapped to.
	KerberosRealmName *string `json:"kerberosRealmName,omitempty"`

	// Specifies the associated KMS Server ID.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// When set, the following provides the LDAP provider the view box is
	// mapped to. For any view from this view box, when accessed via NFS the
	// following LDAP provider is looked up for getting Unix IDs of the
	// corresponding user. Similarly, when a view is accessed via SMB and if
	// the AD user's domain matches with the view box's AD, the following LDAP
	// provider will be used to lookup Unix IDs for the corresponding AD user.
	// Additionally there is also a mapping between LDAP provider and AD domain
	// that is stored in AD provider config. It will be used if AD is not set
	// on the view box.
	LdapProviderID *int64 `json:"ldapProviderId,omitempty"`

	// Specifies the name of the Storage Domain (View Box).
	// Required: true
	Name *string `json:"name"`

	// Specifies the NIS domain that this view box is mapped to.
	NisDomainNameVec []string `json:"nisDomainNameVec"`

	// Specifies an optional quota limit (in bytes) for the physical
	// usage of this Storage Domain (View Box).
	// This quota limit defines a physical limit for size of the data that
	// can be physically stored on the Storage Domain (View Box), after the data
	// has been reduced by change block tracking, compression and deduplication.
	// The physical usage is the aggregate sum of the data stored for this
	// Storage Domain (View Box) on all disks in the Cluster.
	// (The usage includes Cloud Tier data and user data.)
	// A new write is not allowed if the Storage Domain (View Box) will exceed
	// the specified quota. However, it takes time for the Cohesity Cluster to
	// calculate the usage across Nodes, so the limit may be exceeded by a small
	// amount. In addition, if the limit is increased or data is removed,
	// there may be a delay before the Cohesity Cluster allows more data
	// to be written to the Storage Domain (View Box), as the Cluster is
	// calculating the usage across Nodes.
	PhysicalQuota struct {
		QuotaPolicy
	} `json:"physicalQuota,omitempty"`

	// Specifies whether creation of a S3 bucket is allowed in this
	// Storage Domain (View Box).
	// When a new S3 bucket creation request arrives, we'll look at all the View
	// Boxes and the first Storage Domain (View Box) that allows creating S3
	// buckets in it will be the one where the bucket will be placed.
	S3BucketsAllowed *bool `json:"s3BucketsAllowed,omitempty"`

	// Specifies the storage options applied to the Storage Domain (View Box).
	StoragePolicy *StoragePolicy `json:"storagePolicy,omitempty"`

	// Optional ids for the tenants that this view box belongs. This must be
	// checked before granting access to users. Unless the cluster enables view
	// box sharing between tenants is allowed, there shall be at most one item
	// in this list. Note that if all tenant may be deleted - such viewboxes
	// must be garbage collected. This is currently done by a background thread
	// in iris.
	TenantIDVec []string `json:"tenantIdVec"`

	// Specifies the brick size to be used by the viewbox for creating any new
	// blobs.
	UpdatedBrickSize *int32 `json:"updatedBrickSize,omitempty"`
}

// Validate validates this create view box params
func (m *CreateViewBoxParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientSubnetWhiteList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterPartitionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultUserQuotaPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultViewQuotaPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoragePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateViewBoxParams) validateClientSubnetWhiteList(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientSubnetWhiteList) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientSubnetWhiteList); i++ {
		if swag.IsZero(m.ClientSubnetWhiteList[i]) { // not required
			continue
		}

		if m.ClientSubnetWhiteList[i] != nil {
			if err := m.ClientSubnetWhiteList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateViewBoxParams) validateClusterPartitionID(formats strfmt.Registry) error {

	if err := validate.Required("clusterPartitionId", "body", m.ClusterPartitionID); err != nil {
		return err
	}

	return nil
}

func (m *CreateViewBoxParams) validateDefaultUserQuotaPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultUserQuotaPolicy) { // not required
		return nil
	}

	return nil
}

func (m *CreateViewBoxParams) validateDefaultViewQuotaPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultViewQuotaPolicy) { // not required
		return nil
	}

	return nil
}

func (m *CreateViewBoxParams) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *CreateViewBoxParams) validatePhysicalQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalQuota) { // not required
		return nil
	}

	return nil
}

func (m *CreateViewBoxParams) validateStoragePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.StoragePolicy) { // not required
		return nil
	}

	if m.StoragePolicy != nil {
		if err := m.StoragePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create view box params based on the context it is used
func (m *CreateViewBoxParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClientSubnetWhiteList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultUserQuotaPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultViewQuotaPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStoragePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateViewBoxParams) contextValidateClientSubnetWhiteList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClientSubnetWhiteList); i++ {

		if m.ClientSubnetWhiteList[i] != nil {

			if swag.IsZero(m.ClientSubnetWhiteList[i]) { // not required
				return nil
			}

			if err := m.ClientSubnetWhiteList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateViewBoxParams) contextValidateDefaultUserQuotaPolicy(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *CreateViewBoxParams) contextValidateDefaultViewQuotaPolicy(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *CreateViewBoxParams) contextValidatePhysicalQuota(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *CreateViewBoxParams) contextValidateStoragePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.StoragePolicy != nil {

		if swag.IsZero(m.StoragePolicy) { // not required
			return nil
		}

		if err := m.StoragePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateViewBoxParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateViewBoxParams) UnmarshalBinary(b []byte) error {
	var res CreateViewBoxParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
