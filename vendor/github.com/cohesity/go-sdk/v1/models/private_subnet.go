// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PrivateSubnet Subnet Subnet
//
// swagger:model PrivateSubnet
type PrivateSubnet struct {

	// Allow All Tenants Flag
	AllowAllTenants *bool `json:"allowAllTenants,omitempty"`

	// Service Access Flag
	AllowServiceAccess *bool `json:"allowServiceAccess,omitempty"`

	// CIDR
	// Required: true
	Cidr *string `json:"cidr"`

	// dhcp conf
	DhcpConf *DHCPConf `json:"dhcpConf,omitempty"`

	// DHCP enabled
	DhcpEnabled *bool `json:"dhcpEnabled,omitempty"`

	// error
	// Read Only: true
	Error *AxonError `json:"error,omitempty"`

	// Reserved ip list
	// Read Only: true
	ExcludeIPRanges []string `json:"excludeIpRanges"`

	// Gateway
	Gw *string `json:"gw,omitempty"`

	// the id for the subnet
	// Format: uuid4
	// Read Only: true
	// Format: uuid4
	ID *strfmt.UUID4 `json:"id,omitempty"`

	// ip version
	IPVersion *string `json:"ipVersion,omitempty"`

	// id of request that initiated last operation performed on this resource
	// Format: uuid4
	// Read Only: true
	// Format: uuid4
	LastOperationRequestID *strfmt.UUID4 `json:"lastOperationRequestId,omitempty"`

	// Metadata about this subnet
	Metadata map[string]string `json:"metadata,omitempty"`

	// name of the subnet
	// Required: true
	// Min Length: 1
	Name *string `json:"name"`

	// Network ID
	// Required: true
	NetworkID *string `json:"networkId"`

	// service access config
	ServiceAccessConfig *ServiceAccessConfig `json:"serviceAccessConfig,omitempty"`

	// IP address list which is reserved for static addresses and won't be used by IPAM for dynamic allocations
	StaticIPRanges []string `json:"staticIpRanges"`

	// status
	Status *string `json:"status,omitempty"`

	// ID of the tenant
	// Read Only: true
	TenantID *string `json:"tenantId,omitempty"`
}

// Validate validates this private subnet
func (m *PrivateSubnet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCidr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDhcpConf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastOperationRequestID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceAccessConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateSubnet) validateCidr(formats strfmt.Registry) error {

	if err := validate.Required("cidr", "body", m.Cidr); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) validateDhcpConf(formats strfmt.Registry) error {
	if swag.IsZero(m.DhcpConf) { // not required
		return nil
	}

	if m.DhcpConf != nil {
		if err := m.DhcpConf.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dhcpConf")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dhcpConf")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSubnet) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSubnet) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.FormatOf("id", "body", "uuid4", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) validateLastOperationRequestID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastOperationRequestID) { // not required
		return nil
	}

	if err := validate.FormatOf("lastOperationRequestId", "body", "uuid4", m.LastOperationRequestID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) validateNetworkID(formats strfmt.Registry) error {

	if err := validate.Required("networkId", "body", m.NetworkID); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) validateServiceAccessConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceAccessConfig) { // not required
		return nil
	}

	if m.ServiceAccessConfig != nil {
		if err := m.ServiceAccessConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("serviceAccessConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("serviceAccessConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this private subnet based on the context it is used
func (m *PrivateSubnet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDhcpConf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludeIPRanges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastOperationRequestID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceAccessConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenantID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateSubnet) contextValidateDhcpConf(ctx context.Context, formats strfmt.Registry) error {

	if m.DhcpConf != nil {

		if swag.IsZero(m.DhcpConf) { // not required
			return nil
		}

		if err := m.DhcpConf.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dhcpConf")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dhcpConf")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSubnet) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {

		if swag.IsZero(m.Error) { // not required
			return nil
		}

		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSubnet) contextValidateExcludeIPRanges(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "excludeIpRanges", "body", []string(m.ExcludeIPRanges)); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) contextValidateLastOperationRequestID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastOperationRequestId", "body", m.LastOperationRequestID); err != nil {
		return err
	}

	return nil
}

func (m *PrivateSubnet) contextValidateServiceAccessConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ServiceAccessConfig != nil {

		if swag.IsZero(m.ServiceAccessConfig) { // not required
			return nil
		}

		if err := m.ServiceAccessConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("serviceAccessConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("serviceAccessConfig")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSubnet) contextValidateTenantID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenantId", "body", m.TenantID); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateSubnet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateSubnet) UnmarshalBinary(b []byte) error {
	var res PrivateSubnet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
