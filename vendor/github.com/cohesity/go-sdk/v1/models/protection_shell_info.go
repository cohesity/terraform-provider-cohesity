// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProtectionShellInfo ProtectionShellInfo specifies the shell information about a protection run.
//
// swagger:model ProtectionShellInfo
type ProtectionShellInfo struct {

	// Specifies the end time of the Protection Run. The end time
	// is specified as a Unix epoch Timestamp (in microseconds).
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Specifies if an error occurred (if any) while running this task.
	// This field is populated when the status is equal to 'kFailure'.
	Error *string `json:"error,omitempty"`

	// Specifies the id of the Job Run that ran the backup task and
	// the copy tasks.
	JobRunID *int64 `json:"jobRunId,omitempty"`

	// Specifies the type of backup such as 'kRegular', 'kFull', 'kLog' or
	// 'kSystem'.
	// 'kRegular' indicates a incremental (CBT) backup. Incremental backups
	// utilizing CBT (if supported) are captured of the target protection objects.
	// The first run of a kRegular schedule captures all the blocks.
	// 'kFull' indicates a full (no CBT) backup. A complete backup
	// (all blocks) of the target protection objects are always captured and
	// Change Block Tracking (CBT) is not utilized.
	// 'kLog' indicates a Database Log backup. Capture the database
	// transaction logs to allow rolling back to a specific point in time.
	// 'kSystem' indicates a system backup. System backups are used to do
	// bare metal recovery of the system to a specific point in time.
	// Enum: ["kRegular","kFull","kLog","kSystem"]
	RunType *string `json:"runType,omitempty"`

	// Specifies the start time of the Protection Run. The start time
	// is specified as a Unix epoch Timestamp (in microseconds).
	// This time is when the task is queued to an internal queue where tasks
	// are waiting to run.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the status of Backup task such as 'kRunning', 'kSuccess',
	// 'kFailure' etc.
	// 'kAccepted' indicates the task is queued to run but not yet running.
	// 'kRunning' indicates the task is running.
	// 'kCanceling' indicates a request to cancel the task has occurred but
	//
	// the task is not yet canceled.
	//
	// 'kCanceled' indicates the task has been canceled.
	// 'kSuccess' indicates the task was successful.
	// 'kFailure' indicates the task failed.
	// 'kWarning' indicates the task has finished with warning.
	// 'kOnHold' indicates the task is kept onHold.
	// 'kMissed' indicates the task is missed.
	// 'Finalizing' indicates the task is finalizing.
	// Enum: ["kAccepted","kRunning","kCanceling","kCanceled","kSuccess","kFailure","kWarning","kOnHold","kMissed","kFinalizing"]
	Status *string `json:"status,omitempty"`
}

// Validate validates this protection shell info
func (m *ProtectionShellInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRunType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var protectionShellInfoTypeRunTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kRegular","kFull","kLog","kSystem"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionShellInfoTypeRunTypePropEnum = append(protectionShellInfoTypeRunTypePropEnum, v)
	}
}

const (

	// ProtectionShellInfoRunTypeKRegular captures enum value "kRegular"
	ProtectionShellInfoRunTypeKRegular string = "kRegular"

	// ProtectionShellInfoRunTypeKFull captures enum value "kFull"
	ProtectionShellInfoRunTypeKFull string = "kFull"

	// ProtectionShellInfoRunTypeKLog captures enum value "kLog"
	ProtectionShellInfoRunTypeKLog string = "kLog"

	// ProtectionShellInfoRunTypeKSystem captures enum value "kSystem"
	ProtectionShellInfoRunTypeKSystem string = "kSystem"
)

// prop value enum
func (m *ProtectionShellInfo) validateRunTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionShellInfoTypeRunTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionShellInfo) validateRunType(formats strfmt.Registry) error {
	if swag.IsZero(m.RunType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRunTypeEnum("runType", "body", *m.RunType); err != nil {
		return err
	}

	return nil
}

var protectionShellInfoTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAccepted","kRunning","kCanceling","kCanceled","kSuccess","kFailure","kWarning","kOnHold","kMissed","kFinalizing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		protectionShellInfoTypeStatusPropEnum = append(protectionShellInfoTypeStatusPropEnum, v)
	}
}

const (

	// ProtectionShellInfoStatusKAccepted captures enum value "kAccepted"
	ProtectionShellInfoStatusKAccepted string = "kAccepted"

	// ProtectionShellInfoStatusKRunning captures enum value "kRunning"
	ProtectionShellInfoStatusKRunning string = "kRunning"

	// ProtectionShellInfoStatusKCanceling captures enum value "kCanceling"
	ProtectionShellInfoStatusKCanceling string = "kCanceling"

	// ProtectionShellInfoStatusKCanceled captures enum value "kCanceled"
	ProtectionShellInfoStatusKCanceled string = "kCanceled"

	// ProtectionShellInfoStatusKSuccess captures enum value "kSuccess"
	ProtectionShellInfoStatusKSuccess string = "kSuccess"

	// ProtectionShellInfoStatusKFailure captures enum value "kFailure"
	ProtectionShellInfoStatusKFailure string = "kFailure"

	// ProtectionShellInfoStatusKWarning captures enum value "kWarning"
	ProtectionShellInfoStatusKWarning string = "kWarning"

	// ProtectionShellInfoStatusKOnHold captures enum value "kOnHold"
	ProtectionShellInfoStatusKOnHold string = "kOnHold"

	// ProtectionShellInfoStatusKMissed captures enum value "kMissed"
	ProtectionShellInfoStatusKMissed string = "kMissed"

	// ProtectionShellInfoStatusKFinalizing captures enum value "kFinalizing"
	ProtectionShellInfoStatusKFinalizing string = "kFinalizing"
)

// prop value enum
func (m *ProtectionShellInfo) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, protectionShellInfoTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProtectionShellInfo) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this protection shell info based on context it is used
func (m *ProtectionShellInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProtectionShellInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProtectionShellInfo) UnmarshalBinary(b []byte) error {
	var res ProtectionShellInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
