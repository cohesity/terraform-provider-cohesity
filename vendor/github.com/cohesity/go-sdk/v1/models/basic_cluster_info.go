// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BasicClusterInfo Basic Cohesity Cluster Information.
//
// Specifies basic information about the Cohesity Cluster.
//
// swagger:model BasicClusterInfo
type BasicClusterInfo struct {

	// Specifies the authentication scheme for the cluster.
	// 'kPasswordOnly' indicates the normal cohesity authentication type.
	// 'kCertificateOnly' indicates that certificate based authentication has
	// been enabled and the password based authentication has been turned off.
	// 'kPasswordAndCertificate' indicates that both the authenticatio schemes
	// are required.
	// Enum: ["kPasswordOnly","kCertificateOnly","kPasswordAndCertificate"]
	AuthenticationType *string `json:"authenticationType,omitempty"`

	// Specifies if banner is enabled on the cluster.
	BannerEnabled *bool `json:"bannerEnabled,omitempty"`

	// Specifies a list of domains joined to the Cohesity Cluster with their
	// trust relationships.
	ClusterDomains []*Domain `json:"clusterDomains"`

	// This field is deprecated. Specifies the current release of the Cohesity
	// software running on this Cohesity Cluster.
	// deprecated: true
	ClusterSoftwareVersion *string `json:"clusterSoftwareVersion,omitempty"`

	// Specifies the type of Cohesity Cluster.
	// 'kPhysical' indicates the Cohesity Cluster is hosted directly on hardware.
	// 'kVirtualRobo' indicates the Cohesity Cluster is hosted in a VM on
	// a ESXi Host of a VMware vCenter Server using Cohesity's Virtual Edition.
	// 'kMicrosoftCloud' indicates the Cohesity Cluster is hosted in a VM
	// on Microsoft Azure using Cohesity's Cloud Edition.
	// 'kAmazonCloud' indicates the Cohesity Cluster is hosted in a VM
	// on Amazon S3 using Cohesity's Cloud Edition.
	// 'kGoogleCloud' indicates the Cohesity Cluster is hosted in a VM
	// on Google Cloud Platform using Cohesity's Cloud Edition.
	// Enum: ["kPhysical","kVirtualRobo","kMicrosoftCloud","kAmazonCloud","kGoogleCloud"]
	ClusterType *string `json:"clusterType,omitempty"`

	// Specifies if dodin mode is enabled on the cluster.
	DodinModeEnabled *bool `json:"dodinModeEnabled,omitempty"`

	// Array of Domains.
	//
	// Specifies a list of domains joined to the Cohesity Cluster,
	// including the default LOCAL Cohesity domain used to store the
	// local Cohesity users.
	Domains []string `json:"domains"`

	// Specifies the HeliosControlPlaneEnv.
	// Read Only: true
	HeliosControlPlaneEnv *string `json:"heliosControlPlaneEnv,omitempty"`

	// Specifies Idp is configured for the Cluster.
	IdpConfigured *bool `json:"idpConfigured,omitempty"`

	// Specifies Idp is configured for a Tenant.
	IdpTenantExists *bool `json:"idpTenantExists,omitempty"`

	// Specifies the language and locale for the Cohesity Cluster.
	LanguageLocale *string `json:"languageLocale,omitempty"`

	// Specifies whether server is running in mcm-mode. If set to true,
	// it is in mcm-mode.
	McmMode *bool `json:"mcmMode,omitempty"`

	// Specifies whether server is running in mcm-on-prem-mode. If set to true,
	// it is in mcm on prem mode. This need mcm-mode to be true.
	McmOnPremMode *bool `json:"mcmOnPremMode,omitempty"`

	// Specifies if multi-tenancy is enabled on the cluster.
	MultiTenancyEnabled *bool `json:"multiTenancyEnabled,omitempty"`

	// Specifies the name of the Cohesity Cluster.
	Name *string `json:"name,omitempty"`
}

// Validate validates this basic cluster info
func (m *BasicClusterInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var basicClusterInfoTypeAuthenticationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kPasswordOnly","kCertificateOnly","kPasswordAndCertificate"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		basicClusterInfoTypeAuthenticationTypePropEnum = append(basicClusterInfoTypeAuthenticationTypePropEnum, v)
	}
}

const (

	// BasicClusterInfoAuthenticationTypeKPasswordOnly captures enum value "kPasswordOnly"
	BasicClusterInfoAuthenticationTypeKPasswordOnly string = "kPasswordOnly"

	// BasicClusterInfoAuthenticationTypeKCertificateOnly captures enum value "kCertificateOnly"
	BasicClusterInfoAuthenticationTypeKCertificateOnly string = "kCertificateOnly"

	// BasicClusterInfoAuthenticationTypeKPasswordAndCertificate captures enum value "kPasswordAndCertificate"
	BasicClusterInfoAuthenticationTypeKPasswordAndCertificate string = "kPasswordAndCertificate"
)

// prop value enum
func (m *BasicClusterInfo) validateAuthenticationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, basicClusterInfoTypeAuthenticationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BasicClusterInfo) validateAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthenticationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthenticationTypeEnum("authenticationType", "body", *m.AuthenticationType); err != nil {
		return err
	}

	return nil
}

func (m *BasicClusterInfo) validateClusterDomains(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterDomains) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterDomains); i++ {
		if swag.IsZero(m.ClusterDomains[i]) { // not required
			continue
		}

		if m.ClusterDomains[i] != nil {
			if err := m.ClusterDomains[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusterDomains" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clusterDomains" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var basicClusterInfoTypeClusterTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kPhysical","kVirtualRobo","kMicrosoftCloud","kAmazonCloud","kGoogleCloud"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		basicClusterInfoTypeClusterTypePropEnum = append(basicClusterInfoTypeClusterTypePropEnum, v)
	}
}

const (

	// BasicClusterInfoClusterTypeKPhysical captures enum value "kPhysical"
	BasicClusterInfoClusterTypeKPhysical string = "kPhysical"

	// BasicClusterInfoClusterTypeKVirtualRobo captures enum value "kVirtualRobo"
	BasicClusterInfoClusterTypeKVirtualRobo string = "kVirtualRobo"

	// BasicClusterInfoClusterTypeKMicrosoftCloud captures enum value "kMicrosoftCloud"
	BasicClusterInfoClusterTypeKMicrosoftCloud string = "kMicrosoftCloud"

	// BasicClusterInfoClusterTypeKAmazonCloud captures enum value "kAmazonCloud"
	BasicClusterInfoClusterTypeKAmazonCloud string = "kAmazonCloud"

	// BasicClusterInfoClusterTypeKGoogleCloud captures enum value "kGoogleCloud"
	BasicClusterInfoClusterTypeKGoogleCloud string = "kGoogleCloud"
)

// prop value enum
func (m *BasicClusterInfo) validateClusterTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, basicClusterInfoTypeClusterTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BasicClusterInfo) validateClusterType(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterType) { // not required
		return nil
	}

	// value enum
	if err := m.validateClusterTypeEnum("clusterType", "body", *m.ClusterType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this basic cluster info based on the context it is used
func (m *BasicClusterInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusterDomains(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeliosControlPlaneEnv(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BasicClusterInfo) contextValidateClusterDomains(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClusterDomains); i++ {

		if m.ClusterDomains[i] != nil {

			if swag.IsZero(m.ClusterDomains[i]) { // not required
				return nil
			}

			if err := m.ClusterDomains[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusterDomains" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clusterDomains" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BasicClusterInfo) contextValidateHeliosControlPlaneEnv(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "heliosControlPlaneEnv", "body", m.HeliosControlPlaneEnv); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BasicClusterInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BasicClusterInfo) UnmarshalBinary(b []byte) error {
	var res BasicClusterInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
