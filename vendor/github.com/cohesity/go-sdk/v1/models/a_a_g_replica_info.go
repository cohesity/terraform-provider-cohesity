// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AAGReplicaInfo SQL AAG replica info
//
// Specifies the information about the AAG replica.
//
// swagger:model AAGReplicaInfo
type AAGReplicaInfo struct {

	// Specifies the availability mode of the replica.
	// Enum: ["kSync","kAsync"]
	AvailabilityMode *string `json:"availabilityMode,omitempty"`

	// Specifies the time when replica is created.
	CreateDateMsecs *int64 `json:"createDateMsecs,omitempty"`

	// Specifies the host name of the replica.
	HostName *string `json:"hostName,omitempty"`

	// Specifies the backup priority.
	LastModifiedMsecs *int32 `json:"lastModifiedMsecs,omitempty"`

	// Specifies the operational state of the replica.
	// kFailedNoQuorum, kNull
	// Enum: ["kPendingFailover","kPending","kOnline","kOffline","kFailed"]
	OperationalState *string `json:"operationalState,omitempty"`

	// Specifies what are the types of connections primary role allows.
	// Enum: ["kNone","kReadOnly","kAll","kReadWrite"]
	PrimaryRoleAllowConnections *string `json:"primaryRoleAllowConnections,omitempty"`

	// Specifies the role of replica.
	// Enum: ["kResolving","kPrimary","kSecondary"]
	Role *string `json:"role,omitempty"`

	// Specifies what are the types of connections secondary role allows.
	// Enum: ["kNone","kReadOnly","kAll","kReadWrite"]
	SecondaryRoleAllowConnections *string `json:"secondaryRoleAllowConnections,omitempty"`

	// Specifies the instance name along with the host name on which the
	// AAG databases are hosted.
	ServerName *string `json:"serverName,omitempty"`

	// Specifies the synchronization health of the replica.
	// Enum: ["kNotHealthy","kPartiallyHealthy","kHealthy"]
	SynchronizationHealth *string `json:"synchronizationHealth,omitempty"`
}

// Validate validates this a a g replica info
func (m *AAGReplicaInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailabilityMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryRoleAllowConnections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryRoleAllowConnections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSynchronizationHealth(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aAGReplicaInfoTypeAvailabilityModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSync","kAsync"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aAGReplicaInfoTypeAvailabilityModePropEnum = append(aAGReplicaInfoTypeAvailabilityModePropEnum, v)
	}
}

const (

	// AAGReplicaInfoAvailabilityModeKSync captures enum value "kSync"
	AAGReplicaInfoAvailabilityModeKSync string = "kSync"

	// AAGReplicaInfoAvailabilityModeKAsync captures enum value "kAsync"
	AAGReplicaInfoAvailabilityModeKAsync string = "kAsync"
)

// prop value enum
func (m *AAGReplicaInfo) validateAvailabilityModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aAGReplicaInfoTypeAvailabilityModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AAGReplicaInfo) validateAvailabilityMode(formats strfmt.Registry) error {
	if swag.IsZero(m.AvailabilityMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateAvailabilityModeEnum("availabilityMode", "body", *m.AvailabilityMode); err != nil {
		return err
	}

	return nil
}

var aAGReplicaInfoTypeOperationalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kPendingFailover","kPending","kOnline","kOffline","kFailed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aAGReplicaInfoTypeOperationalStatePropEnum = append(aAGReplicaInfoTypeOperationalStatePropEnum, v)
	}
}

const (

	// AAGReplicaInfoOperationalStateKPendingFailover captures enum value "kPendingFailover"
	AAGReplicaInfoOperationalStateKPendingFailover string = "kPendingFailover"

	// AAGReplicaInfoOperationalStateKPending captures enum value "kPending"
	AAGReplicaInfoOperationalStateKPending string = "kPending"

	// AAGReplicaInfoOperationalStateKOnline captures enum value "kOnline"
	AAGReplicaInfoOperationalStateKOnline string = "kOnline"

	// AAGReplicaInfoOperationalStateKOffline captures enum value "kOffline"
	AAGReplicaInfoOperationalStateKOffline string = "kOffline"

	// AAGReplicaInfoOperationalStateKFailed captures enum value "kFailed"
	AAGReplicaInfoOperationalStateKFailed string = "kFailed"
)

// prop value enum
func (m *AAGReplicaInfo) validateOperationalStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aAGReplicaInfoTypeOperationalStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AAGReplicaInfo) validateOperationalState(formats strfmt.Registry) error {
	if swag.IsZero(m.OperationalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperationalStateEnum("operationalState", "body", *m.OperationalState); err != nil {
		return err
	}

	return nil
}

var aAGReplicaInfoTypePrimaryRoleAllowConnectionsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNone","kReadOnly","kAll","kReadWrite"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aAGReplicaInfoTypePrimaryRoleAllowConnectionsPropEnum = append(aAGReplicaInfoTypePrimaryRoleAllowConnectionsPropEnum, v)
	}
}

const (

	// AAGReplicaInfoPrimaryRoleAllowConnectionsKNone captures enum value "kNone"
	AAGReplicaInfoPrimaryRoleAllowConnectionsKNone string = "kNone"

	// AAGReplicaInfoPrimaryRoleAllowConnectionsKReadOnly captures enum value "kReadOnly"
	AAGReplicaInfoPrimaryRoleAllowConnectionsKReadOnly string = "kReadOnly"

	// AAGReplicaInfoPrimaryRoleAllowConnectionsKAll captures enum value "kAll"
	AAGReplicaInfoPrimaryRoleAllowConnectionsKAll string = "kAll"

	// AAGReplicaInfoPrimaryRoleAllowConnectionsKReadWrite captures enum value "kReadWrite"
	AAGReplicaInfoPrimaryRoleAllowConnectionsKReadWrite string = "kReadWrite"
)

// prop value enum
func (m *AAGReplicaInfo) validatePrimaryRoleAllowConnectionsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aAGReplicaInfoTypePrimaryRoleAllowConnectionsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AAGReplicaInfo) validatePrimaryRoleAllowConnections(formats strfmt.Registry) error {
	if swag.IsZero(m.PrimaryRoleAllowConnections) { // not required
		return nil
	}

	// value enum
	if err := m.validatePrimaryRoleAllowConnectionsEnum("primaryRoleAllowConnections", "body", *m.PrimaryRoleAllowConnections); err != nil {
		return err
	}

	return nil
}

var aAGReplicaInfoTypeRolePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kResolving","kPrimary","kSecondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aAGReplicaInfoTypeRolePropEnum = append(aAGReplicaInfoTypeRolePropEnum, v)
	}
}

const (

	// AAGReplicaInfoRoleKResolving captures enum value "kResolving"
	AAGReplicaInfoRoleKResolving string = "kResolving"

	// AAGReplicaInfoRoleKPrimary captures enum value "kPrimary"
	AAGReplicaInfoRoleKPrimary string = "kPrimary"

	// AAGReplicaInfoRoleKSecondary captures enum value "kSecondary"
	AAGReplicaInfoRoleKSecondary string = "kSecondary"
)

// prop value enum
func (m *AAGReplicaInfo) validateRoleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aAGReplicaInfoTypeRolePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AAGReplicaInfo) validateRole(formats strfmt.Registry) error {
	if swag.IsZero(m.Role) { // not required
		return nil
	}

	// value enum
	if err := m.validateRoleEnum("role", "body", *m.Role); err != nil {
		return err
	}

	return nil
}

var aAGReplicaInfoTypeSecondaryRoleAllowConnectionsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNone","kReadOnly","kAll","kReadWrite"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aAGReplicaInfoTypeSecondaryRoleAllowConnectionsPropEnum = append(aAGReplicaInfoTypeSecondaryRoleAllowConnectionsPropEnum, v)
	}
}

const (

	// AAGReplicaInfoSecondaryRoleAllowConnectionsKNone captures enum value "kNone"
	AAGReplicaInfoSecondaryRoleAllowConnectionsKNone string = "kNone"

	// AAGReplicaInfoSecondaryRoleAllowConnectionsKReadOnly captures enum value "kReadOnly"
	AAGReplicaInfoSecondaryRoleAllowConnectionsKReadOnly string = "kReadOnly"

	// AAGReplicaInfoSecondaryRoleAllowConnectionsKAll captures enum value "kAll"
	AAGReplicaInfoSecondaryRoleAllowConnectionsKAll string = "kAll"

	// AAGReplicaInfoSecondaryRoleAllowConnectionsKReadWrite captures enum value "kReadWrite"
	AAGReplicaInfoSecondaryRoleAllowConnectionsKReadWrite string = "kReadWrite"
)

// prop value enum
func (m *AAGReplicaInfo) validateSecondaryRoleAllowConnectionsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aAGReplicaInfoTypeSecondaryRoleAllowConnectionsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AAGReplicaInfo) validateSecondaryRoleAllowConnections(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryRoleAllowConnections) { // not required
		return nil
	}

	// value enum
	if err := m.validateSecondaryRoleAllowConnectionsEnum("secondaryRoleAllowConnections", "body", *m.SecondaryRoleAllowConnections); err != nil {
		return err
	}

	return nil
}

var aAGReplicaInfoTypeSynchronizationHealthPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNotHealthy","kPartiallyHealthy","kHealthy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aAGReplicaInfoTypeSynchronizationHealthPropEnum = append(aAGReplicaInfoTypeSynchronizationHealthPropEnum, v)
	}
}

const (

	// AAGReplicaInfoSynchronizationHealthKNotHealthy captures enum value "kNotHealthy"
	AAGReplicaInfoSynchronizationHealthKNotHealthy string = "kNotHealthy"

	// AAGReplicaInfoSynchronizationHealthKPartiallyHealthy captures enum value "kPartiallyHealthy"
	AAGReplicaInfoSynchronizationHealthKPartiallyHealthy string = "kPartiallyHealthy"

	// AAGReplicaInfoSynchronizationHealthKHealthy captures enum value "kHealthy"
	AAGReplicaInfoSynchronizationHealthKHealthy string = "kHealthy"
)

// prop value enum
func (m *AAGReplicaInfo) validateSynchronizationHealthEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aAGReplicaInfoTypeSynchronizationHealthPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AAGReplicaInfo) validateSynchronizationHealth(formats strfmt.Registry) error {
	if swag.IsZero(m.SynchronizationHealth) { // not required
		return nil
	}

	// value enum
	if err := m.validateSynchronizationHealthEnum("synchronizationHealth", "body", *m.SynchronizationHealth); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this a a g replica info based on context it is used
func (m *AAGReplicaInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AAGReplicaInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AAGReplicaInfo) UnmarshalBinary(b []byte) error {
	var res AAGReplicaInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
