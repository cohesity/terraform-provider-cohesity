// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// App App information.
//
// App provides information about an application.
//
// swagger:model App
type App struct {

	// Specifies unique id allocated by the AppStore.
	AppID *int64 `json:"appId,omitempty"`

	// Specifies the list of clusters on which the app is installed for a
	// particular account Id.
	Clusters []*ClusterInfo `json:"clusters"`

	// Specifies app download progress percentage.
	DownloadProgressPct *float64 `json:"downloadProgressPct,omitempty"`

	// Specifies if an external ip is required for the app.
	ExternalIPRequired *bool `json:"externalIpRequired,omitempty"`

	// List of external network information available for the app.
	ExternalNetworks []*ExternalNetworkInfo `json:"externalNetworks"`

	// Specifies app installation status.
	// Specifies status of the app installation.
	// kNotInstalled - App yet to be installed.
	// kInstallInProgress - App installation is in progress.
	// kInstalled - App is installed successfully and can be launched.
	// kInstallFailed - App installation failed.
	// kUninstallInProgress - App uninstallation is in progress.
	// kUninstallFailed - App uninstallation failed.
	// kDownloadNotStarted - App download has not started.
	// kDownloadInProgress - App download in progress.
	// kDownloadComplete - App download completed.
	// kDownloadFailed - App download failed.
	// Enum: ["kNotInstalled","kInstallInProgress","kInstalled","kInstallFailed","kUninstallInProgress","kUninstallFailed","kDownloadNotStarted","kDownloadInProgress","kDownloadComplete","kDownloadFailed"]
	InstallState *string `json:"installState,omitempty"`

	// Specifies timestamp when the app was installed.
	InstallTime *int64 `json:"installTime,omitempty"`

	// List of applicable instance size specifications (e.g. small/medium/large)
	// for the app. Used to determine container resources.
	InstanceSizes []string `json:"instanceSizes"`

	// Specifies whether the app currently installed on all clusters is the
	// latest version or not.
	IsLatest *bool `json:"isLatest,omitempty"`

	// Specifies application version assigned by the AppStore for the latest
	// version of an app.
	LatestVersion *int64 `json:"latestVersion,omitempty"`

	// Specifies metadata information about the app.
	Metadata *AppMetadata `json:"metadata,omitempty"`

	// Specifies privileges that are required for this app.
	// App privilege information.
	//
	// Specifies privileges that are required for this app.
	// kReadAccess - App needs views for read access.
	// kReadWriteAccess - App needs views for Read/write access.
	// kManagementAccess - App needs management access via iris API.
	// kAutoMountAccess - Whether to allow auto-mounting all the views.
	// kUnrestrictedAppUIAccess - Whether app requires unrestricted UI access (i.e. without passing app access token in URL).
	// kAuditLogViewReadAccess - Whether app requires read access to the internal audit log view.
	// kProtectedObjectAccess - Whether app requires read access to protected objects.
	RequiredPrivileges []string `json:"requiredPrivileges"`

	// ErrorMessage on failed installation.
	StateDetail *string `json:"stateDetail,omitempty"`

	// Specifies timestamp when the app was uninstalled.
	UninstallTime *int64 `json:"uninstallTime,omitempty"`

	// Specifies application version assigned by the AppStore.
	Version *int64 `json:"version,omitempty"`

	// List of vm name info objects.
	VMNameInfoList []*VMNameInfo `json:"vmNameInfoList"`
}

// Validate validates this app
func (m *App) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClusters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalNetworks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstallState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequiredPrivileges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMNameInfoList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *App) validateClusters(formats strfmt.Registry) error {
	if swag.IsZero(m.Clusters) { // not required
		return nil
	}

	for i := 0; i < len(m.Clusters); i++ {
		if swag.IsZero(m.Clusters[i]) { // not required
			continue
		}

		if m.Clusters[i] != nil {
			if err := m.Clusters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clusters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *App) validateExternalNetworks(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalNetworks) { // not required
		return nil
	}

	for i := 0; i < len(m.ExternalNetworks); i++ {
		if swag.IsZero(m.ExternalNetworks[i]) { // not required
			continue
		}

		if m.ExternalNetworks[i] != nil {
			if err := m.ExternalNetworks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("externalNetworks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("externalNetworks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var appTypeInstallStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNotInstalled","kInstallInProgress","kInstalled","kInstallFailed","kUninstallInProgress","kUninstallFailed","kDownloadNotStarted","kDownloadInProgress","kDownloadComplete","kDownloadFailed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		appTypeInstallStatePropEnum = append(appTypeInstallStatePropEnum, v)
	}
}

const (

	// AppInstallStateKNotInstalled captures enum value "kNotInstalled"
	AppInstallStateKNotInstalled string = "kNotInstalled"

	// AppInstallStateKInstallInProgress captures enum value "kInstallInProgress"
	AppInstallStateKInstallInProgress string = "kInstallInProgress"

	// AppInstallStateKInstalled captures enum value "kInstalled"
	AppInstallStateKInstalled string = "kInstalled"

	// AppInstallStateKInstallFailed captures enum value "kInstallFailed"
	AppInstallStateKInstallFailed string = "kInstallFailed"

	// AppInstallStateKUninstallInProgress captures enum value "kUninstallInProgress"
	AppInstallStateKUninstallInProgress string = "kUninstallInProgress"

	// AppInstallStateKUninstallFailed captures enum value "kUninstallFailed"
	AppInstallStateKUninstallFailed string = "kUninstallFailed"

	// AppInstallStateKDownloadNotStarted captures enum value "kDownloadNotStarted"
	AppInstallStateKDownloadNotStarted string = "kDownloadNotStarted"

	// AppInstallStateKDownloadInProgress captures enum value "kDownloadInProgress"
	AppInstallStateKDownloadInProgress string = "kDownloadInProgress"

	// AppInstallStateKDownloadComplete captures enum value "kDownloadComplete"
	AppInstallStateKDownloadComplete string = "kDownloadComplete"

	// AppInstallStateKDownloadFailed captures enum value "kDownloadFailed"
	AppInstallStateKDownloadFailed string = "kDownloadFailed"
)

// prop value enum
func (m *App) validateInstallStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, appTypeInstallStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *App) validateInstallState(formats strfmt.Registry) error {
	if swag.IsZero(m.InstallState) { // not required
		return nil
	}

	// value enum
	if err := m.validateInstallStateEnum("installState", "body", *m.InstallState); err != nil {
		return err
	}

	return nil
}

func (m *App) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

var appRequiredPrivilegesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kReadAccess","kReadWriteAccess","kManagementAccess","kAutoMountAccess","kUnrestrictedAppUIAccess","kAuditLogViewReadAccess","kProtectedObjectAccess"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		appRequiredPrivilegesItemsEnum = append(appRequiredPrivilegesItemsEnum, v)
	}
}

func (m *App) validateRequiredPrivilegesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, appRequiredPrivilegesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *App) validateRequiredPrivileges(formats strfmt.Registry) error {
	if swag.IsZero(m.RequiredPrivileges) { // not required
		return nil
	}

	for i := 0; i < len(m.RequiredPrivileges); i++ {

		// value enum
		if err := m.validateRequiredPrivilegesItemsEnum("requiredPrivileges"+"."+strconv.Itoa(i), "body", m.RequiredPrivileges[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *App) validateVMNameInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.VMNameInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.VMNameInfoList); i++ {
		if swag.IsZero(m.VMNameInfoList[i]) { // not required
			continue
		}

		if m.VMNameInfoList[i] != nil {
			if err := m.VMNameInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vmNameInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vmNameInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this app based on the context it is used
func (m *App) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExternalNetworks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMNameInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *App) contextValidateClusters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Clusters); i++ {

		if m.Clusters[i] != nil {

			if swag.IsZero(m.Clusters[i]) { // not required
				return nil
			}

			if err := m.Clusters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clusters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *App) contextValidateExternalNetworks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExternalNetworks); i++ {

		if m.ExternalNetworks[i] != nil {

			if swag.IsZero(m.ExternalNetworks[i]) { // not required
				return nil
			}

			if err := m.ExternalNetworks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("externalNetworks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("externalNetworks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *App) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {

		if swag.IsZero(m.Metadata) { // not required
			return nil
		}

		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *App) contextValidateVMNameInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VMNameInfoList); i++ {

		if m.VMNameInfoList[i] != nil {

			if swag.IsZero(m.VMNameInfoList[i]) { // not required
				return nil
			}

			if err := m.VMNameInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vmNameInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vmNameInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *App) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *App) UnmarshalBinary(b []byte) error {
	var res App
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
