// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SQLProtectionSource SQL Protection Source.
//
// Specifies an Object representing one SQL Server instance or database.
//
// swagger:model SqlProtectionSource
type SQLProtectionSource struct {

	// Specifies whether the database is marked as available for backup according
	// to the SQL Server VSS writer. This may be false if either the state of
	// the databases is not online, or if the VSS writer is not online.
	// This field is set only for type 'kDatabase'.
	IsAvailableForVssBackup *bool `json:"IsAvailableForVssBackup,omitempty"`

	// Specifies the information about the AAG source.
	AagInfo *AAGInfo `json:"aagInfo,omitempty"`

	// Specifies the time when the database was created. It is displayed in the
	// timezone of the SQL server on which this database is running.
	CreatedTimestamp *string `json:"createdTimestamp,omitempty"`

	// Specifies the database name of the SQL Protection Source, if the type
	// is database.
	DatabaseName *string `json:"databaseName,omitempty"`

	// Specifies the AAG entity id if the database is part of an AAG.
	// This field is set only for type 'kDatabase'.
	DbAagEntityID *int64 `json:"dbAagEntityId,omitempty"`

	// Specifies the name of the AAG if the database is part of an AAG.
	// This field is set only for type 'kDatabase'.
	DbAagName *string `json:"dbAagName,omitempty"`

	// Specifies the versions of SQL server that the database is compatible
	// with.
	DbCompatibilityLevel *int64 `json:"dbCompatibilityLevel,omitempty"`

	// Specifies the information about the set of file groups for this db on
	// the host. This is only set if the type is kDatabase.
	DbFileGroups []string `json:"dbFileGroups"`

	// Specifies the last known information about the set of database files
	// on the host. This field is set only for type 'kDatabase'.
	DbFiles []*DbFileInfo `json:"dbFiles"`

	// Specifies the name of the database owner.
	DbOwnerUsername *string `json:"dbOwnerUsername,omitempty"`

	// Specifies the default path for data files for DBs in an instance
	DefaultDatabaseLocation *string `json:"defaultDatabaseLocation,omitempty"`

	// Specifies the default path for log files for DBs in an instance
	DefaultLogLocation *string `json:"defaultLogLocation,omitempty"`

	// Specifies an id that identifies an SQL Object.
	ID *SQLSourceID `json:"id,omitempty"`

	// Specifies whether the database is TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`

	// Specifies the instance name of the SQL Protection Source
	Name *string `json:"name,omitempty"`

	// Specifies the id of the container VM for the SQL Protection Source.
	OwnerID *int64 `json:"ownerId,omitempty"`

	// Specifies the Recovery Model for the database in SQL environment.
	// Only meaningful for the 'kDatabase' SQL Protection Source.
	// Specifies the Recovery Model set for the Microsoft SQL Server.
	// 'kSimpleRecoveryModel' indicates the Simple SQL Recovery Model which
	// does not utilize log backups.
	// 'kFullRecoveryModel' indicates the Full SQL Recovery Model which
	// requires log backups and allows recovery to a single point in time.
	// 'kBulkLoggedRecoveryModel' indicates the Bulk Logged SQL Recovery Model
	// which requires log backups and allows high-performance bulk copy operations.
	// Enum: ["kSimpleRecoveryModel","kFullRecoveryModel","kBulkLoggedRecoveryModel"]
	RecoveryModel *string `json:"recoveryModel,omitempty"`

	// The state of the database as returned by SQL Server.
	// Indicates the state of the database. The values correspond to the 'state'
	// field in the system table sys.databases. See https://goo.gl/P66XqM.
	// 'kOnline' indicates that database is in online state.
	// 'kRestoring' indicates that database is in restore state.
	// 'kRecovering' indicates that database is in recovery state.
	// 'kRecoveryPending' indicates that database recovery is in pending state.
	// 'kSuspect' indicates that primary filegroup is suspect and may be damaged.
	// 'kEmergency' indicates that manually forced emergency state.
	// 'kOffline' indicates that database is in offline state.
	// 'kCopying' indicates that database is in copying state.
	// 'kOfflineSecondary' indicates that secondary database is in offline state.
	// Enum: ["kOnline","kRestoring","kRecovering","kRecoveryPending","kSuspect","kEmergency","kOffline","kCopying","kOfflineSecondary"]
	SQLServerDbState *string `json:"sqlServerDbState,omitempty"`

	// The version of the SQL instance.
	SQLServerInstanceVersion *SQLServerInstanceVersion `json:"sqlServerInstanceVersion,omitempty"`

	// Specifies the type of the managed Object in a SQL Protection Source.
	// Examples of SQL Objects include 'kInstance' and 'kDatabase'.
	// 'kInstance' indicates that SQL server instance is being protected.
	// 'kDatabase' indicates that SQL server database is being protected.
	// 'kAAG' indicates that SQL AAG (AlwaysOn Availability Group) is being
	// protected.
	// 'kAAGRootContainer' indicates that SQL AAG's root container is being
	// protected.
	// 'kRootContainer' indicates root container for SQL sources.
	// Enum: ["kInstance","kDatabase","kAAG","kAAGRootContainer","kRootContainer"]
	Type *string `json:"type,omitempty"`
}

// Validate validates this Sql protection source
func (m *SQLProtectionSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAagInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDbFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecoveryModel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLServerDbState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLServerInstanceVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLProtectionSource) validateAagInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.AagInfo) { // not required
		return nil
	}

	if m.AagInfo != nil {
		if err := m.AagInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aagInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("aagInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SQLProtectionSource) validateDbFiles(formats strfmt.Registry) error {
	if swag.IsZero(m.DbFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.DbFiles); i++ {
		if swag.IsZero(m.DbFiles[i]) { // not required
			continue
		}

		if m.DbFiles[i] != nil {
			if err := m.DbFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dbFiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dbFiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SQLProtectionSource) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if m.ID != nil {
		if err := m.ID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

var sqlProtectionSourceTypeRecoveryModelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSimpleRecoveryModel","kFullRecoveryModel","kBulkLoggedRecoveryModel"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlProtectionSourceTypeRecoveryModelPropEnum = append(sqlProtectionSourceTypeRecoveryModelPropEnum, v)
	}
}

const (

	// SQLProtectionSourceRecoveryModelKSimpleRecoveryModel captures enum value "kSimpleRecoveryModel"
	SQLProtectionSourceRecoveryModelKSimpleRecoveryModel string = "kSimpleRecoveryModel"

	// SQLProtectionSourceRecoveryModelKFullRecoveryModel captures enum value "kFullRecoveryModel"
	SQLProtectionSourceRecoveryModelKFullRecoveryModel string = "kFullRecoveryModel"

	// SQLProtectionSourceRecoveryModelKBulkLoggedRecoveryModel captures enum value "kBulkLoggedRecoveryModel"
	SQLProtectionSourceRecoveryModelKBulkLoggedRecoveryModel string = "kBulkLoggedRecoveryModel"
)

// prop value enum
func (m *SQLProtectionSource) validateRecoveryModelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlProtectionSourceTypeRecoveryModelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLProtectionSource) validateRecoveryModel(formats strfmt.Registry) error {
	if swag.IsZero(m.RecoveryModel) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecoveryModelEnum("recoveryModel", "body", *m.RecoveryModel); err != nil {
		return err
	}

	return nil
}

var sqlProtectionSourceTypeSQLServerDbStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kOnline","kRestoring","kRecovering","kRecoveryPending","kSuspect","kEmergency","kOffline","kCopying","kOfflineSecondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlProtectionSourceTypeSQLServerDbStatePropEnum = append(sqlProtectionSourceTypeSQLServerDbStatePropEnum, v)
	}
}

const (

	// SQLProtectionSourceSQLServerDbStateKOnline captures enum value "kOnline"
	SQLProtectionSourceSQLServerDbStateKOnline string = "kOnline"

	// SQLProtectionSourceSQLServerDbStateKRestoring captures enum value "kRestoring"
	SQLProtectionSourceSQLServerDbStateKRestoring string = "kRestoring"

	// SQLProtectionSourceSQLServerDbStateKRecovering captures enum value "kRecovering"
	SQLProtectionSourceSQLServerDbStateKRecovering string = "kRecovering"

	// SQLProtectionSourceSQLServerDbStateKRecoveryPending captures enum value "kRecoveryPending"
	SQLProtectionSourceSQLServerDbStateKRecoveryPending string = "kRecoveryPending"

	// SQLProtectionSourceSQLServerDbStateKSuspect captures enum value "kSuspect"
	SQLProtectionSourceSQLServerDbStateKSuspect string = "kSuspect"

	// SQLProtectionSourceSQLServerDbStateKEmergency captures enum value "kEmergency"
	SQLProtectionSourceSQLServerDbStateKEmergency string = "kEmergency"

	// SQLProtectionSourceSQLServerDbStateKOffline captures enum value "kOffline"
	SQLProtectionSourceSQLServerDbStateKOffline string = "kOffline"

	// SQLProtectionSourceSQLServerDbStateKCopying captures enum value "kCopying"
	SQLProtectionSourceSQLServerDbStateKCopying string = "kCopying"

	// SQLProtectionSourceSQLServerDbStateKOfflineSecondary captures enum value "kOfflineSecondary"
	SQLProtectionSourceSQLServerDbStateKOfflineSecondary string = "kOfflineSecondary"
)

// prop value enum
func (m *SQLProtectionSource) validateSQLServerDbStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlProtectionSourceTypeSQLServerDbStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLProtectionSource) validateSQLServerDbState(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLServerDbState) { // not required
		return nil
	}

	// value enum
	if err := m.validateSQLServerDbStateEnum("sqlServerDbState", "body", *m.SQLServerDbState); err != nil {
		return err
	}

	return nil
}

func (m *SQLProtectionSource) validateSQLServerInstanceVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLServerInstanceVersion) { // not required
		return nil
	}

	if m.SQLServerInstanceVersion != nil {
		if err := m.SQLServerInstanceVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlServerInstanceVersion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlServerInstanceVersion")
			}
			return err
		}
	}

	return nil
}

var sqlProtectionSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kInstance","kDatabase","kAAG","kAAGRootContainer","kRootContainer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlProtectionSourceTypeTypePropEnum = append(sqlProtectionSourceTypeTypePropEnum, v)
	}
}

const (

	// SQLProtectionSourceTypeKInstance captures enum value "kInstance"
	SQLProtectionSourceTypeKInstance string = "kInstance"

	// SQLProtectionSourceTypeKDatabase captures enum value "kDatabase"
	SQLProtectionSourceTypeKDatabase string = "kDatabase"

	// SQLProtectionSourceTypeKAAG captures enum value "kAAG"
	SQLProtectionSourceTypeKAAG string = "kAAG"

	// SQLProtectionSourceTypeKAAGRootContainer captures enum value "kAAGRootContainer"
	SQLProtectionSourceTypeKAAGRootContainer string = "kAAGRootContainer"

	// SQLProtectionSourceTypeKRootContainer captures enum value "kRootContainer"
	SQLProtectionSourceTypeKRootContainer string = "kRootContainer"
)

// prop value enum
func (m *SQLProtectionSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlProtectionSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLProtectionSource) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this Sql protection source based on the context it is used
func (m *SQLProtectionSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAagInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDbFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSQLServerInstanceVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLProtectionSource) contextValidateAagInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.AagInfo != nil {

		if swag.IsZero(m.AagInfo) { // not required
			return nil
		}

		if err := m.AagInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aagInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("aagInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SQLProtectionSource) contextValidateDbFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DbFiles); i++ {

		if m.DbFiles[i] != nil {

			if swag.IsZero(m.DbFiles[i]) { // not required
				return nil
			}

			if err := m.DbFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dbFiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dbFiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SQLProtectionSource) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if m.ID != nil {

		if swag.IsZero(m.ID) { // not required
			return nil
		}

		if err := m.ID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *SQLProtectionSource) contextValidateSQLServerInstanceVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.SQLServerInstanceVersion != nil {

		if swag.IsZero(m.SQLServerInstanceVersion) { // not required
			return nil
		}

		if err := m.SQLServerInstanceVersion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlServerInstanceVersion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlServerInstanceVersion")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLProtectionSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLProtectionSource) UnmarshalBinary(b []byte) error {
	var res SQLProtectionSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
