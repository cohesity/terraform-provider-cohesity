// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SQLRestoreParameters SQL Application Server Restore Parameters.
//
// Specifies the parameters specific the Application Server instance.
//
// swagger:model SqlRestoreParameters
type SQLRestoreParameters struct {

	// Set this to true if tail logs are to be captured before the restore
	// operation. This is only applicable if we are restoring the SQL database
	// to its hosting Protection Source, and the database is not being renamed.
	CaptureTailLogs *bool `json:"captureTailLogs,omitempty"`

	// This field determines if Auto Sync enabled/disabled for SQL Multi-stage
	// Restore task
	IsAutoSyncEnabled *bool `json:"isAutoSyncEnabled,omitempty"`

	// This field prevents "change data capture" settings from being reomved
	// when a database or log backup is restored on another server and database
	// is recovered.
	KeepCdc *bool `json:"keepCdc,omitempty"`

	// Set this to true if we want to restore the database and do not want to
	// bring it online after restore.
	//
	// This is only applicable if we are restoring the database back to
	// its original location.
	KeepOffline *bool `json:"keepOffline,omitempty"`

	// Specifies optionally a new name for the restored database.
	NewDatabaseName *string `json:"newDatabaseName,omitempty"`

	// Specifies an instance name of the SQL Server that should be restored.
	// SQL application has many instances. Each instance has a unique name.
	// One of the instances that should be restored must be set in this field.
	NewInstanceName *string `json:"newInstanceName,omitempty"`

	// Overwrite Policy specifies a policy to be used while recovering
	// existing databases.
	// Specifies the policy to be used while recovering
	// existing databases.
	// 'kFailIfExists' refers to a policy to fail if DB exists already.
	// 'kOverwrite' refres to the policy to overwrite existing DB.
	// Enum: ["kFailIfExists","kOverwrite"]
	OverwritePolicy *string `json:"overwritePolicy,omitempty"`

	// Specifies the time in the past to which the SQL database needs to be
	// restored. This allows for granular recovery of SQL databases. If this is
	// not set, the SQL database will be restored from the full/incremental
	// snapshot.
	RestoreTimeSecs *int64 `json:"restoreTimeSecs,omitempty"`

	// Specifies the directory where to put the database data files.
	// Missing directory will be automatically created. This field must be
	// set if restoring to a different target host.
	TargetDataFilesDirectory *string `json:"targetDataFilesDirectory,omitempty"`

	// Specifies the directory where to put the database log files. Missing
	// directory will be automatically created. This field must be set if
	// restoring to a different target host.
	TargetLogFilesDirectory *string `json:"targetLogFilesDirectory,omitempty"`

	// Specifies the secondary data filename pattern and corresponding
	// directories of the DB. Secondary data files are optional and are user
	// defined. The recommended file extension for secondary files is ".ndf".
	//
	// If this option is specified and the destination folders do not exist they
	// will be automatically created.
	TargetSecondaryDataFilesDirectoryList []*FilenamePatternToDirectory `json:"targetSecondaryDataFilesDirectoryList"`

	// WithClause allows you to specify clauses to be used in native sql restore
	// task.
	WithClause *string `json:"withClause,omitempty"`
}

// Validate validates this Sql restore parameters
func (m *SQLRestoreParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOverwritePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetSecondaryDataFilesDirectoryList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var sqlRestoreParametersTypeOverwritePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kFailIfExists","kOverwrite"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		sqlRestoreParametersTypeOverwritePolicyPropEnum = append(sqlRestoreParametersTypeOverwritePolicyPropEnum, v)
	}
}

const (

	// SQLRestoreParametersOverwritePolicyKFailIfExists captures enum value "kFailIfExists"
	SQLRestoreParametersOverwritePolicyKFailIfExists string = "kFailIfExists"

	// SQLRestoreParametersOverwritePolicyKOverwrite captures enum value "kOverwrite"
	SQLRestoreParametersOverwritePolicyKOverwrite string = "kOverwrite"
)

// prop value enum
func (m *SQLRestoreParameters) validateOverwritePolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, sqlRestoreParametersTypeOverwritePolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SQLRestoreParameters) validateOverwritePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.OverwritePolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateOverwritePolicyEnum("overwritePolicy", "body", *m.OverwritePolicy); err != nil {
		return err
	}

	return nil
}

func (m *SQLRestoreParameters) validateTargetSecondaryDataFilesDirectoryList(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetSecondaryDataFilesDirectoryList) { // not required
		return nil
	}

	for i := 0; i < len(m.TargetSecondaryDataFilesDirectoryList); i++ {
		if swag.IsZero(m.TargetSecondaryDataFilesDirectoryList[i]) { // not required
			continue
		}

		if m.TargetSecondaryDataFilesDirectoryList[i] != nil {
			if err := m.TargetSecondaryDataFilesDirectoryList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targetSecondaryDataFilesDirectoryList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targetSecondaryDataFilesDirectoryList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this Sql restore parameters based on the context it is used
func (m *SQLRestoreParameters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTargetSecondaryDataFilesDirectoryList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SQLRestoreParameters) contextValidateTargetSecondaryDataFilesDirectoryList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TargetSecondaryDataFilesDirectoryList); i++ {

		if m.TargetSecondaryDataFilesDirectoryList[i] != nil {

			if swag.IsZero(m.TargetSecondaryDataFilesDirectoryList[i]) { // not required
				return nil
			}

			if err := m.TargetSecondaryDataFilesDirectoryList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targetSecondaryDataFilesDirectoryList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targetSecondaryDataFilesDirectoryList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SQLRestoreParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SQLRestoreParameters) UnmarshalBinary(b []byte) error {
	var res SQLRestoreParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
