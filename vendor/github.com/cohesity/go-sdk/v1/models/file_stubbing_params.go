// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// FileStubbingParams File Stubbing Parameters
// Message to capture the additional stubbing params for a file-based
// environment.
//
// swagger:model FileStubbingParams
type FileStubbingParams struct {

	// File access time buckets.
	AccessTimeBuckets []*NasAnalysisJobParamsAccessTimeBucket `json:"accessTimeBuckets"`

	// Identifies the cold files in the NAS source. Files that haven't been
	// accessed/modified in the last cold_file_window msecs or are older than
	// cold_window_msecs are migrated.
	ColdFileWindow *int64 `json:"coldFileWindow,omitempty"`

	// Delete migrated data if no symlink at source is pointing to it.
	DeleteOrphanData *bool `json:"deleteOrphanData,omitempty"`

	// Denied file type buckets. This is list is mutually exclusive of allowed
	// buckets. This is used only when allowed buckets contain 'Other-*' bucket
	// in which case we will have to deny all the extensions which are not
	// present allowed buckets. This field is only used for communication between
	// master and slave. Iris only uses the 'file_type_buckets' field.
	DeniedFileTypeBuckets []*NasAnalysisJobParamsFileTypeBucket `json:"deniedFileTypeBuckets"`

	// Audit log the file tiering activity.
	EnableAuditLogging *bool `json:"enableAuditLogging,omitempty"`

	// Enable checksum verification for downtier job.
	EnableChecksumVerification *bool `json:"enableChecksumVerification,omitempty"`

	// File migrate policy based on file access/modify time and age. Depcrecated.
	FileSelectPolicy *int32 `json:"fileSelectPolicy,omitempty"`

	// Gives the size criteria to be used for selecting the files to be migrated.
	// The cold files that are equal and greater than file_size or
	// smaller than file_size are migrated.
	FileSize *int64 `json:"fileSize,omitempty"`

	// File size buckets.
	FileSizeBuckets []*NasAnalysisJobParamsFileSizeBucket `json:"fileSizeBuckets"`

	// File size policy for selecting files to migrate. Depcrecated.
	FileSizePolicy *int32 `json:"fileSizePolicy,omitempty"`

	// Allowed file type buckets.
	FileTypeBuckets []*NasAnalysisJobParamsFileTypeBucket `json:"fileTypeBuckets"`

	// The filtering policy to decide which objects within a source should be
	// stubbed. If this is not specified, then all the objects within the
	// source will be migrated based on the migration policy.
	// We use the filtering_policy in NasBackupParams. So this field is
	// deprecated.
	FilteringPolicy *FilteringPolicyProto `json:"filteringPolicy,omitempty"`

	// Migrate data without stub.
	MigrateWithoutStub *bool `json:"migrateWithoutStub,omitempty"`

	// File modification time buckets.
	ModTimeBuckets []*NasAnalysisJobParamsModTimeBucket `json:"modTimeBuckets"`

	// Mount path where the Cohesity target view must be mounted on all
	// NFS clients for accessing the migrated data.
	NfsMountPath *string `json:"nfsMountPath,omitempty"`

	// nfs_mount_path_prefix contains the parent directory path where respective
	// view name will be suffixed to form a complete mount path where Cohesity
	// target view will be mounted on NFS clients for accessing the migrated
	// data.
	NfsMountPathPrefix *string `json:"nfsMountPathPrefix,omitempty"`

	// The object's entity id to TargetViewData map where the data will be
	// migrated.
	TargetViewMap interface{} `json:"targetViewMap,omitempty"`

	// The target view name to which the data will be migrated.
	TargetViewName *string `json:"targetViewName,omitempty"`

	// target_view_prefix is used to support multiple objects in a single
	// tiering job. It helps in generating view name which are reasonably
	// close to the original share name.
	TargetViewPrefix *string `json:"targetViewPrefix,omitempty"`

	// Tiering Goal, i.e. the maximum amount of data that should be present
	// on source after downtiering.
	TieringGoal *int64 `json:"tieringGoal,omitempty"`
}

// Validate validates this file stubbing params
func (m *FileStubbingParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessTimeBuckets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeniedFileTypeBuckets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileSizeBuckets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileTypeBuckets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilteringPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModTimeBuckets(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileStubbingParams) validateAccessTimeBuckets(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessTimeBuckets) { // not required
		return nil
	}

	for i := 0; i < len(m.AccessTimeBuckets); i++ {
		if swag.IsZero(m.AccessTimeBuckets[i]) { // not required
			continue
		}

		if m.AccessTimeBuckets[i] != nil {
			if err := m.AccessTimeBuckets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accessTimeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("accessTimeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) validateDeniedFileTypeBuckets(formats strfmt.Registry) error {
	if swag.IsZero(m.DeniedFileTypeBuckets) { // not required
		return nil
	}

	for i := 0; i < len(m.DeniedFileTypeBuckets); i++ {
		if swag.IsZero(m.DeniedFileTypeBuckets[i]) { // not required
			continue
		}

		if m.DeniedFileTypeBuckets[i] != nil {
			if err := m.DeniedFileTypeBuckets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("deniedFileTypeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("deniedFileTypeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) validateFileSizeBuckets(formats strfmt.Registry) error {
	if swag.IsZero(m.FileSizeBuckets) { // not required
		return nil
	}

	for i := 0; i < len(m.FileSizeBuckets); i++ {
		if swag.IsZero(m.FileSizeBuckets[i]) { // not required
			continue
		}

		if m.FileSizeBuckets[i] != nil {
			if err := m.FileSizeBuckets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileSizeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileSizeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) validateFileTypeBuckets(formats strfmt.Registry) error {
	if swag.IsZero(m.FileTypeBuckets) { // not required
		return nil
	}

	for i := 0; i < len(m.FileTypeBuckets); i++ {
		if swag.IsZero(m.FileTypeBuckets[i]) { // not required
			continue
		}

		if m.FileTypeBuckets[i] != nil {
			if err := m.FileTypeBuckets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileTypeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileTypeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) validateFilteringPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.FilteringPolicy) { // not required
		return nil
	}

	if m.FilteringPolicy != nil {
		if err := m.FilteringPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filteringPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filteringPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *FileStubbingParams) validateModTimeBuckets(formats strfmt.Registry) error {
	if swag.IsZero(m.ModTimeBuckets) { // not required
		return nil
	}

	for i := 0; i < len(m.ModTimeBuckets); i++ {
		if swag.IsZero(m.ModTimeBuckets[i]) { // not required
			continue
		}

		if m.ModTimeBuckets[i] != nil {
			if err := m.ModTimeBuckets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("modTimeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("modTimeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this file stubbing params based on the context it is used
func (m *FileStubbingParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccessTimeBuckets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDeniedFileTypeBuckets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileSizeBuckets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileTypeBuckets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilteringPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateModTimeBuckets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileStubbingParams) contextValidateAccessTimeBuckets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AccessTimeBuckets); i++ {

		if m.AccessTimeBuckets[i] != nil {

			if swag.IsZero(m.AccessTimeBuckets[i]) { // not required
				return nil
			}

			if err := m.AccessTimeBuckets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accessTimeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("accessTimeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) contextValidateDeniedFileTypeBuckets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DeniedFileTypeBuckets); i++ {

		if m.DeniedFileTypeBuckets[i] != nil {

			if swag.IsZero(m.DeniedFileTypeBuckets[i]) { // not required
				return nil
			}

			if err := m.DeniedFileTypeBuckets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("deniedFileTypeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("deniedFileTypeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) contextValidateFileSizeBuckets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FileSizeBuckets); i++ {

		if m.FileSizeBuckets[i] != nil {

			if swag.IsZero(m.FileSizeBuckets[i]) { // not required
				return nil
			}

			if err := m.FileSizeBuckets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileSizeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileSizeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) contextValidateFileTypeBuckets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FileTypeBuckets); i++ {

		if m.FileTypeBuckets[i] != nil {

			if swag.IsZero(m.FileTypeBuckets[i]) { // not required
				return nil
			}

			if err := m.FileTypeBuckets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileTypeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileTypeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FileStubbingParams) contextValidateFilteringPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.FilteringPolicy != nil {

		if swag.IsZero(m.FilteringPolicy) { // not required
			return nil
		}

		if err := m.FilteringPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filteringPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filteringPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *FileStubbingParams) contextValidateModTimeBuckets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ModTimeBuckets); i++ {

		if m.ModTimeBuckets[i] != nil {

			if swag.IsZero(m.ModTimeBuckets[i]) { // not required
				return nil
			}

			if err := m.ModTimeBuckets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("modTimeBuckets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("modTimeBuckets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileStubbingParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileStubbingParams) UnmarshalBinary(b []byte) error {
	var res FileStubbingParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
