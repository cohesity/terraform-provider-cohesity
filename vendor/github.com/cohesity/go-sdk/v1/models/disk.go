// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Disk Disk in a Volume.
//
// Specifies information about a disk and partitions in a volume.
//
// swagger:model Disk
type Disk struct {

	// Array of Disk Blocks.
	//
	// Specifies a set of disk blocks by defining the location and offset of
	// disk blocks in a disk.
	DiskBlocks []*DiskBlock `json:"diskBlocks"`

	// Specifies the format of the virtual disk.
	// 'kVMDK' indicates VMware's Virtual Disk format.
	// 'kVHD' indicates Microsoft's Virtual Hard Drive format.
	// 'kVHDx' indicates Microsoft's Hyper-V Virtual Hard Drive format.
	// 'kRaw' indicates Raw disk format used by KVM, Acropolis.
	// 'kUnknow' indicates Unknown disk format.
	// Enum: ["kVMDK","kVHD","kVHDx","kRaw","kUnknown"]
	DiskFormat *string `json:"diskFormat,omitempty"`

	// Array of Partitions.
	//
	// Specifies information about all the partitions in this disk.
	DiskPartitions []*DiskPartition `json:"diskPartitions"`

	// Specifies partition table format on a disk.
	// 'kNoPartition' indicates missing partition table.
	// 'kMBRPartition' indicates partition table is in Master Boot Record format.
	// 'kGPTPartition' indicates partition table is in Guid Partition Table format.
	// 'kSGIPartition' indicates partition table uses SGI scheme.
	// 'kSUNPartition' indicates partition table uses SUN scheme.
	// Enum: ["kNoPartition","kMBRPartition","kGPTPartition","kSGIPartition","kSUNPartition"]
	PartitionTableFormat *string `json:"partitionTableFormat,omitempty"`

	// Specifies the sector size of hard disk. It is used for mapping the disk
	// blocks of the disk file into a linear list of sectors.
	SectorSizeBytes *int64 `json:"sectorSizeBytes,omitempty"`

	// Specifies the disk uuid.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the disk file name. This is the VMDK name and not the
	// flat file name.
	VmdkFileName *string `json:"vmdkFileName,omitempty"`

	// Specifies the disk size in bytes.
	VmdkSizeBytes *int64 `json:"vmdkSizeBytes,omitempty"`
}

// Validate validates this disk
func (m *Disk) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDiskBlocks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskPartitions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePartitionTableFormat(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) validateDiskBlocks(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskBlocks) { // not required
		return nil
	}

	for i := 0; i < len(m.DiskBlocks); i++ {
		if swag.IsZero(m.DiskBlocks[i]) { // not required
			continue
		}

		if m.DiskBlocks[i] != nil {
			if err := m.DiskBlocks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskBlocks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskBlocks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var diskTypeDiskFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kVMDK","kVHD","kVHDx","kRaw","kUnknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypeDiskFormatPropEnum = append(diskTypeDiskFormatPropEnum, v)
	}
}

const (

	// DiskDiskFormatKVMDK captures enum value "kVMDK"
	DiskDiskFormatKVMDK string = "kVMDK"

	// DiskDiskFormatKVHD captures enum value "kVHD"
	DiskDiskFormatKVHD string = "kVHD"

	// DiskDiskFormatKVHDx captures enum value "kVHDx"
	DiskDiskFormatKVHDx string = "kVHDx"

	// DiskDiskFormatKRaw captures enum value "kRaw"
	DiskDiskFormatKRaw string = "kRaw"

	// DiskDiskFormatKUnknown captures enum value "kUnknown"
	DiskDiskFormatKUnknown string = "kUnknown"
)

// prop value enum
func (m *Disk) validateDiskFormatEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypeDiskFormatPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validateDiskFormat(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskFormat) { // not required
		return nil
	}

	// value enum
	if err := m.validateDiskFormatEnum("diskFormat", "body", *m.DiskFormat); err != nil {
		return err
	}

	return nil
}

func (m *Disk) validateDiskPartitions(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskPartitions) { // not required
		return nil
	}

	for i := 0; i < len(m.DiskPartitions); i++ {
		if swag.IsZero(m.DiskPartitions[i]) { // not required
			continue
		}

		if m.DiskPartitions[i] != nil {
			if err := m.DiskPartitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskPartitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskPartitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var diskTypePartitionTableFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNoPartition","kMBRPartition","kGPTPartition","kSGIPartition","kSUNPartition"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskTypePartitionTableFormatPropEnum = append(diskTypePartitionTableFormatPropEnum, v)
	}
}

const (

	// DiskPartitionTableFormatKNoPartition captures enum value "kNoPartition"
	DiskPartitionTableFormatKNoPartition string = "kNoPartition"

	// DiskPartitionTableFormatKMBRPartition captures enum value "kMBRPartition"
	DiskPartitionTableFormatKMBRPartition string = "kMBRPartition"

	// DiskPartitionTableFormatKGPTPartition captures enum value "kGPTPartition"
	DiskPartitionTableFormatKGPTPartition string = "kGPTPartition"

	// DiskPartitionTableFormatKSGIPartition captures enum value "kSGIPartition"
	DiskPartitionTableFormatKSGIPartition string = "kSGIPartition"

	// DiskPartitionTableFormatKSUNPartition captures enum value "kSUNPartition"
	DiskPartitionTableFormatKSUNPartition string = "kSUNPartition"
)

// prop value enum
func (m *Disk) validatePartitionTableFormatEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskTypePartitionTableFormatPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Disk) validatePartitionTableFormat(formats strfmt.Registry) error {
	if swag.IsZero(m.PartitionTableFormat) { // not required
		return nil
	}

	// value enum
	if err := m.validatePartitionTableFormatEnum("partitionTableFormat", "body", *m.PartitionTableFormat); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this disk based on the context it is used
func (m *Disk) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDiskBlocks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDiskPartitions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Disk) contextValidateDiskBlocks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DiskBlocks); i++ {

		if m.DiskBlocks[i] != nil {

			if swag.IsZero(m.DiskBlocks[i]) { // not required
				return nil
			}

			if err := m.DiskBlocks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskBlocks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskBlocks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Disk) contextValidateDiskPartitions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DiskPartitions); i++ {

		if m.DiskPartitions[i] != nil {

			if swag.IsZero(m.DiskPartitions[i]) { // not required
				return nil
			}

			if err := m.DiskPartitions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskPartitions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskPartitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Disk) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Disk) UnmarshalBinary(b []byte) error {
	var res Disk
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
