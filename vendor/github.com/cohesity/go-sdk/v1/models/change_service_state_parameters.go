// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ChangeServiceStateParameters Change Service State Parameters.
//
// Specifies the parameters needed to change the state of one or more
// services running on the Cluster.
//
// swagger:model ChangeServiceStateParameters
type ChangeServiceStateParameters struct {

	// Specifies the action to take on the specified service.
	// 'kStop' indicates that the specified services will be stopped.
	// 'kStart' indicates that the specified services will be started.
	// 'kRestart' indicates that the specified services will be restarted.
	// Enum: ["kStop","kStart","kRestart"]
	Action *string `json:"action,omitempty"`

	// Specifies the list of services to take the specified action on.
	// If none are specified, all Cluster services will be affected. It should
	// also be noted that some Cluster services are not stoppable and may
	// not be affected by the action specified.
	// 'kApollo' is a service for reclaiming freed disk sectors on Nodes in the
	// SnapFS distributed file system.
	// 'kBridge' is a service for managing the SnapFS distributed file system.
	// 'kGenie' is a service that is responsible for monitoring hardware health
	// on the Cluster.
	// 'kGenieGofer' is a service that links the Genie service to other services
	// on the Cluster.
	// 'kMagneto' is the data protection service of the Cohesity Data Platform.
	// 'kIris' is the service which serves REST API calls to the UI, CLI, and any
	// scripts written by customers.
	// 'kIrisProxy' is a service that links the Iris service to other services
	// on the Cluster.
	// 'kScribe' is the service responsible for storing filesystem metadata.
	// 'kStats' is the service that is responsible for retrieving and aggregating
	// disk metrics across the Cluster.
	// 'kYoda' is an elastic search indexing service.
	// 'kAlerts' is a publisher and subscribing service for alerts.
	// 'kKeychain' is a service for managing disk encryption keys.
	// 'kLogWatcher' is a service that scans the log directory and reduces
	// the number of logs if required.
	// 'kStatsCollector' is a service that periodically logs system stats.
	// 'kGandalf' is a distributed lock service and coordination manager.
	// 'kNexus' indicates the Nexus service. This is the service that is
	// responsible for creation of Clusters and configuration of Nodes and
	// networking.
	// 'kNexusProxy' is a service that links the Nexus service to other services
	// on the Cluster.
	// 'kStorageProxy' is a service for accessing data on external entities.
	// 'kRtClient' is a reverse tunneling client service.
	// 'kVaultProxy' is a service for managing external targets that Clusters
	// can be backed up to.
	// 'kSmbProxy' is an SMB protocol service.
	// 'kBridgeProxy' is the service that links the Bridge service to other
	// services on the Cluster.
	// 'kLibrarian' is an elastic search indexing service.
	// 'kGroot' is a service for managing replication of SQL databases across
	// multiple nodes in a Cluster.
	// 'kEagleAgent' is a service that is responsible for retrieving information
	// on Cluster health.
	// 'kAthena' is a service for running distributed containerized applications
	// on the Cohesity Data Platform.
	// 'kBifrostBroker' is a service for communicating with the Cohesity proxies
	// for multitenancy.
	// 'kSmb2Proxy' is a new SMB protocol service.
	// 'kOs' can be specified in order to do a full reboot.
	// 'kAtom' is a service for receiving data for the Continuous Data Protection.
	// 'kPatch' is a service for downloading and applying patches.
	// 'kCompass' is a service for serving dns request for external and internal
	// traffic.
	// 'kEtlServer' is a service responsible for ETling data for globalsearch.
	// 'kIcebox' is service that links Icebox service to other services on cluster.
	// kScribe, kStats, kYoda, kAlerts, kKeychain, kLogWatcher, kStatsCollecter,
	// kGandalf, kNexus, kNexusProxy, kStorageProxy, kRtClient, kVaultProxy,
	// kSmbProxy, kBridgeProxy, kLibrarian, kGroot, kEagleAgent, kAthena,
	// kBifrostBroker, kSmb2Proxy, kOs, kAtom, kIcebox
	Services []string `json:"services"`
}

// Validate validates this change service state parameters
func (m *ChangeServiceStateParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServices(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var changeServiceStateParametersTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kStop","kStart","kRestart"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		changeServiceStateParametersTypeActionPropEnum = append(changeServiceStateParametersTypeActionPropEnum, v)
	}
}

const (

	// ChangeServiceStateParametersActionKStop captures enum value "kStop"
	ChangeServiceStateParametersActionKStop string = "kStop"

	// ChangeServiceStateParametersActionKStart captures enum value "kStart"
	ChangeServiceStateParametersActionKStart string = "kStart"

	// ChangeServiceStateParametersActionKRestart captures enum value "kRestart"
	ChangeServiceStateParametersActionKRestart string = "kRestart"
)

// prop value enum
func (m *ChangeServiceStateParameters) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, changeServiceStateParametersTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChangeServiceStateParameters) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	// value enum
	if err := m.validateActionEnum("action", "body", *m.Action); err != nil {
		return err
	}

	return nil
}

var changeServiceStateParametersServicesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kApollo","kBridge","kGenie","kGenieGofer","kMagneto","kIris","kIrisProxy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		changeServiceStateParametersServicesItemsEnum = append(changeServiceStateParametersServicesItemsEnum, v)
	}
}

func (m *ChangeServiceStateParameters) validateServicesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, changeServiceStateParametersServicesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ChangeServiceStateParameters) validateServices(formats strfmt.Registry) error {
	if swag.IsZero(m.Services) { // not required
		return nil
	}

	for i := 0; i < len(m.Services); i++ {

		// value enum
		if err := m.validateServicesItemsEnum("services"+"."+strconv.Itoa(i), "body", m.Services[i]); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this change service state parameters based on context it is used
func (m *ChangeServiceStateParameters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ChangeServiceStateParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ChangeServiceStateParameters) UnmarshalBinary(b []byte) error {
	var res ChangeServiceStateParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
