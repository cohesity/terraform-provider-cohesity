// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CloneTaskRequest Clone Restore Task Request.
//
// Specifies the settings for a Restore Task that clones VMs or Views.
//
// swagger:model CloneTaskRequest
type CloneTaskRequest struct {

	// Clone View.
	//
	// Specifies settings for cloning an existing View.
	// This field is required for a 'kCloneView' Restore Task.
	CloneViewParameters struct {
		CloneViewRequest
	} `json:"cloneViewParameters,omitempty"`

	// Specifies if the Restore Task should continue when some operations on some
	// objects fail. If true, the Cohesity Cluster ignores intermittent
	// errors and restores as many objects as possible.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Specifies the way data needs to be retrieved from the external target.
	// This information will be filled in by Iris and Magneto will pass it along
	// to the Icebox as it is to support bulk retrieval from Glacier.
	// Specifies the type of Restore Task.
	//
	// 'kStandard' specifies retrievals that allow to access any of your archives
	// within several hours. Standard retrievals typically complete within 3–5
	// hours. This is the default option for retrieval requests that do not specify
	// the retrieval option.
	// 'kBulk' specifies retrievals that are Glacier’s lowest-cost retrieval
	// option, which can be used to retrieve large amounts, even petabytes, of data
	// inexpensively in a day. Bulk retrieval typically complete within 5–12 hours.
	// 'kExpedited' specifies retrievals that allows to quickly access your data
	// when occasional urgent requests for a subset of archives are required. For
	// all but the largest archives (250 MB+), data accessed using Expedited
	// retrievals are typically made available within 1–5 minutes.
	// Enum: ["kStandard","kBulk","kExpedited"]
	GlacierRetrievalType *string `json:"glacierRetrievalType,omitempty"`

	// Specifies additional parameters for 'kHyperV' restore objects.
	HypervParameters *HypervCloneParameters `json:"hypervParameters,omitempty"`

	// Specifies the name of the Restore Task. This field must be set and
	// must be a unique name.
	// Required: true
	Name *string `json:"name"`

	// Specify a new registered parent Protection Source. If specified
	// the selected objects are cloned or recovered to this new Protection
	// Source. If not specified, objects are cloned or recovered
	// to the original Protection Source that was managing them.
	NewParentID *int64 `json:"newParentId,omitempty"`

	// Array of Objects.
	//
	// Specifies a list of Protection Source objects or Protection Job objects
	// (with specified Protection Source objects).
	Objects []*RestoreObjectDetails `json:"objects"`

	// Specifies the name of the View where the cloned VMs are stored.
	// This field is required for a 'kCloneVMs' Restore Task.
	TargetViewName *string `json:"targetViewName,omitempty"`

	// Specifies the type of Restore Task such as 'kCloneVMs' or 'kCloneView'.
	// 'kCloneVMs' specifies a Restore Task that clones VMs.
	// 'kCloneView' specifies a Restore Task that clones a View.
	// Required: true
	// Enum: ["kCloneVMs","kCloneView"]
	Type *string `json:"type"`

	// Specifies VLAN parameters for the restore operation.
	VlanParameters *VlanParameters `json:"vlanParameters,omitempty"`

	// Specifies additional parameters for 'kVmware' restore objects.
	VmwareParameters *VmwareCloneParameters `json:"vmwareParameters,omitempty"`
}

// Validate validates this clone task request
func (m *CloneTaskRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCloneViewParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlacierRetrievalType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHypervParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjects(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlanParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVmwareParameters(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloneTaskRequest) validateCloneViewParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.CloneViewParameters) { // not required
		return nil
	}

	return nil
}

var cloneTaskRequestTypeGlacierRetrievalTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kStandard","kBulk","kExpedited"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloneTaskRequestTypeGlacierRetrievalTypePropEnum = append(cloneTaskRequestTypeGlacierRetrievalTypePropEnum, v)
	}
}

const (

	// CloneTaskRequestGlacierRetrievalTypeKStandard captures enum value "kStandard"
	CloneTaskRequestGlacierRetrievalTypeKStandard string = "kStandard"

	// CloneTaskRequestGlacierRetrievalTypeKBulk captures enum value "kBulk"
	CloneTaskRequestGlacierRetrievalTypeKBulk string = "kBulk"

	// CloneTaskRequestGlacierRetrievalTypeKExpedited captures enum value "kExpedited"
	CloneTaskRequestGlacierRetrievalTypeKExpedited string = "kExpedited"
)

// prop value enum
func (m *CloneTaskRequest) validateGlacierRetrievalTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloneTaskRequestTypeGlacierRetrievalTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloneTaskRequest) validateGlacierRetrievalType(formats strfmt.Registry) error {
	if swag.IsZero(m.GlacierRetrievalType) { // not required
		return nil
	}

	// value enum
	if err := m.validateGlacierRetrievalTypeEnum("glacierRetrievalType", "body", *m.GlacierRetrievalType); err != nil {
		return err
	}

	return nil
}

func (m *CloneTaskRequest) validateHypervParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.HypervParameters) { // not required
		return nil
	}

	if m.HypervParameters != nil {
		if err := m.HypervParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hypervParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hypervParameters")
			}
			return err
		}
	}

	return nil
}

func (m *CloneTaskRequest) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *CloneTaskRequest) validateObjects(formats strfmt.Registry) error {
	if swag.IsZero(m.Objects) { // not required
		return nil
	}

	for i := 0; i < len(m.Objects); i++ {
		if swag.IsZero(m.Objects[i]) { // not required
			continue
		}

		if m.Objects[i] != nil {
			if err := m.Objects[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var cloneTaskRequestTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCloneVMs","kCloneView"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloneTaskRequestTypeTypePropEnum = append(cloneTaskRequestTypeTypePropEnum, v)
	}
}

const (

	// CloneTaskRequestTypeKCloneVMs captures enum value "kCloneVMs"
	CloneTaskRequestTypeKCloneVMs string = "kCloneVMs"

	// CloneTaskRequestTypeKCloneView captures enum value "kCloneView"
	CloneTaskRequestTypeKCloneView string = "kCloneView"
)

// prop value enum
func (m *CloneTaskRequest) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloneTaskRequestTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloneTaskRequest) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *CloneTaskRequest) validateVlanParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.VlanParameters) { // not required
		return nil
	}

	if m.VlanParameters != nil {
		if err := m.VlanParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlanParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vlanParameters")
			}
			return err
		}
	}

	return nil
}

func (m *CloneTaskRequest) validateVmwareParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.VmwareParameters) { // not required
		return nil
	}

	if m.VmwareParameters != nil {
		if err := m.VmwareParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vmwareParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vmwareParameters")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this clone task request based on the context it is used
func (m *CloneTaskRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCloneViewParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHypervParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjects(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVlanParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVmwareParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloneTaskRequest) contextValidateCloneViewParameters(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *CloneTaskRequest) contextValidateHypervParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.HypervParameters != nil {

		if swag.IsZero(m.HypervParameters) { // not required
			return nil
		}

		if err := m.HypervParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hypervParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hypervParameters")
			}
			return err
		}
	}

	return nil
}

func (m *CloneTaskRequest) contextValidateObjects(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Objects); i++ {

		if m.Objects[i] != nil {

			if swag.IsZero(m.Objects[i]) { // not required
				return nil
			}

			if err := m.Objects[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("objects" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("objects" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneTaskRequest) contextValidateVlanParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.VlanParameters != nil {

		if swag.IsZero(m.VlanParameters) { // not required
			return nil
		}

		if err := m.VlanParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vlanParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vlanParameters")
			}
			return err
		}
	}

	return nil
}

func (m *CloneTaskRequest) contextValidateVmwareParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.VmwareParameters != nil {

		if swag.IsZero(m.VmwareParameters) { // not required
			return nil
		}

		if err := m.VmwareParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vmwareParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vmwareParameters")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloneTaskRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloneTaskRequest) UnmarshalBinary(b []byte) error {
	var res CloneTaskRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
