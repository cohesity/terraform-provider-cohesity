// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ViewBox Domain (View Box).
//
// Provides details about a Storage Domain (View Box).
//
// swagger:model ViewBox
type ViewBox struct {

	// Specifies an active directory domain that this view box is mapped to.
	AdDomainName *string `json:"adDomainName,omitempty"`

	// Specifies the default brick size used by the viewbox.
	BrickSize *int32 `json:"brickSize,omitempty"`

	// Array of Subnets.
	//
	// Specifies the Subnets from which this Storage Domain (View Box) accepts
	// requests.
	ClientSubnetWhiteList []*Subnet `json:"clientSubnetWhiteList"`

	// Specifies the associated cloud domain Id.
	CloudDomainID *int64 `json:"cloudDomainId,omitempty"`

	// Specifies the cloud down water-fall threshold percentage. This indicates
	// how full should a viewbox at least be before we down water-fall its data
	// to cloud tier. If this field is set, the physical quota limit must be set
	// also and will be used as viewbox capacity.
	CloudDownWaterfallThresholdPct *int32 `json:"cloudDownWaterfallThresholdPct,omitempty"`

	// Specifies the cloud down water-fall threshold seconds. This indicates
	// what's the time threshold on water-falling data to cloud tier.
	CloudDownWaterfallThresholdSecs *int32 `json:"cloudDownWaterfallThresholdSecs,omitempty"`

	// Specifies the Cluster Partition id where the Storage Domain (View Box) is
	// located.
	// Required: true
	ClusterPartitionID *int64 `json:"clusterPartitionId"`

	// Specifies the Cohesity Cluster name where the Storage Domain (View Box) is
	// located.
	// Read Only: true
	ClusterPartitionName *string `json:"clusterPartitionName,omitempty"`

	// Specifies an optional quota policy/limits that are inherited by all users
	// within the views in this viewbox.
	DefaultUserQuotaPolicy struct {
		QuotaPolicy
	} `json:"defaultUserQuotaPolicy,omitempty"`

	// Specifies an optional default logical quota limit (in bytes)
	// for the Views in this Storage Domain (View Box).
	// (Logical data is when the data is fully hydrated and expanded.)
	// However, this inherited quota can be overwritten at the View level.
	// A new write is not allowed if the Storage Domain (View Box) will exceed
	// the specified quota.
	// However, it takes time for the Cohesity Cluster to calculate
	// the usage across Nodes, so the limit may be exceeded by a small amount.
	// In addition, if the limit is increased or data is removed,
	// there may be delay before the Cohesity Cluster allows more data
	// to be written to the Storage Domain (View Box), as the Cluster is
	// calculating the usage across Nodes.
	DefaultViewQuotaPolicy struct {
		QuotaPolicy
	} `json:"defaultViewQuotaPolicy,omitempty"`

	// Specifies whether DEK(Data Encryption Key) rotation is enabled for this
	// viewbox. This is applicable only when the viewbox uses AWS or similar KMS
	// in which the KEK (Key Encryption Key) is not created and maintained by
	// Cohesity. For Internal KMS and keys stored in Safenet servers, DEK
	// rotation will not be performed.
	DekRotationEnabled *bool `json:"dekRotationEnabled,omitempty"`

	// Specifies whether this viewbox can be used as a staging area while copying
	// a largedataset that can't fit on the cluster to an external target. The
	// amount of data that can be stored on the viewbox can be specified using
	// 'physical_quota'.
	DirectArchiveEnabled *bool `json:"directArchiveEnabled,omitempty"`

	// Specifies the Id of the Storage Domain (View Box).
	ID *int64 `json:"id,omitempty"`

	// Recommendation for the view if the template id was passed during query.
	// We say the view is to be recommended, if the dedup and inlinecompression
	// both are same as the template's property.
	IsRecommended *bool `json:"isRecommended,omitempty"`

	// Specifies the Kerberos domain that this view box is mapped to.
	KerberosRealmName *string `json:"kerberosRealmName,omitempty"`

	// Specifies the associated KMS Server ID.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// Last key rotation timestamp in msecs for viewbox.
	LastKeyRotationTimestampMsecs *int64 `json:"lastKeyRotationTimestampMsecs,omitempty"`

	// When set, the following provides the LDAP provider the view box is
	// mapped to. For any view from this view box, when accessed via NFS the
	// following LDAP provider is looked up for getting Unix IDs of the
	// corresponding user. Similarly, when a view is accessed via SMB and if
	// the AD user's domain matches with the view box's AD, the following LDAP
	// provider will be used to lookup Unix IDs for the corresponding AD user.
	// Additionally there is also a mapping between LDAP provider and AD domain
	// that is stored in AD provider config. It will be used if AD is not set
	// on the view box.
	LdapProviderID *int64 `json:"ldapProviderId,omitempty"`

	// Specifies the name of the Storage Domain (View Box).
	// Required: true
	Name *string `json:"name"`

	// Specifies the NIS domain that this view box is mapped to.
	NisDomainNameVec []string `json:"nisDomainNameVec"`

	// Specifies an optional quota limit (in bytes) for the physical
	// usage of this Storage Domain (View Box).
	// This quota limit defines a physical limit for size of the data that
	// can be physically stored on the Storage Domain (View Box), after the data
	// has been reduced by change block tracking, compression and deduplication.
	// The physical usage is the aggregate sum of the data stored for this
	// Storage Domain (View Box) on all disks in the Cluster.
	// (The usage includes Cloud Tier data and user data.)
	// A new write is not allowed if the Storage Domain (View Box) will exceed
	// the specified quota. However, it takes time for the Cohesity Cluster to
	// calculate the usage across Nodes, so the limit may be exceeded by a small
	// amount. In addition, if the limit is increased or data is removed,
	// there may be a delay before the Cohesity Cluster allows more data
	// to be written to the Storage Domain (View Box), as the Cluster is
	// calculating the usage across Nodes.
	PhysicalQuota struct {
		QuotaPolicy
	} `json:"physicalQuota,omitempty"`

	// Specifies the current removal state of the Storage Domain (View Box).
	// 'kDontRemove' means the state of object is functional and
	// it is not being removed.
	// 'kMarkedForRemoval' means the object is being removed.
	// 'kOkToRemove' means the object has been removed on the Cohesity Cluster and
	// if the object is physical, it can be removed from the Cohesity Cluster.
	// Enum: ["kDontRemove","kMarkedForRemoval","kOkToRemove"]
	RemovalState *string `json:"removalState,omitempty"`

	// Specifies whether creation of a S3 bucket is allowed in this
	// Storage Domain (View Box).
	// When a new S3 bucket creation request arrives, we'll look at all the View
	// Boxes and the first Storage Domain (View Box) that allows creating S3
	// buckets in it will be the one where the bucket will be placed.
	S3BucketsAllowed *bool `json:"s3BucketsAllowed,omitempty"`

	// Specifies the time series schema info of the view box.
	SchemaInfoList []*SchemaInfo `json:"schemaInfoList"`

	// Specifies statistics about the Storage Domain (View Box).
	// readOnly: true
	Stats *ViewBoxStats `json:"stats,omitempty"`

	// Specifies the storage options applied to the Storage Domain (View Box).
	StoragePolicy *StoragePolicy `json:"storagePolicy,omitempty"`

	// Optional ids for the tenants that this view box belongs. This must be
	// checked before granting access to users. Unless the cluster enables view
	// box sharing between tenants is allowed, there shall be at most one item
	// in this list. Note that if all tenant may be deleted - such viewboxes
	// must be garbage collected. This is currently done by a background thread
	// in iris.
	TenantIDVec []string `json:"tenantIdVec"`

	// If 'true', when the Cohesity Cluster is writing to a file, the
	// file modification time is not persisted synchronously during the
	// file write, so the modification time may not be accurate.
	// (Typically the file modification time is off by 30 seconds but
	// it can be longer.)
	// Only set to 'false' if your environment requires a very accurate
	// modification time.
	// The default value is 'true' which provides the best Cohesity
	// Cluster performance.
	TreatFileSyncAsDataSync *bool `json:"treatFileSyncAsDataSync,omitempty"`

	// Specifies the brick size to be used by the viewbox for creating any new
	// blobs.
	UpdatedBrickSize *int32 `json:"updatedBrickSize,omitempty"`

	// Specifies the associated vault Id.
	VaultID *int64 `json:"vaultId,omitempty"`
}

// Validate validates this view box
func (m *ViewBox) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClientSubnetWhiteList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterPartitionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultUserQuotaPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultViewQuotaPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemaInfoList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoragePolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ViewBox) validateClientSubnetWhiteList(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientSubnetWhiteList) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientSubnetWhiteList); i++ {
		if swag.IsZero(m.ClientSubnetWhiteList[i]) { // not required
			continue
		}

		if m.ClientSubnetWhiteList[i] != nil {
			if err := m.ClientSubnetWhiteList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ViewBox) validateClusterPartitionID(formats strfmt.Registry) error {

	if err := validate.Required("clusterPartitionId", "body", m.ClusterPartitionID); err != nil {
		return err
	}

	return nil
}

func (m *ViewBox) validateDefaultUserQuotaPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultUserQuotaPolicy) { // not required
		return nil
	}

	return nil
}

func (m *ViewBox) validateDefaultViewQuotaPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultViewQuotaPolicy) { // not required
		return nil
	}

	return nil
}

func (m *ViewBox) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ViewBox) validatePhysicalQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalQuota) { // not required
		return nil
	}

	return nil
}

var viewBoxTypeRemovalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kDontRemove","kMarkedForRemoval","kOkToRemove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		viewBoxTypeRemovalStatePropEnum = append(viewBoxTypeRemovalStatePropEnum, v)
	}
}

const (

	// ViewBoxRemovalStateKDontRemove captures enum value "kDontRemove"
	ViewBoxRemovalStateKDontRemove string = "kDontRemove"

	// ViewBoxRemovalStateKMarkedForRemoval captures enum value "kMarkedForRemoval"
	ViewBoxRemovalStateKMarkedForRemoval string = "kMarkedForRemoval"

	// ViewBoxRemovalStateKOkToRemove captures enum value "kOkToRemove"
	ViewBoxRemovalStateKOkToRemove string = "kOkToRemove"
)

// prop value enum
func (m *ViewBox) validateRemovalStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, viewBoxTypeRemovalStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ViewBox) validateRemovalState(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemovalStateEnum("removalState", "body", *m.RemovalState); err != nil {
		return err
	}

	return nil
}

func (m *ViewBox) validateSchemaInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.SchemaInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.SchemaInfoList); i++ {
		if swag.IsZero(m.SchemaInfoList[i]) { // not required
			continue
		}

		if m.SchemaInfoList[i] != nil {
			if err := m.SchemaInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ViewBox) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *ViewBox) validateStoragePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.StoragePolicy) { // not required
		return nil
	}

	if m.StoragePolicy != nil {
		if err := m.StoragePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this view box based on the context it is used
func (m *ViewBox) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClientSubnetWhiteList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterPartitionName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultUserQuotaPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDefaultViewQuotaPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemaInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStoragePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ViewBox) contextValidateClientSubnetWhiteList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClientSubnetWhiteList); i++ {

		if m.ClientSubnetWhiteList[i] != nil {

			if swag.IsZero(m.ClientSubnetWhiteList[i]) { // not required
				return nil
			}

			if err := m.ClientSubnetWhiteList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clientSubnetWhiteList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ViewBox) contextValidateClusterPartitionName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "clusterPartitionName", "body", m.ClusterPartitionName); err != nil {
		return err
	}

	return nil
}

func (m *ViewBox) contextValidateDefaultUserQuotaPolicy(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ViewBox) contextValidateDefaultViewQuotaPolicy(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ViewBox) contextValidatePhysicalQuota(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ViewBox) contextValidateSchemaInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SchemaInfoList); i++ {

		if m.SchemaInfoList[i] != nil {

			if swag.IsZero(m.SchemaInfoList[i]) { // not required
				return nil
			}

			if err := m.SchemaInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("schemaInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ViewBox) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if swag.IsZero(m.Stats) { // not required
			return nil
		}

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *ViewBox) contextValidateStoragePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.StoragePolicy != nil {

		if swag.IsZero(m.StoragePolicy) { // not required
			return nil
		}

		if err := m.StoragePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ViewBox) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ViewBox) UnmarshalBinary(b []byte) error {
	var res ViewBox
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
