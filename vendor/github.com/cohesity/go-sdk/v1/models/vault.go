// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Vault Vault.
//
// Specifies an external storage location and is equivalent to
// an External Target in the Cohesity Dashboard.
// A Vault can provide an additional Cloud Tier where cold data of the
// Cohesity Cluster can be stored in the Cloud.
// A Vault can also provide archive storage for backup data. This archive data
// is stored on Tapes and in Cloud Vaults.
//
// swagger:model Vault
type Vault struct {

	// Specifies the CA (certificate authority) trusted certificate.
	CaTrustedCertificate *string `json:"caTrustedCertificate,omitempty"`

	// Specifies the client CA  certificate. This certificate is in pem format.
	ClientCertificate *string `json:"clientCertificate,omitempty"`

	// Specifies the client private key. This certificate is in pem format.
	ClientPrivateKey *string `json:"clientPrivateKey,omitempty"`

	// Specifies the vault config used for Cloud Archival Direct.
	CloudArchivalDirectConfig *CloudArchivalDirectConfig `json:"cloudArchivalDirectConfig,omitempty"`

	// Specifies the cloud domain information.
	CloudDomainList []*CloudDomainList `json:"cloudDomainList"`

	// Specifies whether to send data to the Vault in a
	// compressed format.
	// 'kCompressionNone' indicates that data is not compressed.
	// 'kCompressionLow' indicates that data is compressed using LZ4 or Snappy.
	// 'kCompressionHigh' indicates that data is compressed in Gzip.
	// Enum: ["kCompressionNone","kCompressionLow","kCompressionHigh"]
	CompressionPolicy *string `json:"compressionPolicy,omitempty"`

	// Specifies the settings required to connect to the Vault (External Target).
	Config *VaultConfig `json:"config,omitempty"`

	// Specifies whether to manage the encryption key manually or let the
	// Cohesity Cluster manage it. If true, you must get the encryption key
	// store it outside the Cluster, before disaster strikes such as the
	// source local Cohesity Cluster being down.
	// You can get the encryption key by downloading it
	// using the Cohesity Dashboard or by calling the
	// GET /public/vaults/encryptionKey/{id} operation.
	CustomerManagingEncryptionKeys *bool `json:"customerManagingEncryptionKeys,omitempty"`

	// Specifies whether to deduplicate data before sending it to the Vault.
	DedupEnabled *bool `json:"dedupEnabled,omitempty"`

	// Specifies whether DEK(Data Encryption Key) rotation is enabled for this
	// vault. This is applicable only when the viewbox uses AWS or similar KMS
	// in which the KEK (Key Encryption Key) is not created and maintained by
	// Cohesity. For Internal KMS and keys stored in Safenet servers, DEK
	// rotation will not be performed.
	DekRotationEnabled *bool `json:"dekRotationEnabled,omitempty"`

	// Specifies the error message when deleting a vault.
	DeleteVaultError *string `json:"deleteVaultError,omitempty"`

	// Specifies a description about the Vault.
	Description *string `json:"description,omitempty"`

	// Desired location for write ahead logs(wal).
	// 'kHomePartition' indicates desired wal location to be the home partition.
	// 'kDisk' indicates desired wal location to be the same disk as chunk repo.
	// 'kScribe' indicates desired wal location to be scribe.
	// 'kScribeTable' indicates chunk repository state is kept as key-value
	// pairs in scribe.
	// Enum: ["kHomePartition","kDisk","kScribe","kScribeTable"]
	DesiredWalLocation *string `json:"desiredWalLocation,omitempty"`

	// Specifies whether object lock is enabled or not on the vault.
	EnableObjectLock *bool `json:"enableObjectLock,omitempty"`

	// Specifies if the encryption key file has been downloaded using the
	// Cohesity Dashboard (Cohesity UI).
	// If true, the encryption key has been downloaded using the Cohesity
	// Dashboard. An encryption key can only be downloaded once using the
	// Cohesity Dashboard.
	EncryptionKeyFileDownloaded *bool `json:"encryptionKeyFileDownloaded,omitempty"`

	// Specifies whether to send and store data in an encrypted format.
	// 'kEncryptionNone' indicates the data is not encrypted.
	// 'kEncryptionStrong' indicates the data is encrypted.
	// Enum: ["kEncryptionNone","kEncryptionStrong","kEncryptionWeak"]
	EncryptionPolicy *string `json:"encryptionPolicy,omitempty"`

	// Specifies the type of Vault.
	// 'kNearline' indicates a Google Nearline Vault.
	// 'kGlacier' indicates an AWS Glacier Vault.
	// 'kS3' indicates an AWS S3 Vault.
	// 'kAzureStandard' indicates a Microsoft Azure Standard Vault.
	// 'kS3Compatible' indicates an S3 Compatible Vault.
	// (See the online help for supported types.)
	// 'kQStarTape' indicates a QStar Tape Vault.
	// 'kGoogleStandard' indicates a Google Standard Vault.
	// 'kGoogleDRA' indicates a Google DRA Vault.
	// 'kAmazonS3StandardIA' indicates an Amazon S3 Standard-IA Vault.
	// 'kAWSGovCloud' indicates an AWS Gov Cloud Vault.
	// 'kNAS' indicates a NAS Vault.
	// 'kColdline' indicates a Google Coldline Vault.
	// 'kAzureGovCloud' indicates a Microsoft Azure Gov Cloud Vault.
	// 'kAzureArchive' indicates an Azure Archive Vault.
	// 'kAzure' indicates an Azure Vault.
	// 'kGoogle' indicates a Google Vault.
	// 'kAmazon' indicates an Amazon Vault.
	// 'kOracle' indicates an Oracle Vault.
	// 'kOracleTierStandard' indicates an Oracle Tier Standard Vault.
	// 'kOracleTierArchive' indicates an Oracle Tier Archive Vault.
	// 'kAmazonC2S' indicates an Amazon Commercial Cloud Services Vault.
	// Enum: ["kNearline","kGlacier","kS3","kAzureStandard","kS3Compatible","kQStarTape","kGoogleStandard","kGoogleDRA","kAmazonS3StandardIA","kAWSGovCloud","kNAS","kColdline","kAzureGovCloud","kAzureArchive","kAzure","kGoogle","kAmazon","kOracle","kOracleTierStandard","kOracleTierArchive","kAmazonC2S"]
	ExternalTargetType *string `json:"externalTargetType,omitempty"`

	// Specifies the number days between full archives to the Vault.
	// The current default is 90 days.
	// This is only meaningful when incrementalArchivesEnabled is true and
	// the Vault usage type is kArchival.
	FullArchiveIntervalDays *int64 `json:"fullArchiveIntervalDays,omitempty"`

	// Specifies the global identifier of the Vault.
	GlobalID *string `json:"globalId,omitempty"`

	// Specifies an id that identifies the Vault.
	ID *int64 `json:"id,omitempty"`

	// Specifies whether to perform incremental archival when sending data
	// to the Vault.
	// If false, only full backups are performed.
	// If true, incremental backups are performed between the full backups.
	IncrementalArchivesEnabled *bool `json:"incrementalArchivesEnabled,omitempty"`

	// Specifies whether the vault is aws snowball or not.
	IsAwsSnowball *bool `json:"isAwsSnowball,omitempty"`

	// Specifies whether forever incremental archival is enabled on this vault.
	IsForeverIncrementalArchiveEnabled *bool `json:"isForeverIncrementalArchiveEnabled,omitempty"`

	// Specifies if given password is not encrypted or not in the cluster config.
	IsPasswordEncrypted *bool `json:"isPasswordEncrypted,omitempty"`

	// Specifies the time (in microseconds) when the encryption key file was
	// downloaded from the Cohesity Dashboard (Cohesity UI).
	// An encryption key can only be downloaded once
	// using the Cohesity Dashboard.
	KeyFileDownloadTimeUsecs *int64 `json:"keyFileDownloadTimeUsecs,omitempty"`

	// Specifies the user who downloaded the encryption key from the
	// Cohesity Dashboard (Cohesity UI). This field
	// is only populated if encryption is enabled for the Vault and
	// customerManagingEncryptionKeys is true.
	KeyFileDownloadUser *string `json:"keyFileDownloadUser,omitempty"`

	// Specifies the associated KMS Server ID.
	KmsServerID *int64 `json:"kmsServerId,omitempty"`

	// Specifies the name of the Vault.
	Name *string `json:"name,omitempty"`

	// Specifies the state of the vault to be removed.
	// 'kDontRemove' means the state of object is functional and
	// it is not being removed.
	// 'kMarkedForRemoval' means the object is being removed.
	// 'kOkToRemove' means the object has been removed on the Cohesity Cluster and
	// if the object is physical, it can be removed from the Cohesity Cluster.
	// Enum: ["kDontRemove","kMarkedForRemoval","kOkToRemove"]
	RemovalState *string `json:"removalState,omitempty"`

	// Specifies the list of tenants which will have a access to current vault.
	TenantIds []string `json:"tenantIds"`

	// Specifies the type of Vault.
	// This field is deprecated. This field is split into ExternalTargetType in
	// and TierType in respective credentials. Initialize those
	// fields instead.
	// deprecated: true
	// 'kNearline' indicates a Google Nearline Vault.
	// 'kGlacier' indicates an AWS Glacier Vault.
	// 'kS3' indicates an AWS S3 Vault.
	// 'kAzureStandard' indicates a Microsoft Azure Standard Vault.
	// 'kS3Compatible' indicates an S3 Compatible Vault.
	// (See the online help for supported types.)
	// 'kQStarTape' indicates a QStar Tape Vault.
	// 'kGoogleStandard' indicates a Google Standard Vault.
	// 'kGoogleDRA' indicates a Google DRA Vault.
	// 'kAmazonS3StandardIA' indicates an Amazon S3 Standard-IA Vault.
	// 'kAWSGovCloud' indicates an AWS Gov Cloud Vault.
	// 'kNAS' indicates a NAS Vault.
	// 'kColdline' indicates a Google Coldline Vault.
	// 'kAzureGovCloud' indicates a Microsoft Azure Gov Cloud Vault.
	// 'kAzureArchive' indicates an Azure Archive Vault.
	// 'kAzure' indicates an Azure Vault.
	// 'kGoogle' indicates a Google Vault.
	// 'kAmazon' indicates an Amazon Vault.
	// 'kOracle' indicates an Oracle Vault.
	// 'kOracleTierStandard' indicates an Oracle Tier Standard Vault.
	// 'kOracleTierArchive' indicates an Oracle Tier Archive Vault.
	// 'kAmazonC2S' indicates an Amazon Commercial Cloud Services Vault.
	// Enum: ["kNearline","kGlacier","kS3","kAzureStandard","kS3Compatible","kQStarTape","kGoogleStandard","kGoogleDRA","kAmazonS3StandardIA","kAWSGovCloud","kNAS","kColdline","kAzureGovCloud","kAzureArchive","kAzure","kGoogle","kAmazon","kOracle","kOracleTierStandard","kOracleTierArchive","kAmazonC2S"]
	Type *string `json:"type,omitempty"`

	// Specifies the usage type of the Vault.
	// 'kArchival' indicates the Vault provides archive storage for backup data.
	// 'kCloudSpill' indicates the Vault provides additional storage for cold data.
	// 'kRpaasArchival' indicates the Vault is for RPaaS.
	// Enum: ["kArchival","kCloudSpill"]
	UsageType *string `json:"usageType,omitempty"`

	// Specifies bandwidth limit.
	VaultBandwidthLimits *VaultBandwidthLimits `json:"vaultBandwidthLimits,omitempty"`

	// Specifies the ownership context for consumption.
	// 'kOwnershipContextLocal' indicates the Vault is used for local consumption
	// 'kOwnershipContextFortKnox' indicates the Vault is used for Fortknox
	// consumption
	// Enum: ["kOwnershipContextLocal","kOwnershipContextFortKnox"]
	VaultOwnership *string `json:"vaultOwnership,omitempty"`

	// Specifies the name of the associated viewbox that is to be created while
	// registering vault in NextGen CE.
	ViewBoxName *string `json:"viewBoxName,omitempty"`
}

// Validate validates this vault
func (m *Vault) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCloudArchivalDirectConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudDomainList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompressionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDesiredWalLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalTargetType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsageType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaultBandwidthLimits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaultOwnership(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Vault) validateCloudArchivalDirectConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudArchivalDirectConfig) { // not required
		return nil
	}

	if m.CloudArchivalDirectConfig != nil {
		if err := m.CloudArchivalDirectConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudArchivalDirectConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudArchivalDirectConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Vault) validateCloudDomainList(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudDomainList) { // not required
		return nil
	}

	for i := 0; i < len(m.CloudDomainList); i++ {
		if swag.IsZero(m.CloudDomainList[i]) { // not required
			continue
		}

		if m.CloudDomainList[i] != nil {
			if err := m.CloudDomainList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloudDomainList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cloudDomainList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var vaultTypeCompressionPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCompressionNone","kCompressionLow","kCompressionHigh"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeCompressionPolicyPropEnum = append(vaultTypeCompressionPolicyPropEnum, v)
	}
}

const (

	// VaultCompressionPolicyKCompressionNone captures enum value "kCompressionNone"
	VaultCompressionPolicyKCompressionNone string = "kCompressionNone"

	// VaultCompressionPolicyKCompressionLow captures enum value "kCompressionLow"
	VaultCompressionPolicyKCompressionLow string = "kCompressionLow"

	// VaultCompressionPolicyKCompressionHigh captures enum value "kCompressionHigh"
	VaultCompressionPolicyKCompressionHigh string = "kCompressionHigh"
)

// prop value enum
func (m *Vault) validateCompressionPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeCompressionPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateCompressionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.CompressionPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateCompressionPolicyEnum("compressionPolicy", "body", *m.CompressionPolicy); err != nil {
		return err
	}

	return nil
}

func (m *Vault) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.Config) { // not required
		return nil
	}

	if m.Config != nil {
		if err := m.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("config")
			}
			return err
		}
	}

	return nil
}

var vaultTypeDesiredWalLocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kHomePartition","kDisk","kScribe","kScribeTable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeDesiredWalLocationPropEnum = append(vaultTypeDesiredWalLocationPropEnum, v)
	}
}

const (

	// VaultDesiredWalLocationKHomePartition captures enum value "kHomePartition"
	VaultDesiredWalLocationKHomePartition string = "kHomePartition"

	// VaultDesiredWalLocationKDisk captures enum value "kDisk"
	VaultDesiredWalLocationKDisk string = "kDisk"

	// VaultDesiredWalLocationKScribe captures enum value "kScribe"
	VaultDesiredWalLocationKScribe string = "kScribe"

	// VaultDesiredWalLocationKScribeTable captures enum value "kScribeTable"
	VaultDesiredWalLocationKScribeTable string = "kScribeTable"
)

// prop value enum
func (m *Vault) validateDesiredWalLocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeDesiredWalLocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateDesiredWalLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.DesiredWalLocation) { // not required
		return nil
	}

	// value enum
	if err := m.validateDesiredWalLocationEnum("desiredWalLocation", "body", *m.DesiredWalLocation); err != nil {
		return err
	}

	return nil
}

var vaultTypeEncryptionPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kEncryptionNone","kEncryptionStrong","kEncryptionWeak"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeEncryptionPolicyPropEnum = append(vaultTypeEncryptionPolicyPropEnum, v)
	}
}

const (

	// VaultEncryptionPolicyKEncryptionNone captures enum value "kEncryptionNone"
	VaultEncryptionPolicyKEncryptionNone string = "kEncryptionNone"

	// VaultEncryptionPolicyKEncryptionStrong captures enum value "kEncryptionStrong"
	VaultEncryptionPolicyKEncryptionStrong string = "kEncryptionStrong"

	// VaultEncryptionPolicyKEncryptionWeak captures enum value "kEncryptionWeak"
	VaultEncryptionPolicyKEncryptionWeak string = "kEncryptionWeak"
)

// prop value enum
func (m *Vault) validateEncryptionPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeEncryptionPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateEncryptionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateEncryptionPolicyEnum("encryptionPolicy", "body", *m.EncryptionPolicy); err != nil {
		return err
	}

	return nil
}

var vaultTypeExternalTargetTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNearline","kGlacier","kS3","kAzureStandard","kS3Compatible","kQStarTape","kGoogleStandard","kGoogleDRA","kAmazonS3StandardIA","kAWSGovCloud","kNAS","kColdline","kAzureGovCloud","kAzureArchive","kAzure","kGoogle","kAmazon","kOracle","kOracleTierStandard","kOracleTierArchive","kAmazonC2S"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeExternalTargetTypePropEnum = append(vaultTypeExternalTargetTypePropEnum, v)
	}
}

const (

	// VaultExternalTargetTypeKNearline captures enum value "kNearline"
	VaultExternalTargetTypeKNearline string = "kNearline"

	// VaultExternalTargetTypeKGlacier captures enum value "kGlacier"
	VaultExternalTargetTypeKGlacier string = "kGlacier"

	// VaultExternalTargetTypeKS3 captures enum value "kS3"
	VaultExternalTargetTypeKS3 string = "kS3"

	// VaultExternalTargetTypeKAzureStandard captures enum value "kAzureStandard"
	VaultExternalTargetTypeKAzureStandard string = "kAzureStandard"

	// VaultExternalTargetTypeKS3Compatible captures enum value "kS3Compatible"
	VaultExternalTargetTypeKS3Compatible string = "kS3Compatible"

	// VaultExternalTargetTypeKQStarTape captures enum value "kQStarTape"
	VaultExternalTargetTypeKQStarTape string = "kQStarTape"

	// VaultExternalTargetTypeKGoogleStandard captures enum value "kGoogleStandard"
	VaultExternalTargetTypeKGoogleStandard string = "kGoogleStandard"

	// VaultExternalTargetTypeKGoogleDRA captures enum value "kGoogleDRA"
	VaultExternalTargetTypeKGoogleDRA string = "kGoogleDRA"

	// VaultExternalTargetTypeKAmazonS3StandardIA captures enum value "kAmazonS3StandardIA"
	VaultExternalTargetTypeKAmazonS3StandardIA string = "kAmazonS3StandardIA"

	// VaultExternalTargetTypeKAWSGovCloud captures enum value "kAWSGovCloud"
	VaultExternalTargetTypeKAWSGovCloud string = "kAWSGovCloud"

	// VaultExternalTargetTypeKNAS captures enum value "kNAS"
	VaultExternalTargetTypeKNAS string = "kNAS"

	// VaultExternalTargetTypeKColdline captures enum value "kColdline"
	VaultExternalTargetTypeKColdline string = "kColdline"

	// VaultExternalTargetTypeKAzureGovCloud captures enum value "kAzureGovCloud"
	VaultExternalTargetTypeKAzureGovCloud string = "kAzureGovCloud"

	// VaultExternalTargetTypeKAzureArchive captures enum value "kAzureArchive"
	VaultExternalTargetTypeKAzureArchive string = "kAzureArchive"

	// VaultExternalTargetTypeKAzure captures enum value "kAzure"
	VaultExternalTargetTypeKAzure string = "kAzure"

	// VaultExternalTargetTypeKGoogle captures enum value "kGoogle"
	VaultExternalTargetTypeKGoogle string = "kGoogle"

	// VaultExternalTargetTypeKAmazon captures enum value "kAmazon"
	VaultExternalTargetTypeKAmazon string = "kAmazon"

	// VaultExternalTargetTypeKOracle captures enum value "kOracle"
	VaultExternalTargetTypeKOracle string = "kOracle"

	// VaultExternalTargetTypeKOracleTierStandard captures enum value "kOracleTierStandard"
	VaultExternalTargetTypeKOracleTierStandard string = "kOracleTierStandard"

	// VaultExternalTargetTypeKOracleTierArchive captures enum value "kOracleTierArchive"
	VaultExternalTargetTypeKOracleTierArchive string = "kOracleTierArchive"

	// VaultExternalTargetTypeKAmazonC2S captures enum value "kAmazonC2S"
	VaultExternalTargetTypeKAmazonC2S string = "kAmazonC2S"
)

// prop value enum
func (m *Vault) validateExternalTargetTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeExternalTargetTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateExternalTargetType(formats strfmt.Registry) error {
	if swag.IsZero(m.ExternalTargetType) { // not required
		return nil
	}

	// value enum
	if err := m.validateExternalTargetTypeEnum("externalTargetType", "body", *m.ExternalTargetType); err != nil {
		return err
	}

	return nil
}

var vaultTypeRemovalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kDontRemove","kMarkedForRemoval","kOkToRemove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeRemovalStatePropEnum = append(vaultTypeRemovalStatePropEnum, v)
	}
}

const (

	// VaultRemovalStateKDontRemove captures enum value "kDontRemove"
	VaultRemovalStateKDontRemove string = "kDontRemove"

	// VaultRemovalStateKMarkedForRemoval captures enum value "kMarkedForRemoval"
	VaultRemovalStateKMarkedForRemoval string = "kMarkedForRemoval"

	// VaultRemovalStateKOkToRemove captures enum value "kOkToRemove"
	VaultRemovalStateKOkToRemove string = "kOkToRemove"
)

// prop value enum
func (m *Vault) validateRemovalStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeRemovalStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateRemovalState(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemovalStateEnum("removalState", "body", *m.RemovalState); err != nil {
		return err
	}

	return nil
}

var vaultTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNearline","kGlacier","kS3","kAzureStandard","kS3Compatible","kQStarTape","kGoogleStandard","kGoogleDRA","kAmazonS3StandardIA","kAWSGovCloud","kNAS","kColdline","kAzureGovCloud","kAzureArchive","kAzure","kGoogle","kAmazon","kOracle","kOracleTierStandard","kOracleTierArchive","kAmazonC2S"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeTypePropEnum = append(vaultTypeTypePropEnum, v)
	}
}

const (

	// VaultTypeKNearline captures enum value "kNearline"
	VaultTypeKNearline string = "kNearline"

	// VaultTypeKGlacier captures enum value "kGlacier"
	VaultTypeKGlacier string = "kGlacier"

	// VaultTypeKS3 captures enum value "kS3"
	VaultTypeKS3 string = "kS3"

	// VaultTypeKAzureStandard captures enum value "kAzureStandard"
	VaultTypeKAzureStandard string = "kAzureStandard"

	// VaultTypeKS3Compatible captures enum value "kS3Compatible"
	VaultTypeKS3Compatible string = "kS3Compatible"

	// VaultTypeKQStarTape captures enum value "kQStarTape"
	VaultTypeKQStarTape string = "kQStarTape"

	// VaultTypeKGoogleStandard captures enum value "kGoogleStandard"
	VaultTypeKGoogleStandard string = "kGoogleStandard"

	// VaultTypeKGoogleDRA captures enum value "kGoogleDRA"
	VaultTypeKGoogleDRA string = "kGoogleDRA"

	// VaultTypeKAmazonS3StandardIA captures enum value "kAmazonS3StandardIA"
	VaultTypeKAmazonS3StandardIA string = "kAmazonS3StandardIA"

	// VaultTypeKAWSGovCloud captures enum value "kAWSGovCloud"
	VaultTypeKAWSGovCloud string = "kAWSGovCloud"

	// VaultTypeKNAS captures enum value "kNAS"
	VaultTypeKNAS string = "kNAS"

	// VaultTypeKColdline captures enum value "kColdline"
	VaultTypeKColdline string = "kColdline"

	// VaultTypeKAzureGovCloud captures enum value "kAzureGovCloud"
	VaultTypeKAzureGovCloud string = "kAzureGovCloud"

	// VaultTypeKAzureArchive captures enum value "kAzureArchive"
	VaultTypeKAzureArchive string = "kAzureArchive"

	// VaultTypeKAzure captures enum value "kAzure"
	VaultTypeKAzure string = "kAzure"

	// VaultTypeKGoogle captures enum value "kGoogle"
	VaultTypeKGoogle string = "kGoogle"

	// VaultTypeKAmazon captures enum value "kAmazon"
	VaultTypeKAmazon string = "kAmazon"

	// VaultTypeKOracle captures enum value "kOracle"
	VaultTypeKOracle string = "kOracle"

	// VaultTypeKOracleTierStandard captures enum value "kOracleTierStandard"
	VaultTypeKOracleTierStandard string = "kOracleTierStandard"

	// VaultTypeKOracleTierArchive captures enum value "kOracleTierArchive"
	VaultTypeKOracleTierArchive string = "kOracleTierArchive"

	// VaultTypeKAmazonC2S captures enum value "kAmazonC2S"
	VaultTypeKAmazonC2S string = "kAmazonC2S"
)

// prop value enum
func (m *Vault) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

var vaultTypeUsageTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kArchival","kCloudSpill"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeUsageTypePropEnum = append(vaultTypeUsageTypePropEnum, v)
	}
}

const (

	// VaultUsageTypeKArchival captures enum value "kArchival"
	VaultUsageTypeKArchival string = "kArchival"

	// VaultUsageTypeKCloudSpill captures enum value "kCloudSpill"
	VaultUsageTypeKCloudSpill string = "kCloudSpill"
)

// prop value enum
func (m *Vault) validateUsageTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeUsageTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateUsageType(formats strfmt.Registry) error {
	if swag.IsZero(m.UsageType) { // not required
		return nil
	}

	// value enum
	if err := m.validateUsageTypeEnum("usageType", "body", *m.UsageType); err != nil {
		return err
	}

	return nil
}

func (m *Vault) validateVaultBandwidthLimits(formats strfmt.Registry) error {
	if swag.IsZero(m.VaultBandwidthLimits) { // not required
		return nil
	}

	if m.VaultBandwidthLimits != nil {
		if err := m.VaultBandwidthLimits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vaultBandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vaultBandwidthLimits")
			}
			return err
		}
	}

	return nil
}

var vaultTypeVaultOwnershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kOwnershipContextLocal","kOwnershipContextFortKnox"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vaultTypeVaultOwnershipPropEnum = append(vaultTypeVaultOwnershipPropEnum, v)
	}
}

const (

	// VaultVaultOwnershipKOwnershipContextLocal captures enum value "kOwnershipContextLocal"
	VaultVaultOwnershipKOwnershipContextLocal string = "kOwnershipContextLocal"

	// VaultVaultOwnershipKOwnershipContextFortKnox captures enum value "kOwnershipContextFortKnox"
	VaultVaultOwnershipKOwnershipContextFortKnox string = "kOwnershipContextFortKnox"
)

// prop value enum
func (m *Vault) validateVaultOwnershipEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vaultTypeVaultOwnershipPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vault) validateVaultOwnership(formats strfmt.Registry) error {
	if swag.IsZero(m.VaultOwnership) { // not required
		return nil
	}

	// value enum
	if err := m.validateVaultOwnershipEnum("vaultOwnership", "body", *m.VaultOwnership); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this vault based on the context it is used
func (m *Vault) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCloudArchivalDirectConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudDomainList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVaultBandwidthLimits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Vault) contextValidateCloudArchivalDirectConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudArchivalDirectConfig != nil {

		if swag.IsZero(m.CloudArchivalDirectConfig) { // not required
			return nil
		}

		if err := m.CloudArchivalDirectConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudArchivalDirectConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudArchivalDirectConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Vault) contextValidateCloudDomainList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CloudDomainList); i++ {

		if m.CloudDomainList[i] != nil {

			if swag.IsZero(m.CloudDomainList[i]) { // not required
				return nil
			}

			if err := m.CloudDomainList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloudDomainList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cloudDomainList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Vault) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.Config != nil {

		if swag.IsZero(m.Config) { // not required
			return nil
		}

		if err := m.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("config")
			}
			return err
		}
	}

	return nil
}

func (m *Vault) contextValidateVaultBandwidthLimits(ctx context.Context, formats strfmt.Registry) error {

	if m.VaultBandwidthLimits != nil {

		if swag.IsZero(m.VaultBandwidthLimits) { // not required
			return nil
		}

		if err := m.VaultBandwidthLimits.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vaultBandwidthLimits")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vaultBandwidthLimits")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Vault) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Vault) UnmarshalBinary(b []byte) error {
	var res Vault
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
