// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HypervVirtualMachine HyperV VirtualMachine Object.
//
// Specifies information about a VirtualMachine Object in HyperV environment.
//
// swagger:model HypervVirtualMachine
type HypervVirtualMachine struct {

	// Specifies whether the VM is Highly Available or not.
	IsHighlyAvailable *bool `json:"isHighlyAvailable,omitempty"`

	// Specifies the version of the VM. For example, 8.0, 5.0 etc.
	Version *string `json:"version,omitempty"`

	// Specifies an array of virtual disks that are part of the Virtual Machine.
	// This is populated for entities of type 'kVirtualMachine'.
	VirtualDisks []*VirtualDiskBasicInfo `json:"virtualDisks"`

	// Specifies the status of the VM for backup purpose.
	// overrideDescription: true
	// Specifies the backup status of a HyperV Virtual Machine object.
	// 'kSupported' indicates the agent on the VM can do backup.
	// 'kUnsupportedConfig' indicates the agent on the VM cannot do backup.
	// 'kMissing' indicates the VM is not found in SCVMM.
	// Enum: ["kSupported","kUnsupportedConfig","kMissing"]
	VMBackupStatus *string `json:"vmBackupStatus,omitempty"`

	// Specifies the type of backup supported by the VM.
	// overrideDescription: true
	// Specifies the type of an HyperV datastore object.
	// 'kRctBackup' indicates backup is done using RCT/checkpoints.
	// 'kVssBackup' indicates backup is done using VSS.
	// Enum: ["kRctBackup","kVssBackup"]
	VMBackupType *string `json:"vmBackupType,omitempty"`
}

// Validate validates this hyperv virtual machine
func (m *HypervVirtualMachine) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVirtualDisks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMBackupStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMBackupType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HypervVirtualMachine) validateVirtualDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.VirtualDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.VirtualDisks); i++ {
		if swag.IsZero(m.VirtualDisks[i]) { // not required
			continue
		}

		if m.VirtualDisks[i] != nil {
			if err := m.VirtualDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var hypervVirtualMachineTypeVMBackupStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSupported","kUnsupportedConfig","kMissing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hypervVirtualMachineTypeVMBackupStatusPropEnum = append(hypervVirtualMachineTypeVMBackupStatusPropEnum, v)
	}
}

const (

	// HypervVirtualMachineVMBackupStatusKSupported captures enum value "kSupported"
	HypervVirtualMachineVMBackupStatusKSupported string = "kSupported"

	// HypervVirtualMachineVMBackupStatusKUnsupportedConfig captures enum value "kUnsupportedConfig"
	HypervVirtualMachineVMBackupStatusKUnsupportedConfig string = "kUnsupportedConfig"

	// HypervVirtualMachineVMBackupStatusKMissing captures enum value "kMissing"
	HypervVirtualMachineVMBackupStatusKMissing string = "kMissing"
)

// prop value enum
func (m *HypervVirtualMachine) validateVMBackupStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, hypervVirtualMachineTypeVMBackupStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HypervVirtualMachine) validateVMBackupStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.VMBackupStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateVMBackupStatusEnum("vmBackupStatus", "body", *m.VMBackupStatus); err != nil {
		return err
	}

	return nil
}

var hypervVirtualMachineTypeVMBackupTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kRctBackup","kVssBackup"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		hypervVirtualMachineTypeVMBackupTypePropEnum = append(hypervVirtualMachineTypeVMBackupTypePropEnum, v)
	}
}

const (

	// HypervVirtualMachineVMBackupTypeKRctBackup captures enum value "kRctBackup"
	HypervVirtualMachineVMBackupTypeKRctBackup string = "kRctBackup"

	// HypervVirtualMachineVMBackupTypeKVssBackup captures enum value "kVssBackup"
	HypervVirtualMachineVMBackupTypeKVssBackup string = "kVssBackup"
)

// prop value enum
func (m *HypervVirtualMachine) validateVMBackupTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, hypervVirtualMachineTypeVMBackupTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HypervVirtualMachine) validateVMBackupType(formats strfmt.Registry) error {
	if swag.IsZero(m.VMBackupType) { // not required
		return nil
	}

	// value enum
	if err := m.validateVMBackupTypeEnum("vmBackupType", "body", *m.VMBackupType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this hyperv virtual machine based on the context it is used
func (m *HypervVirtualMachine) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVirtualDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HypervVirtualMachine) contextValidateVirtualDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VirtualDisks); i++ {

		if m.VirtualDisks[i] != nil {

			if swag.IsZero(m.VirtualDisks[i]) { // not required
				return nil
			}

			if err := m.VirtualDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *HypervVirtualMachine) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HypervVirtualMachine) UnmarshalBinary(b []byte) error {
	var res HypervVirtualMachine
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
