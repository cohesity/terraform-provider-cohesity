// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AmazonCloudCredentials Amazon Cloud Credentials.
//
// Specifies the cloud credentials to connect to a Amazon
// service account. Glacier, S3, and S3-compatible clouds all use these
// credentials.
//
// swagger:model AmazonCloudCredentials
type AmazonCloudCredentials struct {

	// Specifies whether this vault supports AWS Lambda based GC. A Lambda
	// function needs to be deployed in the customer's AWS environment or the IAM
	// user should have permissions to create one.
	IsLambdaBasedGCEnabled *bool `json:"IsLambdaBasedGCEnabled,omitempty"`

	// Specifies the access key for Amazon service account.
	// See the Cohesity online help for the value to specify for this field
	// based on the current S3 Compatible Vault (External Target) type.
	// For example for Iron Mountain, specify the user name from Iron Mountain
	// for this field.
	AccessKeyID *string `json:"accessKeyId,omitempty"`

	// Specifies the auth method used for the request
	// See the Cohesity online help for the value to specify for this field
	// based on the current S3-compatible Vault (External Target) type.
	// Specifies the authentication method to be used for API calls.
	// 'kUseIAMUser' indicates a user based authentication.
	// 'kUseIAMRole' indicates a role based authentication, used only for AWS CE.
	// 'kUseHelios' indicates a Helios based authentication.
	// Enum: ["kUseIAMUser","kUseIAMRole","kUseHelios"]
	AuthMethod *string `json:"authMethod,omitempty"`

	// Specifies the C2S Access Portal (CAP) which is used to get the aws
	// credentials in Amazon Commercial Cloud Service(C2S).
	C2sAccessPortal *C2SAccessPortal `json:"c2sAccessPortal,omitempty"`

	// Specifies the credential blob to authenticate with credential endpoint.
	CredentialBlob *string `json:"credentialBlob,omitempty"`

	// Specifies the credential process that generates the security token.
	CredentialEndpoint *string `json:"credentialEndpoint,omitempty"`

	// Specifies the iam role arn Amazon service account.
	// See the Cohesity online help for the value to specify for this field
	// based on the current S3-compatible Vault (External Target) type.
	IamRoleArn *string `json:"iamRoleArn,omitempty"`

	// Specifies a read-only iam role arn Amazon service account.
	// See the Cohesity online help for the value to specify for this field
	// based on the current S3-compatible Vault (External Target) type.
	ReadOnlyIamRoleArn *string `json:"readOnlyIamRoleArn,omitempty"`

	// Specifies the region to use for the Amazon service account.
	Region *string `json:"region,omitempty"`

	// Specifies the secret access key for Amazon service account.
	// See the Cohesity online help for the value to specify for this field
	// based on the current S3-compatible Vault (External Target) type.
	SecretAccessKey *string `json:"secretAccessKey,omitempty"`

	// Specifies the URL (Endpoint) for the service such as s3like.notamazon.com.
	// This field is only significant for S3-compatible cloud services.
	ServiceURL *string `json:"serviceUrl,omitempty"`

	// Specifies the version of the S3 Compliance.
	// This field must be set to 2 or 4 and the default version is 2.
	// This field is only significant for S3-compatible cloud services.
	// See the Cohesity online help for the supported S3-compatible Vault
	// (External Target) types and the value to specify for this field
	// based on the current S3-compatible Vault (External Target) type.
	SignatureVersion *int32 `json:"signatureVersion,omitempty"`

	// Specifies the storage class of AWS.
	// AmazonTierType specifies the storage class for AWS.
	// 'kAmazonS3Standard' indicates a tier type of Amazon properties that is
	// accessed frequently.
	// 'kAmazonS3StandardIA' indicates a tier type of Amazon properties that is
	// accessed less frequently, but requires rapid access when needed.
	// 'kAmazonGlacier' indicates a tier type of Amazon properties that is accessed
	// rarely.
	// 'kAmazonS3OneZoneIA' indicates a tier type of Amazon properties for
	// long-lived, but less frequently accessed data.
	// 'kAmazonS3IntelligentTiering' indicates a tier type of Amazon properties for
	// data with unknown or changing access patterns.
	// 'kAmazonS3Glacier' indicates a tier type of Amazon properties for
	// data that provides secure, durable object storage for long-term data
	// retention and digital preservation. It provides three options for access to
	// archives, from a few minutes to several hours.
	// 'kAmazonS3GlacierDeepArchive' indicates a tier type of Amazon properties for
	// data that provides secure, durable object storage for long-term data
	// retention and digital preservation. It provides two access options ranging
	// from 12 to 48 hours.
	// Enum: ["kAmazonS3Standard","kAmazonS3StandardIA","kAmazonGlacier","kAmazonS3OneZoneIA","kAmazonS3IntelligentTiering","kAmazonS3Glacier","kAmazonS3GlacierDeepArchive","kAmazonS3GlacierIR"]
	TierType *string `json:"tierType,omitempty"`

	// Specifies the list of all tiers for Amazon account.
	Tiers []string `json:"tiers"`

	// Specifies whether to use http or https to connect to the service.
	// If true, a secure connection (https) is used.
	// This field is only significant for S3-compatible cloud services.
	UseHTTPS *bool `json:"useHttps,omitempty"`
}

// Validate validates this amazon cloud credentials
func (m *AmazonCloudCredentials) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateC2sAccessPortal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTierType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var amazonCloudCredentialsTypeAuthMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUseIAMUser","kUseIAMRole","kUseHelios"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		amazonCloudCredentialsTypeAuthMethodPropEnum = append(amazonCloudCredentialsTypeAuthMethodPropEnum, v)
	}
}

const (

	// AmazonCloudCredentialsAuthMethodKUseIAMUser captures enum value "kUseIAMUser"
	AmazonCloudCredentialsAuthMethodKUseIAMUser string = "kUseIAMUser"

	// AmazonCloudCredentialsAuthMethodKUseIAMRole captures enum value "kUseIAMRole"
	AmazonCloudCredentialsAuthMethodKUseIAMRole string = "kUseIAMRole"

	// AmazonCloudCredentialsAuthMethodKUseHelios captures enum value "kUseHelios"
	AmazonCloudCredentialsAuthMethodKUseHelios string = "kUseHelios"
)

// prop value enum
func (m *AmazonCloudCredentials) validateAuthMethodEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, amazonCloudCredentialsTypeAuthMethodPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AmazonCloudCredentials) validateAuthMethod(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthMethodEnum("authMethod", "body", *m.AuthMethod); err != nil {
		return err
	}

	return nil
}

func (m *AmazonCloudCredentials) validateC2sAccessPortal(formats strfmt.Registry) error {
	if swag.IsZero(m.C2sAccessPortal) { // not required
		return nil
	}

	if m.C2sAccessPortal != nil {
		if err := m.C2sAccessPortal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c2sAccessPortal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("c2sAccessPortal")
			}
			return err
		}
	}

	return nil
}

var amazonCloudCredentialsTypeTierTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAmazonS3Standard","kAmazonS3StandardIA","kAmazonGlacier","kAmazonS3OneZoneIA","kAmazonS3IntelligentTiering","kAmazonS3Glacier","kAmazonS3GlacierDeepArchive","kAmazonS3GlacierIR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		amazonCloudCredentialsTypeTierTypePropEnum = append(amazonCloudCredentialsTypeTierTypePropEnum, v)
	}
}

const (

	// AmazonCloudCredentialsTierTypeKAmazonS3Standard captures enum value "kAmazonS3Standard"
	AmazonCloudCredentialsTierTypeKAmazonS3Standard string = "kAmazonS3Standard"

	// AmazonCloudCredentialsTierTypeKAmazonS3StandardIA captures enum value "kAmazonS3StandardIA"
	AmazonCloudCredentialsTierTypeKAmazonS3StandardIA string = "kAmazonS3StandardIA"

	// AmazonCloudCredentialsTierTypeKAmazonGlacier captures enum value "kAmazonGlacier"
	AmazonCloudCredentialsTierTypeKAmazonGlacier string = "kAmazonGlacier"

	// AmazonCloudCredentialsTierTypeKAmazonS3OneZoneIA captures enum value "kAmazonS3OneZoneIA"
	AmazonCloudCredentialsTierTypeKAmazonS3OneZoneIA string = "kAmazonS3OneZoneIA"

	// AmazonCloudCredentialsTierTypeKAmazonS3IntelligentTiering captures enum value "kAmazonS3IntelligentTiering"
	AmazonCloudCredentialsTierTypeKAmazonS3IntelligentTiering string = "kAmazonS3IntelligentTiering"

	// AmazonCloudCredentialsTierTypeKAmazonS3Glacier captures enum value "kAmazonS3Glacier"
	AmazonCloudCredentialsTierTypeKAmazonS3Glacier string = "kAmazonS3Glacier"

	// AmazonCloudCredentialsTierTypeKAmazonS3GlacierDeepArchive captures enum value "kAmazonS3GlacierDeepArchive"
	AmazonCloudCredentialsTierTypeKAmazonS3GlacierDeepArchive string = "kAmazonS3GlacierDeepArchive"

	// AmazonCloudCredentialsTierTypeKAmazonS3GlacierIR captures enum value "kAmazonS3GlacierIR"
	AmazonCloudCredentialsTierTypeKAmazonS3GlacierIR string = "kAmazonS3GlacierIR"
)

// prop value enum
func (m *AmazonCloudCredentials) validateTierTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, amazonCloudCredentialsTypeTierTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AmazonCloudCredentials) validateTierType(formats strfmt.Registry) error {
	if swag.IsZero(m.TierType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTierTypeEnum("tierType", "body", *m.TierType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this amazon cloud credentials based on the context it is used
func (m *AmazonCloudCredentials) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateC2sAccessPortal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AmazonCloudCredentials) contextValidateC2sAccessPortal(ctx context.Context, formats strfmt.Registry) error {

	if m.C2sAccessPortal != nil {

		if swag.IsZero(m.C2sAccessPortal) { // not required
			return nil
		}

		if err := m.C2sAccessPortal.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("c2sAccessPortal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("c2sAccessPortal")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AmazonCloudCredentials) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AmazonCloudCredentials) UnmarshalBinary(b []byte) error {
	var res AmazonCloudCredentials
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
