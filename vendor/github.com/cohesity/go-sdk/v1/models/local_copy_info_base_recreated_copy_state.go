// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// LocalCopyInfoBaseRecreatedCopyState Message proto encapsulating the recreated copy state.
//
// swagger:model LocalCopyInfoBase_RecreatedCopyState
type LocalCopyInfoBaseRecreatedCopyState struct {

	// Denotes the relative path of the directory if the magneto
	// RecreateLocalCopy API was for a single entity protected using object
	// based protection. This field is copied as such from Icebox Slave
	// CreateStubViewResult.
	EntityDirRelativePath *string `json:"entityDirRelativePath,omitempty"`

	// Current hydration status of the local copy. Note that if the copy was
	// created with kNoHydrate and then requested to be updated to
	// kFullyHydrate: this status will transition from kNotHydrated into
	// kHydrationInProgress until the hydration is successfully completed by
	// Icebox, when it will be finally set as kFullyHydrated. If the hydration
	// was cancelled in between, this will be set to kPartiallyHydrated even if
	// no actual work has been done by Icebox.
	//
	// The persistent state of the magneto background task which tracks the
	// progress of icebox hydration request -- will also persist and maintain
	// the list of unique request identifiers that requested magneto master for
	// an hydrated local copy for the specified snapshot. In case the hydration
	// request needs to be cancelled, the requestor would issue a cancel
	// hydration request using EditRecreatedLocalCopy gRPC API with the same
	// request identifier, which was used during the RecreateLocalCopy API
	// call. If the hydration is still in progress, the cancellation request
	// would be processed only if it matches one of the request identifiers
	// present in the waiters list. Upon cancellation request, the request_id
	// would be removed from the waiters list for that hydration task. However,
	// the actual cancellation of hydration task would be triggered only when
	// there are no more waiters, i.e., all the requests which were waiting for
	// that particular hydration task have issued a cancellation.
	//
	// Some additional points to note:
	// Any cancel request received after hydration completes will become a
	// no operation.
	// Any new RecreateLocalCopy request received after hydration gets
	// completed (while the recreated local copy hasn't expired yet) cannot
	// roll back the hydration status to some 'lower' hydrated status.
	// However the request can potentially extend the expiry time of the
	// local copy.
	//
	// Note: Any reads done on the local copy while it is in kNotHydrated state
	// could potentially hydrate it on-demand and make it partially hydrated.
	// However the above hydration cannot be tracked by magneto and so the
	// above status will remain as kNotHydrated in such cases unless an explict
	// RecreateLocalCopy gRPC API request to hydrate the local copy is received
	// by magneto.
	HydrationStatus *int32 `json:"hydrationStatus,omitempty"`

	// Denotes the int64 id of the above icebox stub view.
	IceboxStubViewID *int64 `json:"iceboxStubViewId,omitempty"`

	// Denotes the icebox stub view from which this recreated local copy was
	// cloned. If the local copy is not in kFullyHydrated status, then it is
	// necessary to ensure that the icebox stub view is still alive.
	IceboxStubViewName *string `json:"iceboxStubViewName,omitempty"`

	// Denotes the universal id of the source archive corresponding to the
	// above 'source_remote_target', from which this local copy was recreated.
	SourceArchiveUID *UniversalIDProto `json:"sourceArchiveUid,omitempty"`

	// Denotes the remote target which acted as a source for this recreated
	// local copy.
	SourceRemoteTarget *SnapshotTarget `json:"sourceRemoteTarget,omitempty"`
}

// Validate validates this local copy info base recreated copy state
func (m *LocalCopyInfoBaseRecreatedCopyState) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSourceArchiveUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceRemoteTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCopyInfoBaseRecreatedCopyState) validateSourceArchiveUID(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceArchiveUID) { // not required
		return nil
	}

	if m.SourceArchiveUID != nil {
		if err := m.SourceArchiveUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceArchiveUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceArchiveUid")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCopyInfoBaseRecreatedCopyState) validateSourceRemoteTarget(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceRemoteTarget) { // not required
		return nil
	}

	if m.SourceRemoteTarget != nil {
		if err := m.SourceRemoteTarget.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceRemoteTarget")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceRemoteTarget")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this local copy info base recreated copy state based on the context it is used
func (m *LocalCopyInfoBaseRecreatedCopyState) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSourceArchiveUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceRemoteTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCopyInfoBaseRecreatedCopyState) contextValidateSourceArchiveUID(ctx context.Context, formats strfmt.Registry) error {

	if m.SourceArchiveUID != nil {

		if swag.IsZero(m.SourceArchiveUID) { // not required
			return nil
		}

		if err := m.SourceArchiveUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceArchiveUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceArchiveUid")
			}
			return err
		}
	}

	return nil
}

func (m *LocalCopyInfoBaseRecreatedCopyState) contextValidateSourceRemoteTarget(ctx context.Context, formats strfmt.Registry) error {

	if m.SourceRemoteTarget != nil {

		if swag.IsZero(m.SourceRemoteTarget) { // not required
			return nil
		}

		if err := m.SourceRemoteTarget.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceRemoteTarget")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceRemoteTarget")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocalCopyInfoBaseRecreatedCopyState) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCopyInfoBaseRecreatedCopyState) UnmarshalBinary(b []byte) error {
	var res LocalCopyInfoBaseRecreatedCopyState
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
