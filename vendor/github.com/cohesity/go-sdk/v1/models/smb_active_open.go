// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SmbActiveOpen SMB Active Open File.
//
// Specifies an active open of an SMB file, its access and sharing information.
//
// swagger:model SmbActiveOpen
type SmbActiveOpen struct {

	// Specifies the access information.
	// 'kFileReadData' indicates the right to read data from the file or named
	// pipe.
	// 'kFileWriteData' indicates the right to write data into the file or named
	// pipe beyond the end of the file.
	// 'kFileAppendData' indicates the right to append data into the file or named
	// pipe.
	// 'kFileReadEa' indicates the right to read the extended attributes of the
	// file or named pipe.
	// 'kFileWriteEa' indicates the right to write or change the extended
	// attributes to the file or named pipe.
	// 'kFileExecute' indicates the right to delete entries within a directory.
	// 'kFileDeleteChild' indicates the right to execute the file.
	// 'kFileReadAttributes' indicates the right to read the attributes of the
	// file.
	// 'kFileWriteAttributes' indicates the right to change the attributes of the
	// file.
	// 'kDelete' indicates the right to delete the file.
	// 'kReadControl' indicates the right to read the security descriptor for the
	// file or named pipe.
	// 'kWriteDac' indicates the right to change the discretionary access control
	// list (DACL) in the security descriptor for the file or named pipe. For
	// the DACL data structure, see ACL in [MS-DTYP].
	// 'kWriteOwner' indicates the right to change the owner in the security
	// descriptor for the file or named pipe.
	// 'kSynchronize' is used only by SMB2 clients.
	// 'kAccessSystemSecurity' indicates the right to read or change the system
	// access control list (SACL) in the security descriptor for the file or
	// named pipe. For the SACL data structure, see ACL in [MS-DTYP].<42>
	// 'kMaximumAllowed' indicates that the client is requesting an open to the
	// file with the highest level of access the client has on this file.
	// If no access is granted for the client on this file, the server MUST
	// fail the open with STATUS_ACCESS_DENIED.
	// 'kGenericAll' indicates a request for all the access flags that are
	// previously listed except kMaximumAllowed and kAccessSystemSecurity.
	// 'kGenericExecute' indicates a request for the following combination of
	// access flags listed above:
	// kFileReadAttributes| kFileExecute| kSynchronize| kReadControl.
	// 'kGenericWrite' indicates a request for the following combination of
	// access flags listed above:
	// kFileWriteData| kFileAppendData| kFileWriteAttributes| kFileWriteEa|
	// kSynchronize| kReadControl.
	// 'kGenericRead' indicates a request for the following combination of
	// access flags listed above:
	// kFileReadData| kFileReadAttributes| kFileReadEa| kSynchronize|
	// kReadControl.
	AccessInfoList []string `json:"accessInfoList"`

	// Specifies the SMB lease info of the open item.
	LeaseInfo *SmbLeaseInfo `json:"leaseInfo,omitempty"`

	// Specifies the id of the active open.
	OpenID *int64 `json:"openId,omitempty"`

	// Specifies whether others are allowed to delete.
	OthersCanDelete *bool `json:"othersCanDelete,omitempty"`

	// Specifies whether others are allowed to read.
	OthersCanRead *bool `json:"othersCanRead,omitempty"`

	// Specifies whether others are allowed to write.
	OthersCanWrite *bool `json:"othersCanWrite,omitempty"`
}

// Validate validates this smb active open
func (m *SmbActiveOpen) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessInfoList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLeaseInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var smbActiveOpenAccessInfoListItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kFileReadData","kFileWriteData","kFileAppendData","kFileReadEa","kFileWriteEa","kFileExecute","kFileDeleteChild","kFileReadAttributes","kFileWriteAttributes","kDelete","kReadControl","kWriteDac","kWriteOwner","kSynchronize","kAccessSystemSecurity","kMaximumAllowed","kGenericAll","kGenericExecute","kGenericWrite","kGenericRead"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbActiveOpenAccessInfoListItemsEnum = append(smbActiveOpenAccessInfoListItemsEnum, v)
	}
}

func (m *SmbActiveOpen) validateAccessInfoListItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbActiveOpenAccessInfoListItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbActiveOpen) validateAccessInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.AccessInfoList); i++ {

		// value enum
		if err := m.validateAccessInfoListItemsEnum("accessInfoList"+"."+strconv.Itoa(i), "body", m.AccessInfoList[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *SmbActiveOpen) validateLeaseInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.LeaseInfo) { // not required
		return nil
	}

	if m.LeaseInfo != nil {
		if err := m.LeaseInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("leaseInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("leaseInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this smb active open based on the context it is used
func (m *SmbActiveOpen) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLeaseInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SmbActiveOpen) contextValidateLeaseInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.LeaseInfo != nil {

		if swag.IsZero(m.LeaseInfo) { // not required
			return nil
		}

		if err := m.LeaseInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("leaseInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("leaseInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SmbActiveOpen) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SmbActiveOpen) UnmarshalBinary(b []byte) error {
	var res SmbActiveOpen
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
