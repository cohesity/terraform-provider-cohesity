// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ConnectorParams Message that encapsulates the various params required to establish a
// connection with a particular environment.
//
// swagger:model ConnectorParams
type ConnectorParams struct {

	// Optional additional connector params might be needed to connect to an
	// environment.
	AdditionalParams *AdditionalConnectorParams `json:"additionalParams,omitempty"`

	// For some of the environments connection to endpoint is done through an
	// agent. This captures the agent endpoint information.
	AgentEndpoint *string `json:"agentEndpoint,omitempty"`

	// Optional agent port to use when connecting to the server.
	// If this is not specified, then environment specific default port will be
	// used.
	AgentPort *int32 `json:"agentPort,omitempty"`

	// 'network_realm_id' maintains the collection of connector_group_id.
	// Connector group id for the environment. If it is set, Magneto will
	// fetch the bifrost server based on <network_realm_id, connector_group_id>.
	//
	// For communication with iris, this field will be deprecated soon and
	// network_realm_info_vec should be used instead.
	ConnectorGroupID *int64 `json:"connectorGroupId,omitempty"`

	// Credentials that will be used to login to the environment.
	Credentials *Credentials `json:"credentials,omitempty"`

	// The endpoint URL of the environment (such as the address of the vCenter
	// instance for a VMware environment, etc).
	Endpoint *string `json:"endpoint,omitempty"`

	// Optionally the entity associated with the endpoint can be passed.
	// Information within the entity could be used in creation of an appropriate
	// connector context.
	Entity *EntityProto `json:"entity,omitempty"`

	// The host environment type. This is set for kPhysical type environment.
	HostType *int32 `json:"hostType,omitempty"`

	// A unique id associated with this connector params. This is a convenience
	// field and is used to maintain an index to different connection params.
	// This is generated at the time when the source is registered with Magneto.
	ID *int64 `json:"id,omitempty"`

	// The network-realm id of the tenant through which this source is
	// accessible. This realm could be a collection of hyxes. If this
	// is set(>= 0), tenant_id must also be set. Value of '0' has special
	// semantics, refer bifrost/base/constant.cc.
	//
	// This field should be used only for communication between magneto master
	// and slave.
	// For communication with iris, this field will be deprecated soon and
	// network_realm_info_vec should be used instead.
	NetworkRealmID *int64 `json:"networkRealmId,omitempty"`

	// The network-realm info vec of the tenant through which this source is
	// accessible. Each realm could be a collection of hyxes. If this
	// is set, tenant_id must also be set. Realm value of '0' has special
	// semantics, refer bifrost/base/constant.cc.
	NetworkRealmInfoVec []*NetworkRealmInfo `json:"networkRealmInfoVec"`

	// If set to true, inter agent communcation will be enabled and for every
	// GetAgentInfo call we will fill subnet information of all the nodes in
	// clustered entity.
	PopulateSubnetForAllClusterNodes *bool `json:"populateSubnetForAllClusterNodes,omitempty"`

	// Optional port to use when connecting to the server.
	// If this is not specified, then environment specific default port will be
	// used.
	Port *int32 `json:"port,omitempty"`

	// The tenant_id for the environment. This is used to remotely access
	// connectors and executors via bifrost.
	TenantID *string `json:"tenantId,omitempty"`

	// The type of environment to connect to.
	Type *int32 `json:"type,omitempty"`

	// A version that is associated with the params. This is updated anytime
	// any of the params change. This is used to discard older connector params.
	Version *int64 `json:"version,omitempty"`
}

// Validate validates this connector params
func (m *ConnectorParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdditionalParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkRealmInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConnectorParams) validateAdditionalParams(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalParams) { // not required
		return nil
	}

	if m.AdditionalParams != nil {
		if err := m.AdditionalParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalParams")
			}
			return err
		}
	}

	return nil
}

func (m *ConnectorParams) validateCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.Credentials) { // not required
		return nil
	}

	if m.Credentials != nil {
		if err := m.Credentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *ConnectorParams) validateEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.Entity) { // not required
		return nil
	}

	if m.Entity != nil {
		if err := m.Entity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entity")
			}
			return err
		}
	}

	return nil
}

func (m *ConnectorParams) validateNetworkRealmInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkRealmInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkRealmInfoVec); i++ {
		if swag.IsZero(m.NetworkRealmInfoVec[i]) { // not required
			continue
		}

		if m.NetworkRealmInfoVec[i] != nil {
			if err := m.NetworkRealmInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkRealmInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("networkRealmInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this connector params based on the context it is used
func (m *ConnectorParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdditionalParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkRealmInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConnectorParams) contextValidateAdditionalParams(ctx context.Context, formats strfmt.Registry) error {

	if m.AdditionalParams != nil {

		if swag.IsZero(m.AdditionalParams) { // not required
			return nil
		}

		if err := m.AdditionalParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("additionalParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("additionalParams")
			}
			return err
		}
	}

	return nil
}

func (m *ConnectorParams) contextValidateCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.Credentials != nil {

		if swag.IsZero(m.Credentials) { // not required
			return nil
		}

		if err := m.Credentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *ConnectorParams) contextValidateEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.Entity != nil {

		if swag.IsZero(m.Entity) { // not required
			return nil
		}

		if err := m.Entity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entity")
			}
			return err
		}
	}

	return nil
}

func (m *ConnectorParams) contextValidateNetworkRealmInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkRealmInfoVec); i++ {

		if m.NetworkRealmInfoVec[i] != nil {

			if swag.IsZero(m.NetworkRealmInfoVec[i]) { // not required
				return nil
			}

			if err := m.NetworkRealmInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("networkRealmInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("networkRealmInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorParams) UnmarshalBinary(b []byte) error {
	var res ConnectorParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
