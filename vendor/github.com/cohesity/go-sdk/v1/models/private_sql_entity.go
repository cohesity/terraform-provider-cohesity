// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PrivateSQLEntity private Sql entity
//
// swagger:model PrivateSqlEntity
type PrivateSQLEntity struct {

	// This is only set if the type is kAAGDatabase. It specifies information
	// about the all the copies of the AAG database.
	AagDbCopyInfoVec []*AAGDatabaseCopyInfo `json:"aagDbCopyInfoVec"`

	// This is only set if type is kAAG.
	AagInfo *PrivateAAGInfo `json:"aagInfo,omitempty"`

	// The human readable creation date and time of this database. It is
	// displayed in the time zone of the SQL server on which this database is
	// running.
	CreateDate *string `json:"createDate,omitempty"`

	// The name of the databsae. Only set if the type is kDatabase. The name
	// of a database may change over time.
	DatabaseName *string `json:"databaseName,omitempty"`

	// This is only set if type is kDatabase. If the database is part of an
	// AAG, this points to the corresponding AAG entity.
	DbAagEntityID *int64 `json:"dbAagEntityId,omitempty"`

	// This is only set if the type is kDatabase. If the database is part of
	// an AAG, this field stores the name of the AAG. This is needed by the UI
	// for display purposes. Note that 'aag_info' field is not set for database
	// entities.
	DbAagName *string `json:"dbAagName,omitempty"`

	// This is only set if the type is kDatabase. The versions of SQL server that
	// the database is compatible with.
	DbCompatibilityLevel *int64 `json:"dbCompatibilityLevel,omitempty"`

	// This is only set if the type is kDatabase. It has the latest known
	// information about the set of file groups for this db on the host.
	DbFileGroupInfoVec []*SQLDatabaseFileGroupInfo `json:"dbFileGroupInfoVec"`

	// This is only set if the type is kDatabase. It has the latest known
	// information about the set of database files on the host.
	DbFileInfoVec []*FileInfo `json:"dbFileInfoVec"`

	// This is only set if the type is kDatabase. It has the name of the user who
	// owns the database.
	DbOwnerUsername *string `json:"dbOwnerUsername,omitempty"`

	// Front end size information. An example use case is for billing purposes
	// in "[Backup | Data Management] as a Service" offering.
	// The total size of this entity. Currently this is only set for databases
	// and has the same value as 'total_size_bytes'.
	FrontEndSizeInfo *SizeInfo `json:"frontEndSizeInfo,omitempty"`

	// The friendly instance name of the SQL Server instance. Only set if
	// the type is kInstance.
	//
	// TODO(warren): Support unicode in instance names.
	InstanceName *string `json:"instanceName,omitempty"`

	// This is only set if the type is kAAG. If it is set to true, then we
	// consider the AAG as first class citizen and it is no longer a leaf entity.
	IsAagFirstClassCitizen *bool `json:"isAagFirstClassCitizen,omitempty"`

	// This is only set if type is kDatabase.
	// Whether this database is included as one available for backup according
	// to the SQL Server VSS writer. This may be false if either the state of
	// the databases is not online, or if the VSS writer is not online.
	IsAvailableForVssBackup *bool `json:"isAvailableForVssBackup,omitempty"`

	// This is only set if the type is kDatabase. It denotes when this db
	// entity is a cloned database.
	IsDatabaseCloned *bool `json:"isDatabaseCloned,omitempty"`

	// This specifies if the database has TDE enabled.
	IsEncrypted *bool `json:"isEncrypted,omitempty"`

	// This is only set if the type is kInstance or kDatabase.
	// Specifies if it is part of an FCI cluster
	IsFci *bool `json:"isFci,omitempty"`

	// This is only set if type is kDatabase.
	//
	// Set to true if this is a system database.
	IsSystemDb *bool `json:"isSystemDb,omitempty"`

	// The entity id of the owner entity (such as a VM). This is only set if
	// type is kInstance or kDatabase.
	OwnerID *int64 `json:"ownerId,omitempty"`

	// This is only set if the type if kDatabase. Specifies if the
	// database is read-only.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// The recovery model for the database. Only set if the type is kDatabase.
	RecoveryModel *int32 `json:"recoveryModel,omitempty"`

	// The identifier for the sql database or instance entity. If type is
	// kInstance, then sql_id identifies the instance. If type is kDatabase,
	// then sql_id identifies both the instance and database.
	//
	// This field is only set it type is kInstance or kDatabase.
	SQLID *SQLID `json:"sqlId,omitempty"`

	// The SQL instance info will be set for SQL instance entities.
	SQLInstanceInfo *SQLInstanceInfo `json:"sqlInstanceInfo,omitempty"`

	// Deprecated. Should use sql_instance_info instead.
	// TODO: Leonid - Remove after iris changes are checked in.
	// Will be removed after iris code is synced.
	// The version of the SQL instance.
	// The version will be used in database entities.
	SQLInstanceVersion *SQLServerInstanceVersion `json:"sqlInstanceVersion,omitempty"`

	// This is only set if type is kDatabase.
	// The state of the database as returned by SQL Server.
	SQLServerDbState *int32 `json:"sqlServerDbState,omitempty"`

	// The total size of this entity. Currently this is only set for databases.
	TotalSizeBytes *int64 `json:"totalSizeBytes,omitempty"`

	// The type of entity this proto refers to.
	Type *int32 `json:"type,omitempty"`
}

// Validate validates this private Sql entity
func (m *PrivateSQLEntity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAagDbCopyInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAagInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDbFileGroupInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDbFileInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrontEndSizeInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLInstanceInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSQLInstanceVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateSQLEntity) validateAagDbCopyInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.AagDbCopyInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.AagDbCopyInfoVec); i++ {
		if swag.IsZero(m.AagDbCopyInfoVec[i]) { // not required
			continue
		}

		if m.AagDbCopyInfoVec[i] != nil {
			if err := m.AagDbCopyInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aagDbCopyInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("aagDbCopyInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateSQLEntity) validateAagInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.AagInfo) { // not required
		return nil
	}

	if m.AagInfo != nil {
		if err := m.AagInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aagInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("aagInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) validateDbFileGroupInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.DbFileGroupInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.DbFileGroupInfoVec); i++ {
		if swag.IsZero(m.DbFileGroupInfoVec[i]) { // not required
			continue
		}

		if m.DbFileGroupInfoVec[i] != nil {
			if err := m.DbFileGroupInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dbFileGroupInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dbFileGroupInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateSQLEntity) validateDbFileInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.DbFileInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.DbFileInfoVec); i++ {
		if swag.IsZero(m.DbFileInfoVec[i]) { // not required
			continue
		}

		if m.DbFileInfoVec[i] != nil {
			if err := m.DbFileInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dbFileInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dbFileInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateSQLEntity) validateFrontEndSizeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.FrontEndSizeInfo) { // not required
		return nil
	}

	if m.FrontEndSizeInfo != nil {
		if err := m.FrontEndSizeInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) validateSQLID(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLID) { // not required
		return nil
	}

	if m.SQLID != nil {
		if err := m.SQLID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlId")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) validateSQLInstanceInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLInstanceInfo) { // not required
		return nil
	}

	if m.SQLInstanceInfo != nil {
		if err := m.SQLInstanceInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlInstanceInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlInstanceInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) validateSQLInstanceVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.SQLInstanceVersion) { // not required
		return nil
	}

	if m.SQLInstanceVersion != nil {
		if err := m.SQLInstanceVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlInstanceVersion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlInstanceVersion")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this private Sql entity based on the context it is used
func (m *PrivateSQLEntity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAagDbCopyInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAagInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDbFileGroupInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDbFileInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrontEndSizeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSQLID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSQLInstanceInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSQLInstanceVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateSQLEntity) contextValidateAagDbCopyInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AagDbCopyInfoVec); i++ {

		if m.AagDbCopyInfoVec[i] != nil {

			if swag.IsZero(m.AagDbCopyInfoVec[i]) { // not required
				return nil
			}

			if err := m.AagDbCopyInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("aagDbCopyInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("aagDbCopyInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateAagInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.AagInfo != nil {

		if swag.IsZero(m.AagInfo) { // not required
			return nil
		}

		if err := m.AagInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aagInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("aagInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateDbFileGroupInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DbFileGroupInfoVec); i++ {

		if m.DbFileGroupInfoVec[i] != nil {

			if swag.IsZero(m.DbFileGroupInfoVec[i]) { // not required
				return nil
			}

			if err := m.DbFileGroupInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dbFileGroupInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dbFileGroupInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateDbFileInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DbFileInfoVec); i++ {

		if m.DbFileInfoVec[i] != nil {

			if swag.IsZero(m.DbFileInfoVec[i]) { // not required
				return nil
			}

			if err := m.DbFileInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dbFileInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("dbFileInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateFrontEndSizeInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.FrontEndSizeInfo != nil {

		if swag.IsZero(m.FrontEndSizeInfo) { // not required
			return nil
		}

		if err := m.FrontEndSizeInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateSQLID(ctx context.Context, formats strfmt.Registry) error {

	if m.SQLID != nil {

		if swag.IsZero(m.SQLID) { // not required
			return nil
		}

		if err := m.SQLID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlId")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateSQLInstanceInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.SQLInstanceInfo != nil {

		if swag.IsZero(m.SQLInstanceInfo) { // not required
			return nil
		}

		if err := m.SQLInstanceInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlInstanceInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlInstanceInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateSQLEntity) contextValidateSQLInstanceVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.SQLInstanceVersion != nil {

		if swag.IsZero(m.SQLInstanceVersion) { // not required
			return nil
		}

		if err := m.SQLInstanceVersion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sqlInstanceVersion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sqlInstanceVersion")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateSQLEntity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateSQLEntity) UnmarshalBinary(b []byte) error {
	var res PrivateSQLEntity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
