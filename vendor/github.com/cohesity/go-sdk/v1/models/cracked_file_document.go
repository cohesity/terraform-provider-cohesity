// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CrackedFileDocument cracked file document
//
// swagger:model CrackedFileDocument
type CrackedFileDocument struct {

	// ad object metadata
	AdObjectMetadata *CrackedFileDocumentADObjectMetadata `json:"adObjectMetadata,omitempty"`

	// Type of data.
	DataType *int32 `json:"dataType,omitempty"`

	// Inferred document type.
	DocumentType *string `json:"documentType,omitempty"`

	// elasticsearch doc type
	ElasticsearchDocType *string `json:"elasticsearchDocType,omitempty"`

	// These are never set! They are provided here as a useful configuration
	// default.
	ElasticsearchIndexName *string `json:"elasticsearchIndexName,omitempty"`

	// exchange mailbox metadata
	ExchangeMailboxMetadata *CrackedFileDocumentExchangeMailboxMetadata `json:"exchangeMailboxMetadata,omitempty"`

	// Specifies the file category.
	FileCategory *int32 `json:"fileCategory,omitempty"`

	// file versions
	FileVersions []*CrackedFileDocumentFileVersion `json:"fileVersions"`

	// filename
	Filename *string `json:"filename,omitempty"`

	// Previous to 6.1, we used to have is_directory field which got renamed to
	// data_type in 6.1. Documents indexed before 6.1 in Elasticsearch will
	// still have the field stored as is_directory. We need to have a field with
	// name is_directory present in proto so that during parsing of a cfiledoc
	// from json to proto in iris, is_directory field is not dropped.
	// Note that this field will *never* be set by Yoda and is only added to
	// support parsing of old documents present in ES. This field should not be
	// used in code anywhere.
	// TODO(anshu): Remove this field once we have migrated cfiledb to Librarian.
	IsDirectory *bool `json:"isDirectory,omitempty"`

	// The mode in which writer was while writing this document in librarian.
	LibrarianMode *int32 `json:"librarianMode,omitempty"`

	// magneto entity metadata
	MagnetoEntityMetadata *CrackedFileDocumentMagnetoEntityMetadata `json:"magnetoEntityMetadata,omitempty"`

	// mailbox item metadata
	MailboxItemMetadata *CrackedFileDocumentMailboxItemMetadata `json:"mailboxItemMetadata,omitempty"`

	// nosql metadata
	NosqlMetadata *CrackedFileDocumentNoSQLMetadata `json:"nosqlMetadata,omitempty"`

	// o365 group metadata
	O365GroupMetadata *CrackedFileDocumentO365GroupMetadata `json:"o365GroupMetadata,omitempty"`

	// o365 teams metadata
	O365TeamsMetadata *CrackedFileDocumentO365TeamsMetadata `json:"o365TeamsMetadata,omitempty"`

	// This is neither stored in the key, nor value. This field exists only for
	// returning complete info.
	// We use a separate instance of db per object id.
	ObjectID *MagnetoObjectID `json:"objectId,omitempty"`

	// one drive metadata
	OneDriveMetadata *CrackedFileDocumentOneDriveMetadata `json:"oneDriveMetadata,omitempty"`

	// public folder metadata
	PublicFolderMetadata *CrackedFileDocumentPublicFolderMetadata `json:"publicFolderMetadata,omitempty"`

	// Crc32(BinarySerializ(cohesity.magneto.EntityProto))
	// This is kept as a int64 to permit filtering by exact queries.
	RegisteredSourceHash *uint64 `json:"registeredSourceHash,omitempty"`

	// String id corresponding to the field above.
	// TODO(Shreshtha/Richa) : Populate this field in ops creating
	// CrackedFileDocument.
	RegisteredSourceStringID *string `json:"registeredSourceStringId,omitempty"`

	// sharepoint metadata
	SharepointMetadata *CrackedFileDocumentSharepointMetadata `json:"sharepointMetadata,omitempty"`

	// Field to store snapshot tags. This is a copy of keys in
	// snapshot_tags_association_map below and only used for indexing.
	SnapshotTagVec []string `json:"snapshotTagVec"`

	// Map from index into snapshot tags to list of snapshot ranges.
	SnapshotTagsAssociationMap map[string]TaggedSnapshots `json:"snapshotTagsAssociationMap,omitempty"`

	// Field to store document level tags.
	TagVec []string `json:"tagVec"`

	// todo(prann) : cleanup and reserve this
	TeamsChannelMetadata *CrackedFileDocumentTeamsChannelMetadata `json:"teamsChannelMetadata,omitempty"`

	// The Tenant ID that owns this file. This is always indexed even if no
	// tenant id owns this document. In case no tenant id owns this document, an
	// empty string is indexed to denote that no tenant owns this document.
	TenantID *string `json:"tenantId,omitempty"`

	// uda metadata
	UdaMetadata *CrackedFileDocumentUdaMetadata `json:"udaMetadata,omitempty"`

	// versions
	Versions []*CrackedFileDocumentVersionInfo `json:"versions"`

	// view box id (storage container)
	ViewBoxID *int64 `json:"viewBoxId,omitempty"`
}

// Validate validates this cracked file document
func (m *CrackedFileDocument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdObjectMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExchangeMailboxMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMagnetoEntityMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMailboxItemMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNosqlMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateO365GroupMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateO365TeamsMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOneDriveMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublicFolderMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSharepointMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotTagsAssociationMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeamsChannelMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUdaMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CrackedFileDocument) validateAdObjectMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.AdObjectMetadata) { // not required
		return nil
	}

	if m.AdObjectMetadata != nil {
		if err := m.AdObjectMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adObjectMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("adObjectMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateExchangeMailboxMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.ExchangeMailboxMetadata) { // not required
		return nil
	}

	if m.ExchangeMailboxMetadata != nil {
		if err := m.ExchangeMailboxMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exchangeMailboxMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exchangeMailboxMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateFileVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.FileVersions) { // not required
		return nil
	}

	for i := 0; i < len(m.FileVersions); i++ {
		if swag.IsZero(m.FileVersions[i]) { // not required
			continue
		}

		if m.FileVersions[i] != nil {
			if err := m.FileVersions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CrackedFileDocument) validateMagnetoEntityMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.MagnetoEntityMetadata) { // not required
		return nil
	}

	if m.MagnetoEntityMetadata != nil {
		if err := m.MagnetoEntityMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("magnetoEntityMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("magnetoEntityMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateMailboxItemMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.MailboxItemMetadata) { // not required
		return nil
	}

	if m.MailboxItemMetadata != nil {
		if err := m.MailboxItemMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mailboxItemMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mailboxItemMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateNosqlMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.NosqlMetadata) { // not required
		return nil
	}

	if m.NosqlMetadata != nil {
		if err := m.NosqlMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nosqlMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nosqlMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateO365GroupMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.O365GroupMetadata) { // not required
		return nil
	}

	if m.O365GroupMetadata != nil {
		if err := m.O365GroupMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("o365GroupMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("o365GroupMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateO365TeamsMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.O365TeamsMetadata) { // not required
		return nil
	}

	if m.O365TeamsMetadata != nil {
		if err := m.O365TeamsMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("o365TeamsMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("o365TeamsMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateObjectID(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectID) { // not required
		return nil
	}

	if m.ObjectID != nil {
		if err := m.ObjectID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("objectId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("objectId")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateOneDriveMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.OneDriveMetadata) { // not required
		return nil
	}

	if m.OneDriveMetadata != nil {
		if err := m.OneDriveMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oneDriveMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oneDriveMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validatePublicFolderMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.PublicFolderMetadata) { // not required
		return nil
	}

	if m.PublicFolderMetadata != nil {
		if err := m.PublicFolderMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("publicFolderMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("publicFolderMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateSharepointMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.SharepointMetadata) { // not required
		return nil
	}

	if m.SharepointMetadata != nil {
		if err := m.SharepointMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sharepointMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sharepointMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateSnapshotTagsAssociationMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotTagsAssociationMap) { // not required
		return nil
	}

	for k := range m.SnapshotTagsAssociationMap {

		if err := validate.Required("snapshotTagsAssociationMap"+"."+k, "body", m.SnapshotTagsAssociationMap[k]); err != nil {
			return err
		}
		if val, ok := m.SnapshotTagsAssociationMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshotTagsAssociationMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshotTagsAssociationMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *CrackedFileDocument) validateTeamsChannelMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.TeamsChannelMetadata) { // not required
		return nil
	}

	if m.TeamsChannelMetadata != nil {
		if err := m.TeamsChannelMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("teamsChannelMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("teamsChannelMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateUdaMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.UdaMetadata) { // not required
		return nil
	}

	if m.UdaMetadata != nil {
		if err := m.UdaMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udaMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("udaMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) validateVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.Versions) { // not required
		return nil
	}

	for i := 0; i < len(m.Versions); i++ {
		if swag.IsZero(m.Versions[i]) { // not required
			continue
		}

		if m.Versions[i] != nil {
			if err := m.Versions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cracked file document based on the context it is used
func (m *CrackedFileDocument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdObjectMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExchangeMailboxMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMagnetoEntityMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMailboxItemMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNosqlMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateO365GroupMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateO365TeamsMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOneDriveMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePublicFolderMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSharepointMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotTagsAssociationMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTeamsChannelMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUdaMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CrackedFileDocument) contextValidateAdObjectMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.AdObjectMetadata != nil {

		if swag.IsZero(m.AdObjectMetadata) { // not required
			return nil
		}

		if err := m.AdObjectMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adObjectMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("adObjectMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateExchangeMailboxMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.ExchangeMailboxMetadata != nil {

		if swag.IsZero(m.ExchangeMailboxMetadata) { // not required
			return nil
		}

		if err := m.ExchangeMailboxMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exchangeMailboxMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exchangeMailboxMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateFileVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FileVersions); i++ {

		if m.FileVersions[i] != nil {

			if swag.IsZero(m.FileVersions[i]) { // not required
				return nil
			}

			if err := m.FileVersions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fileVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fileVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CrackedFileDocument) contextValidateMagnetoEntityMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.MagnetoEntityMetadata != nil {

		if swag.IsZero(m.MagnetoEntityMetadata) { // not required
			return nil
		}

		if err := m.MagnetoEntityMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("magnetoEntityMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("magnetoEntityMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateMailboxItemMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.MailboxItemMetadata != nil {

		if swag.IsZero(m.MailboxItemMetadata) { // not required
			return nil
		}

		if err := m.MailboxItemMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mailboxItemMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mailboxItemMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateNosqlMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.NosqlMetadata != nil {

		if swag.IsZero(m.NosqlMetadata) { // not required
			return nil
		}

		if err := m.NosqlMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nosqlMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nosqlMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateO365GroupMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.O365GroupMetadata != nil {

		if swag.IsZero(m.O365GroupMetadata) { // not required
			return nil
		}

		if err := m.O365GroupMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("o365GroupMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("o365GroupMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateO365TeamsMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.O365TeamsMetadata != nil {

		if swag.IsZero(m.O365TeamsMetadata) { // not required
			return nil
		}

		if err := m.O365TeamsMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("o365TeamsMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("o365TeamsMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateObjectID(ctx context.Context, formats strfmt.Registry) error {

	if m.ObjectID != nil {

		if swag.IsZero(m.ObjectID) { // not required
			return nil
		}

		if err := m.ObjectID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("objectId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("objectId")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateOneDriveMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.OneDriveMetadata != nil {

		if swag.IsZero(m.OneDriveMetadata) { // not required
			return nil
		}

		if err := m.OneDriveMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oneDriveMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oneDriveMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidatePublicFolderMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.PublicFolderMetadata != nil {

		if swag.IsZero(m.PublicFolderMetadata) { // not required
			return nil
		}

		if err := m.PublicFolderMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("publicFolderMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("publicFolderMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateSharepointMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.SharepointMetadata != nil {

		if swag.IsZero(m.SharepointMetadata) { // not required
			return nil
		}

		if err := m.SharepointMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sharepointMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sharepointMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateSnapshotTagsAssociationMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SnapshotTagsAssociationMap {

		if val, ok := m.SnapshotTagsAssociationMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *CrackedFileDocument) contextValidateTeamsChannelMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.TeamsChannelMetadata != nil {

		if swag.IsZero(m.TeamsChannelMetadata) { // not required
			return nil
		}

		if err := m.TeamsChannelMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("teamsChannelMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("teamsChannelMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateUdaMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.UdaMetadata != nil {

		if swag.IsZero(m.UdaMetadata) { // not required
			return nil
		}

		if err := m.UdaMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udaMetadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("udaMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *CrackedFileDocument) contextValidateVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Versions); i++ {

		if m.Versions[i] != nil {

			if swag.IsZero(m.Versions[i]) { // not required
				return nil
			}

			if err := m.Versions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CrackedFileDocument) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CrackedFileDocument) UnmarshalBinary(b []byte) error {
	var res CrackedFileDocument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
