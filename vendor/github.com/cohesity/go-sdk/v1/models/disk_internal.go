// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DiskInternal DiskInternal is the struct for a Disk.
//
// swagger:model DiskInternal
type DiskInternal struct {

	// AvoidAccess specifies whether a disk is marked AvoidAccess.
	AvoidAccess *bool `json:"avoidAccess,omitempty"`

	// CancelRemoval specifies whether a MarkedForRemoval disk should
	// cancel the removal state and reset to kDontRemove.
	CancelRemoval *bool `json:"cancelRemoval,omitempty"`

	// CurrentNodeId is the Id of the Node to which the Disk belongs.
	CurrentNodeID *int64 `json:"currentNodeId,omitempty"`

	// CurrentNodeIp is the Ip of the Node to which the Disk belongs.
	CurrentNodeIP *string `json:"currentNodeIp,omitempty"`

	// DesiredWalLocation is the new desired location of write ahead logs(wal).
	// 'kHomePartition' indicates desired wal location to be the home partition.
	// 'kDisk' indicates desired wal location to be the same disk as chunk repo.
	// 'kScribe' indicates desired wal location to be scribe.
	// 'kScribeTable' indicates chunk repository state is kept as key-value
	// pairs in scribe.
	// Enum: ["kHomePartition","kDisk","kScribe","kScribeTable"]
	DesiredWalLocation *string `json:"desiredWalLocation,omitempty"`

	// HardwareInfo describes the hardware of the node.
	HardwareInfo *DiskHardwareInfo `json:"hardwareInfo,omitempty"`

	// Id is the Id of the Disk.
	ID *int64 `json:"id,omitempty"`

	// LastNodeId is the Node id of the node where this disk was last known to
	// reside.
	LastNodeID *int64 `json:"lastNodeId,omitempty"`

	// LocationInChassis is the location of the disk in the chassis.
	LocationInChassis *string `json:"locationInChassis,omitempty"`

	// MaxPhysicalCapacityBytes specifies the maximum physical capacity of the
	// disk in bytes.
	MaxPhysicalCapacityBytes *int64 `json:"maxPhysicalCapacityBytes,omitempty"`

	// MaxUsableCapacityBytes is the maximum capacity of the disk in bytes that
	// can be used.
	MaxUsableCapacityBytes *int64 `json:"maxUsableCapacityBytes,omitempty"`

	// MountPath is the mount path of the disk.
	MountPath *string `json:"mountPath,omitempty"`

	// MountProtocol is the mount protocol of the disk.
	MountProtocol *int32 `json:"mountProtocol,omitempty"`

	// PrecheckTimestampSecs specifies the last run time
	// of the pre-checks execution in Unix epoch timestamp in seconds
	PrecheckTimestampSecs *int64 `json:"precheckTimestampSecs,omitempty"`

	// ProgressPercentage is the overall progress percentage
	// in removing the entity.
	ProgressPercentage *int64 `json:"progressPercentage,omitempty"`

	// Removal progress for various components which are not acked yet.
	RemovalProgressList []*ComponentRemovalProgress `json:"removalProgressList"`

	// RemovalReason specifies the removal reason of the disk.
	// 'kAutoHealthCheck' means the entity health is bad.
	// 'kUserGracefulRemoval' means user initiated a graceful removal.
	// 'kUserAvoidAccess' means user initiated a mark offline.
	// 'kUserGracefulNodeRemoval' mean users initiated graceful node removal.
	// 'kUserRemoveDownNode' mean user initiated graceful removal of down node.
	RemovalReason []string `json:"removalReason"`

	// RemovalState specifies the removal state of the disk.
	// 'kDontRemove' means the state of object is functional and
	// it is not being removed.
	// 'kMarkedForRemoval' means the object is being removed.
	// 'kOkToRemove' means the object has been removed on the Cohesity Cluster and
	// if the object is physical, it can be removed from the Cohesity Cluster.
	// Enum: ["kDontRemove","kMarkedForRemoval","kOkToRemove"]
	RemovalState *string `json:"removalState,omitempty"`

	// RemovalTimestampSecs specifies the Unix epoch timestamp (in seconds)
	// when the entity was marked for removal.
	RemovalTimestampSecs *int64 `json:"removalTimestampSecs,omitempty"`

	// ReservationList is a slice containing the space reservation made by
	// various components.
	Reservations []*DiskReservation `json:"reservations"`

	// Services already acked for removal of this entity.
	ServicesAckedList []string `json:"servicesAckedList"`

	// [For CLI displays the string with ServicesNotAcked]
	// ServicesNotAcked specifies services that have not ACKed yet in string
	// format after the entity is marked for removal.
	ServicesNotAcked *string `json:"servicesNotAcked,omitempty"`

	// Services not acked yet for removal of this entity.
	ServicesNotAckedList []string `json:"servicesNotAckedList"`

	// SpaceAvail shows how much disk space is available.
	SpaceAvail *int64 `json:"spaceAvail,omitempty"`

	// SpaceUsed shows how much of the disk space is used.
	SpaceUsed *int64 `json:"spaceUsed,omitempty"`

	// Stats describes the disk stats.
	Stats *DiskStats `json:"stats,omitempty"`

	// StorageTier is the type of StorageTier.
	// StorageTierType represents the various values for the Storage Tier.
	// 'PCIeSSD' indicates storage tier type of Pci Solid State Drive.
	// 'SATA-SSD' indicates storage tier type of SATA Solid State Drive.
	// 'SATA-HDD' indicates storage tier type of SATA Hard Disk Drive.
	// 'CLOUD' indicates storage tier type of Cloud.
	// Enum: ["PCIeSSD","SATA-SSD","SATA-HDD","CLOUD"]
	StorageTier *string `json:"storageTier,omitempty"`

	// TimeRemaining is the overall total duration left to remove the entity.
	TimeRemaining *int64 `json:"timeRemaining,omitempty"`

	// UsageInPercentage shows how much of the disk space is used in percentage.
	UsageInPercentage *int64 `json:"usageInPercentage,omitempty"`

	// If ValidateOnly is true, MarkDiskForRemoval API returns only the
	// pre-check validations. Default is set to false.
	ValidateOnly *bool `json:"validateOnly,omitempty"`

	// ValidationChecks specifies list of pre-check validations
	ValidationChecks []*PreCheckValidation `json:"validationChecks"`

	// Vault Id is the optional vault id that this disk resides on.
	VaultID *int64 `json:"vaultId,omitempty"`
}

// Validate validates this disk internal
func (m *DiskInternal) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDesiredWalLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHardwareInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalProgressList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovalState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReservations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageTier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationChecks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var diskInternalTypeDesiredWalLocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kHomePartition","kDisk","kScribe","kScribeTable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskInternalTypeDesiredWalLocationPropEnum = append(diskInternalTypeDesiredWalLocationPropEnum, v)
	}
}

const (

	// DiskInternalDesiredWalLocationKHomePartition captures enum value "kHomePartition"
	DiskInternalDesiredWalLocationKHomePartition string = "kHomePartition"

	// DiskInternalDesiredWalLocationKDisk captures enum value "kDisk"
	DiskInternalDesiredWalLocationKDisk string = "kDisk"

	// DiskInternalDesiredWalLocationKScribe captures enum value "kScribe"
	DiskInternalDesiredWalLocationKScribe string = "kScribe"

	// DiskInternalDesiredWalLocationKScribeTable captures enum value "kScribeTable"
	DiskInternalDesiredWalLocationKScribeTable string = "kScribeTable"
)

// prop value enum
func (m *DiskInternal) validateDesiredWalLocationEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskInternalTypeDesiredWalLocationPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DiskInternal) validateDesiredWalLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.DesiredWalLocation) { // not required
		return nil
	}

	// value enum
	if err := m.validateDesiredWalLocationEnum("desiredWalLocation", "body", *m.DesiredWalLocation); err != nil {
		return err
	}

	return nil
}

func (m *DiskInternal) validateHardwareInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.HardwareInfo) { // not required
		return nil
	}

	if m.HardwareInfo != nil {
		if err := m.HardwareInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hardwareInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hardwareInfo")
			}
			return err
		}
	}

	return nil
}

func (m *DiskInternal) validateRemovalProgressList(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalProgressList) { // not required
		return nil
	}

	for i := 0; i < len(m.RemovalProgressList); i++ {
		if swag.IsZero(m.RemovalProgressList[i]) { // not required
			continue
		}

		if m.RemovalProgressList[i] != nil {
			if err := m.RemovalProgressList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var diskInternalRemovalReasonItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAutoHealthCheck","kUserGracefulRemoval","kUserAvoidAccess","kUserGracefulNodeRemoval","kUserRemoveDownNode"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskInternalRemovalReasonItemsEnum = append(diskInternalRemovalReasonItemsEnum, v)
	}
}

func (m *DiskInternal) validateRemovalReasonItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskInternalRemovalReasonItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DiskInternal) validateRemovalReason(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalReason) { // not required
		return nil
	}

	for i := 0; i < len(m.RemovalReason); i++ {

		// value enum
		if err := m.validateRemovalReasonItemsEnum("removalReason"+"."+strconv.Itoa(i), "body", m.RemovalReason[i]); err != nil {
			return err
		}

	}

	return nil
}

var diskInternalTypeRemovalStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kDontRemove","kMarkedForRemoval","kOkToRemove"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskInternalTypeRemovalStatePropEnum = append(diskInternalTypeRemovalStatePropEnum, v)
	}
}

const (

	// DiskInternalRemovalStateKDontRemove captures enum value "kDontRemove"
	DiskInternalRemovalStateKDontRemove string = "kDontRemove"

	// DiskInternalRemovalStateKMarkedForRemoval captures enum value "kMarkedForRemoval"
	DiskInternalRemovalStateKMarkedForRemoval string = "kMarkedForRemoval"

	// DiskInternalRemovalStateKOkToRemove captures enum value "kOkToRemove"
	DiskInternalRemovalStateKOkToRemove string = "kOkToRemove"
)

// prop value enum
func (m *DiskInternal) validateRemovalStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskInternalTypeRemovalStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DiskInternal) validateRemovalState(formats strfmt.Registry) error {
	if swag.IsZero(m.RemovalState) { // not required
		return nil
	}

	// value enum
	if err := m.validateRemovalStateEnum("removalState", "body", *m.RemovalState); err != nil {
		return err
	}

	return nil
}

func (m *DiskInternal) validateReservations(formats strfmt.Registry) error {
	if swag.IsZero(m.Reservations) { // not required
		return nil
	}

	for i := 0; i < len(m.Reservations); i++ {
		if swag.IsZero(m.Reservations[i]) { // not required
			continue
		}

		if m.Reservations[i] != nil {
			if err := m.Reservations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reservations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("reservations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DiskInternal) validateStats(formats strfmt.Registry) error {
	if swag.IsZero(m.Stats) { // not required
		return nil
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

var diskInternalTypeStorageTierPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PCIeSSD","SATA-SSD","SATA-HDD","CLOUD"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		diskInternalTypeStorageTierPropEnum = append(diskInternalTypeStorageTierPropEnum, v)
	}
}

const (

	// DiskInternalStorageTierPCIeSSD captures enum value "PCIeSSD"
	DiskInternalStorageTierPCIeSSD string = "PCIeSSD"

	// DiskInternalStorageTierSATADashSSD captures enum value "SATA-SSD"
	DiskInternalStorageTierSATADashSSD string = "SATA-SSD"

	// DiskInternalStorageTierSATADashHDD captures enum value "SATA-HDD"
	DiskInternalStorageTierSATADashHDD string = "SATA-HDD"

	// DiskInternalStorageTierCLOUD captures enum value "CLOUD"
	DiskInternalStorageTierCLOUD string = "CLOUD"
)

// prop value enum
func (m *DiskInternal) validateStorageTierEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, diskInternalTypeStorageTierPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DiskInternal) validateStorageTier(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageTier) { // not required
		return nil
	}

	// value enum
	if err := m.validateStorageTierEnum("storageTier", "body", *m.StorageTier); err != nil {
		return err
	}

	return nil
}

func (m *DiskInternal) validateValidationChecks(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidationChecks) { // not required
		return nil
	}

	for i := 0; i < len(m.ValidationChecks); i++ {
		if swag.IsZero(m.ValidationChecks[i]) { // not required
			continue
		}

		if m.ValidationChecks[i] != nil {
			if err := m.ValidationChecks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this disk internal based on the context it is used
func (m *DiskInternal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateHardwareInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemovalProgressList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReservations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidationChecks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DiskInternal) contextValidateHardwareInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.HardwareInfo != nil {

		if swag.IsZero(m.HardwareInfo) { // not required
			return nil
		}

		if err := m.HardwareInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hardwareInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hardwareInfo")
			}
			return err
		}
	}

	return nil
}

func (m *DiskInternal) contextValidateRemovalProgressList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RemovalProgressList); i++ {

		if m.RemovalProgressList[i] != nil {

			if swag.IsZero(m.RemovalProgressList[i]) { // not required
				return nil
			}

			if err := m.RemovalProgressList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("removalProgressList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DiskInternal) contextValidateReservations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Reservations); i++ {

		if m.Reservations[i] != nil {

			if swag.IsZero(m.Reservations[i]) { // not required
				return nil
			}

			if err := m.Reservations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reservations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("reservations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DiskInternal) contextValidateStats(ctx context.Context, formats strfmt.Registry) error {

	if m.Stats != nil {

		if swag.IsZero(m.Stats) { // not required
			return nil
		}

		if err := m.Stats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *DiskInternal) contextValidateValidationChecks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ValidationChecks); i++ {

		if m.ValidationChecks[i] != nil {

			if swag.IsZero(m.ValidationChecks[i]) { // not required
				return nil
			}

			if err := m.ValidationChecks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validationChecks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DiskInternal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DiskInternal) UnmarshalBinary(b []byte) error {
	var res DiskInternal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
