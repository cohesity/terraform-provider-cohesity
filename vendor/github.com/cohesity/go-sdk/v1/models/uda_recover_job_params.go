// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UdaRecoverJobParams Contains recovery params at the job level applicable for uda environment.
//
// swagger:model UdaRecoverJobParams
type UdaRecoverJobParams struct {

	// Types of backups supported.
	Capabilities *UdaSourceCapabilities `json:"capabilities,omitempty"`

	// Number of parallel streams to use for the restore.
	Concurrency *int32 `json:"concurrency,omitempty"`

	// Deployment type for the UDA agent.
	DeploymentType *int32 `json:"deploymentType,omitempty"`

	// If using external disks, this parameter will contain the user-requested
	// disk SKU for the slave to consume when requesting a disk from heimdall.
	ExternalDiskSku *string `json:"externalDiskSku,omitempty"`

	// The agent host environment type.
	HostType *int32 `json:"hostType,omitempty"`

	// List of hosts forming the UDA cluster.
	Hosts []string `json:"hosts"`

	// Directory on the host where views will be mounted.
	// (This is deprecated now and the value is derived from a gflag in agent.)
	LocalMountDir *string `json:"localMountDir,omitempty"`

	// Whether to mount a view during restore.
	MountView *bool `json:"mountView,omitempty"`

	// Max number of view mounts to use for the restore.
	Mounts *int32 `json:"mounts,omitempty"`

	// Control nodes to connect for control path ops.
	PreferredControlNodes []string `json:"preferredControlNodes"`

	// Custom arguments which are applicable to the objects to be restored.
	RestoreArgs *string `json:"restoreArgs,omitempty"`

	// Map to store custom arguments which will be provided to the recovery job
	// scripts.
	RestoreJobArgumentsMap map[string]UdaCustomArgument `json:"restoreJobArgumentsMap,omitempty"`

	// EntityProto for CreateRestoreTaskArg::restore_target_entity_id.
	// Set in magneto.
	RestoreTargetEntity *EntityProto `json:"restoreTargetEntity,omitempty"`

	// Includes UdaRecoverJobParams::restore_target_entity and its parents.
	// Passed so slave can take lock on these.
	RestoreTargetEntityParents []*EntityProto `json:"restoreTargetEntityParents"`

	// The time when the corresponding backup run was started.
	RunStartTimeUsecs *int64 `json:"runStartTimeUsecs,omitempty"`

	// Path where the source scripts will be located.
	ScriptDir *string `json:"scriptDir,omitempty"`

	// Custom arguments which will be provided to the source registration
	// scripts.
	SourceArgs *string `json:"sourceArgs,omitempty"`

	// Map to store custom arguments which will be provided to the source
	// registration scripts.
	SourceArgumentsMap map[string]UdaCustomArgument `json:"sourceArgumentsMap,omitempty"`

	// Universal Data Adapter source type for which recovery is being performed.
	SourceType *string `json:"sourceType,omitempty"`

	// This message captures all the details needed by UDA Restore to clone S3
	// views and access the S3 bucket.
	UdaS3ViewBackupProperties *UdaS3ViewBackupProperties `json:"udaS3ViewBackupProperties,omitempty"`

	// Whether S3 views should be used for restore.
	UseS3View *bool `json:"useS3View,omitempty"`
}

// Validate validates this uda recover job params
func (m *UdaRecoverJobParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCapabilities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreJobArgumentsMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreTargetEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreTargetEntityParents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceArgumentsMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUdaS3ViewBackupProperties(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UdaRecoverJobParams) validateCapabilities(formats strfmt.Registry) error {
	if swag.IsZero(m.Capabilities) { // not required
		return nil
	}

	if m.Capabilities != nil {
		if err := m.Capabilities.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capabilities")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capabilities")
			}
			return err
		}
	}

	return nil
}

func (m *UdaRecoverJobParams) validateRestoreJobArgumentsMap(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreJobArgumentsMap) { // not required
		return nil
	}

	for k := range m.RestoreJobArgumentsMap {

		if err := validate.Required("restoreJobArgumentsMap"+"."+k, "body", m.RestoreJobArgumentsMap[k]); err != nil {
			return err
		}
		if val, ok := m.RestoreJobArgumentsMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("restoreJobArgumentsMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("restoreJobArgumentsMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *UdaRecoverJobParams) validateRestoreTargetEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreTargetEntity) { // not required
		return nil
	}

	if m.RestoreTargetEntity != nil {
		if err := m.RestoreTargetEntity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restoreTargetEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("restoreTargetEntity")
			}
			return err
		}
	}

	return nil
}

func (m *UdaRecoverJobParams) validateRestoreTargetEntityParents(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreTargetEntityParents) { // not required
		return nil
	}

	for i := 0; i < len(m.RestoreTargetEntityParents); i++ {
		if swag.IsZero(m.RestoreTargetEntityParents[i]) { // not required
			continue
		}

		if m.RestoreTargetEntityParents[i] != nil {
			if err := m.RestoreTargetEntityParents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("restoreTargetEntityParents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("restoreTargetEntityParents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UdaRecoverJobParams) validateSourceArgumentsMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceArgumentsMap) { // not required
		return nil
	}

	for k := range m.SourceArgumentsMap {

		if err := validate.Required("sourceArgumentsMap"+"."+k, "body", m.SourceArgumentsMap[k]); err != nil {
			return err
		}
		if val, ok := m.SourceArgumentsMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sourceArgumentsMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sourceArgumentsMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

func (m *UdaRecoverJobParams) validateUdaS3ViewBackupProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.UdaS3ViewBackupProperties) { // not required
		return nil
	}

	if m.UdaS3ViewBackupProperties != nil {
		if err := m.UdaS3ViewBackupProperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udaS3ViewBackupProperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("udaS3ViewBackupProperties")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this uda recover job params based on the context it is used
func (m *UdaRecoverJobParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapabilities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreJobArgumentsMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreTargetEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreTargetEntityParents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceArgumentsMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUdaS3ViewBackupProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UdaRecoverJobParams) contextValidateCapabilities(ctx context.Context, formats strfmt.Registry) error {

	if m.Capabilities != nil {

		if swag.IsZero(m.Capabilities) { // not required
			return nil
		}

		if err := m.Capabilities.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capabilities")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capabilities")
			}
			return err
		}
	}

	return nil
}

func (m *UdaRecoverJobParams) contextValidateRestoreJobArgumentsMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.RestoreJobArgumentsMap {

		if val, ok := m.RestoreJobArgumentsMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *UdaRecoverJobParams) contextValidateRestoreTargetEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.RestoreTargetEntity != nil {

		if swag.IsZero(m.RestoreTargetEntity) { // not required
			return nil
		}

		if err := m.RestoreTargetEntity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restoreTargetEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("restoreTargetEntity")
			}
			return err
		}
	}

	return nil
}

func (m *UdaRecoverJobParams) contextValidateRestoreTargetEntityParents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RestoreTargetEntityParents); i++ {

		if m.RestoreTargetEntityParents[i] != nil {

			if swag.IsZero(m.RestoreTargetEntityParents[i]) { // not required
				return nil
			}

			if err := m.RestoreTargetEntityParents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("restoreTargetEntityParents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("restoreTargetEntityParents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UdaRecoverJobParams) contextValidateSourceArgumentsMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SourceArgumentsMap {

		if val, ok := m.SourceArgumentsMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *UdaRecoverJobParams) contextValidateUdaS3ViewBackupProperties(ctx context.Context, formats strfmt.Registry) error {

	if m.UdaS3ViewBackupProperties != nil {

		if swag.IsZero(m.UdaS3ViewBackupProperties) { // not required
			return nil
		}

		if err := m.UdaS3ViewBackupProperties.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udaS3ViewBackupProperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("udaS3ViewBackupProperties")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UdaRecoverJobParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UdaRecoverJobParams) UnmarshalBinary(b []byte) error {
	var res UdaRecoverJobParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
