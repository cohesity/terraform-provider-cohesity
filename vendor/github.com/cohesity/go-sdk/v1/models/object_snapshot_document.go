// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ObjectSnapshotDocument object snapshot document
//
// swagger:model ObjectSnapshotDocument
type ObjectSnapshotDocument struct {

	// Entity specific attributes.
	// Ex: environment type, owner_vm_name for databases.
	AttributeMap []*AddSnapshotArgKeyValuePair `json:"attributeMap"`

	// This contains information regarding auto protected entity that the entity
	// in the current task is part of. For e.g. if a protection job was created
	// specifying vApp as the source object then 'auto_protected_source' will be
	// populated with that vApp entity for every VM entity in the task. This is
	// so that we can show this info as part of the object search results and
	// also filter by the auto protected entity.
	AutoProtectedSource *PrivateEntityProto `json:"autoProtectedSource,omitempty"`

	// The type of the backup job that magneto ran.
	BackupType *int32 `json:"backupType,omitempty"`

	// Volume info for bootable volume found in latest snapshot. If this is known
	// then instead of searching volume mapping file (fstab/hive) in all volumes,
	// we first see it it's present here. Only if we fail to find here then we
	// search in all volumes.
	BootVolumeInfo *PrivateVolumeInfo `json:"bootVolumeInfo,omitempty"`

	// Cluster partition id.
	ClusterPartitionID *int64 `json:"clusterPartitionId,omitempty"`

	// Snapshot type of the object. This field is deprecated and is never
	// released in production.
	// TODO(dinesh): Remove this field in next release.
	DEPRECATEDSnapshotType *int32 `json:"dEPRECATEDSnapshotType,omitempty"`

	// Deprecated/
	DeprecatedSnapshotDir *string `json:"deprecatedSnapshotDir,omitempty"`

	// elasticsearch doc type
	ElasticsearchDocType *string `json:"elasticsearchDocType,omitempty"`

	// These are never set! They are provided here as a useful configuration
	// default.
	ElasticsearchIndexName *string `json:"elasticsearchIndexName,omitempty"`

	// If this field is set to true, that will mean, that migration has finished
	// for this particular object.
	FinishedLibrarianMigrationForCfileindex *bool `json:"finishedLibrarianMigrationForCfileindex,omitempty"`

	// Whether the AddSnapshotArg for which this doc was constructed is a
	// reindexing request.
	IsReindexingRequest *bool `json:"isReindexingRequest,omitempty"`

	// Name of the job that pulled the backup.
	JobName *string `json:"jobName,omitempty"`

	// We verify whether data in ES is in sync with objectDb and levelDb. This
	// field specifies the last time this verification was done.
	LastVerificationTimeSecs *int64 `json:"lastVerificationTimeSecs,omitempty"`

	// This field holds Nas related information.
	NasParams *ObjectSnapshotDocumentNasParams `json:"nasParams,omitempty"`

	// This field is set only if backup_type is kO365.
	O365Params *ObjectSnapshotDocumentO365Params `json:"o365Params,omitempty"`

	// Any other search tags that might be associated with the object.
	// Good example are IP address, moref id (for vmware), etc. Yoda will try to
	// pull some well known aliases from object_id.entity.....
	ObjectAliases []string `json:"objectAliases"`

	// Key fields are declared as optional - that's because we clear them before
	// serializing the value. Please don't mark any field as required.
	ObjectID *MagnetoObjectID `json:"objectId,omitempty"`

	// Primary name of the object.
	ObjectName *string `json:"objectName,omitempty"`

	// Inferred OS type.
	OsType *string `json:"osType,omitempty"`

	// A hint as to what node should this object be read on.
	// This is just a hint where magneto can provide the id of the node that
	// pulled the snapshot. Yoda will try to schedule its processing on the same
	// node to minimize data movement over network.
	PreferredReadNodeID *int64 `json:"preferredReadNodeId,omitempty"`

	// The source that was accessed by the job that took this snapshot.
	// e.g., it could be the vCenter in a vmware environment.
	RegisteredSource *PrivateEntityProto `json:"registeredSource,omitempty"`

	// A unique 64 bit number for registered_source. This is not available yet,
	// so we use Crc32(BinarySerialize(cohesity.magneto.EntityProto)))
	RegisteredSourceHash *uint64 `json:"registeredSourceHash,omitempty"`

	// The Tenant ID that owns this document.
	TenantID *string `json:"tenantId,omitempty"`

	// All versions of this document we know about.
	Versions []*ObjectSnapshotDocumentVersionInfo `json:"versions"`

	// The internal id of the view box (storage container).
	// This is used for filtering results from search index.
	ViewBoxID *int64 `json:"viewBoxId,omitempty"`

	// These fields are not stored in Elasticsearch. This field should no longer
	// be populated, use view_name in VersionInfo instead. It will be populated
	// for old vm snapshots (pre 4.2).
	ViewName *string `json:"viewName,omitempty"`

	// Last modified time of volume mapping file (fstab/hive) found in latest
	// snapshot. If this is known then we compare it with current mtime of
	// mapping file to see if we need to read it again.
	VolMappingFileMtimeSecs *int64 `json:"volMappingFileMtimeSecs,omitempty"`

	// For each unique volume mount map we insert an entry in this field.
	VolumeMountIoInfoVersionVec []*ObjectSnapshotDocumentVolumeMountIOInfoMapVersion `json:"volumeMountIoInfoVersionVec"`

	// For each unique volume map we keep this field.
	VolumeVersionVec []*ObjectSnapshotDocumentVolumeMapVersion `json:"volumeVersionVec"`
}

// Validate validates this object snapshot document
func (m *ObjectSnapshotDocument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributeMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoProtectedSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBootVolumeInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNasParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateO365Params(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeMountIoInfoVersionVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeVersionVec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectSnapshotDocument) validateAttributeMap(formats strfmt.Registry) error {
	if swag.IsZero(m.AttributeMap) { // not required
		return nil
	}

	for i := 0; i < len(m.AttributeMap); i++ {
		if swag.IsZero(m.AttributeMap[i]) { // not required
			continue
		}

		if m.AttributeMap[i] != nil {
			if err := m.AttributeMap[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributeMap" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributeMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectSnapshotDocument) validateAutoProtectedSource(formats strfmt.Registry) error {
	if swag.IsZero(m.AutoProtectedSource) { // not required
		return nil
	}

	if m.AutoProtectedSource != nil {
		if err := m.AutoProtectedSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoProtectedSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoProtectedSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) validateBootVolumeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.BootVolumeInfo) { // not required
		return nil
	}

	if m.BootVolumeInfo != nil {
		if err := m.BootVolumeInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bootVolumeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bootVolumeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) validateNasParams(formats strfmt.Registry) error {
	if swag.IsZero(m.NasParams) { // not required
		return nil
	}

	if m.NasParams != nil {
		if err := m.NasParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nasParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nasParams")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) validateO365Params(formats strfmt.Registry) error {
	if swag.IsZero(m.O365Params) { // not required
		return nil
	}

	if m.O365Params != nil {
		if err := m.O365Params.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("o365Params")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("o365Params")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) validateObjectID(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectID) { // not required
		return nil
	}

	if m.ObjectID != nil {
		if err := m.ObjectID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("objectId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("objectId")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) validateRegisteredSource(formats strfmt.Registry) error {
	if swag.IsZero(m.RegisteredSource) { // not required
		return nil
	}

	if m.RegisteredSource != nil {
		if err := m.RegisteredSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registeredSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registeredSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) validateVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.Versions) { // not required
		return nil
	}

	for i := 0; i < len(m.Versions); i++ {
		if swag.IsZero(m.Versions[i]) { // not required
			continue
		}

		if m.Versions[i] != nil {
			if err := m.Versions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectSnapshotDocument) validateVolumeMountIoInfoVersionVec(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeMountIoInfoVersionVec) { // not required
		return nil
	}

	for i := 0; i < len(m.VolumeMountIoInfoVersionVec); i++ {
		if swag.IsZero(m.VolumeMountIoInfoVersionVec[i]) { // not required
			continue
		}

		if m.VolumeMountIoInfoVersionVec[i] != nil {
			if err := m.VolumeMountIoInfoVersionVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeMountIoInfoVersionVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeMountIoInfoVersionVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectSnapshotDocument) validateVolumeVersionVec(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeVersionVec) { // not required
		return nil
	}

	for i := 0; i < len(m.VolumeVersionVec); i++ {
		if swag.IsZero(m.VolumeVersionVec[i]) { // not required
			continue
		}

		if m.VolumeVersionVec[i] != nil {
			if err := m.VolumeVersionVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeVersionVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeVersionVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this object snapshot document based on the context it is used
func (m *ObjectSnapshotDocument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttributeMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoProtectedSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBootVolumeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNasParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateO365Params(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegisteredSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeMountIoInfoVersionVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeVersionVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectSnapshotDocument) contextValidateAttributeMap(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AttributeMap); i++ {

		if m.AttributeMap[i] != nil {

			if swag.IsZero(m.AttributeMap[i]) { // not required
				return nil
			}

			if err := m.AttributeMap[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("attributeMap" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("attributeMap" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateAutoProtectedSource(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoProtectedSource != nil {

		if swag.IsZero(m.AutoProtectedSource) { // not required
			return nil
		}

		if err := m.AutoProtectedSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("autoProtectedSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("autoProtectedSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateBootVolumeInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.BootVolumeInfo != nil {

		if swag.IsZero(m.BootVolumeInfo) { // not required
			return nil
		}

		if err := m.BootVolumeInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bootVolumeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bootVolumeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateNasParams(ctx context.Context, formats strfmt.Registry) error {

	if m.NasParams != nil {

		if swag.IsZero(m.NasParams) { // not required
			return nil
		}

		if err := m.NasParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nasParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nasParams")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateO365Params(ctx context.Context, formats strfmt.Registry) error {

	if m.O365Params != nil {

		if swag.IsZero(m.O365Params) { // not required
			return nil
		}

		if err := m.O365Params.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("o365Params")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("o365Params")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateObjectID(ctx context.Context, formats strfmt.Registry) error {

	if m.ObjectID != nil {

		if swag.IsZero(m.ObjectID) { // not required
			return nil
		}

		if err := m.ObjectID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("objectId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("objectId")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateRegisteredSource(ctx context.Context, formats strfmt.Registry) error {

	if m.RegisteredSource != nil {

		if swag.IsZero(m.RegisteredSource) { // not required
			return nil
		}

		if err := m.RegisteredSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registeredSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registeredSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Versions); i++ {

		if m.Versions[i] != nil {

			if swag.IsZero(m.Versions[i]) { // not required
				return nil
			}

			if err := m.Versions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateVolumeMountIoInfoVersionVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeMountIoInfoVersionVec); i++ {

		if m.VolumeMountIoInfoVersionVec[i] != nil {

			if swag.IsZero(m.VolumeMountIoInfoVersionVec[i]) { // not required
				return nil
			}

			if err := m.VolumeMountIoInfoVersionVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeMountIoInfoVersionVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeMountIoInfoVersionVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ObjectSnapshotDocument) contextValidateVolumeVersionVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeVersionVec); i++ {

		if m.VolumeVersionVec[i] != nil {

			if swag.IsZero(m.VolumeVersionVec[i]) { // not required
				return nil
			}

			if err := m.VolumeVersionVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeVersionVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeVersionVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ObjectSnapshotDocument) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ObjectSnapshotDocument) UnmarshalBinary(b []byte) error {
	var res ObjectSnapshotDocument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
