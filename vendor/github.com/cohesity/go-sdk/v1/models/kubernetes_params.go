// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// KubernetesParams Register Application Servers Parameters.
//
// Specifies the parameters required to register Application Servers
// running in a Protection Source.
//
// swagger:model KubernetesParams
type KubernetesParams struct {

	// Specifies the location of Datamover image in private registry.
	DatamoverImageLocation *string `json:"datamoverImageLocation,omitempty"`

	// Specifies Type of service to be deployed for communication with DataMover
	// pods. Currently, LoadBalancer and NodePort are supported.
	// [default = kNodePort].
	DatamoverServiceType *int32 `json:"datamoverServiceType,omitempty"`

	// Specifies the default VLAN parameters to be used for performing the
	// backup/restore of this entity.
	DefaultVlanParams *VlanParameters `json:"defaultVlanParams,omitempty"`

	// Specifies the location of the image for init containers.
	InitContainerImageLocation *string `json:"initContainerImageLocation,omitempty"`

	// Specifies the distribution if the environment is kKubernetes.
	// overrideDescription: true
	// Enum: ["kMainline","kOpenshift","kRancher","kEKS","kGKE","kAKS","kVMwareTanzu"]
	KubernetesDistribution *string `json:"kubernetesDistribution,omitempty"`

	// Specifies annotations to be put on services for IP allocation. Applicable
	// only when service is of type LoadBalancer.
	ServiceAnnotations []*VlanInfoServiceAnnotationsEntry `json:"serviceAnnotations"`

	// Specifies the location of Velero AWS plugin image in private registry.
	VeleroAwsPluginImageLocation *string `json:"veleroAwsPluginImageLocation,omitempty"`

	// Specifies the location of Velero image in private registry.
	VeleroImageLocation *string `json:"veleroImageLocation,omitempty"`

	// Specifies the location of the image for openshift plugin container.
	VeleroOpenshiftPluginImageLocation *string `json:"veleroOpenshiftPluginImageLocation,omitempty"`

	// Specifies VLAN information provided during registration.
	VlanInfoVec []*KubernetesVlanInfo `json:"vlanInfoVec"`
}

// Validate validates this kubernetes params
func (m *KubernetesParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultVlanParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKubernetesDistribution(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceAnnotations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlanInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *KubernetesParams) validateDefaultVlanParams(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultVlanParams) { // not required
		return nil
	}

	if m.DefaultVlanParams != nil {
		if err := m.DefaultVlanParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultVlanParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultVlanParams")
			}
			return err
		}
	}

	return nil
}

var kubernetesParamsTypeKubernetesDistributionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kMainline","kOpenshift","kRancher","kEKS","kGKE","kAKS","kVMwareTanzu"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		kubernetesParamsTypeKubernetesDistributionPropEnum = append(kubernetesParamsTypeKubernetesDistributionPropEnum, v)
	}
}

const (

	// KubernetesParamsKubernetesDistributionKMainline captures enum value "kMainline"
	KubernetesParamsKubernetesDistributionKMainline string = "kMainline"

	// KubernetesParamsKubernetesDistributionKOpenshift captures enum value "kOpenshift"
	KubernetesParamsKubernetesDistributionKOpenshift string = "kOpenshift"

	// KubernetesParamsKubernetesDistributionKRancher captures enum value "kRancher"
	KubernetesParamsKubernetesDistributionKRancher string = "kRancher"

	// KubernetesParamsKubernetesDistributionKEKS captures enum value "kEKS"
	KubernetesParamsKubernetesDistributionKEKS string = "kEKS"

	// KubernetesParamsKubernetesDistributionKGKE captures enum value "kGKE"
	KubernetesParamsKubernetesDistributionKGKE string = "kGKE"

	// KubernetesParamsKubernetesDistributionKAKS captures enum value "kAKS"
	KubernetesParamsKubernetesDistributionKAKS string = "kAKS"

	// KubernetesParamsKubernetesDistributionKVMwareTanzu captures enum value "kVMwareTanzu"
	KubernetesParamsKubernetesDistributionKVMwareTanzu string = "kVMwareTanzu"
)

// prop value enum
func (m *KubernetesParams) validateKubernetesDistributionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, kubernetesParamsTypeKubernetesDistributionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *KubernetesParams) validateKubernetesDistribution(formats strfmt.Registry) error {
	if swag.IsZero(m.KubernetesDistribution) { // not required
		return nil
	}

	// value enum
	if err := m.validateKubernetesDistributionEnum("kubernetesDistribution", "body", *m.KubernetesDistribution); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesParams) validateServiceAnnotations(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceAnnotations) { // not required
		return nil
	}

	for i := 0; i < len(m.ServiceAnnotations); i++ {
		if swag.IsZero(m.ServiceAnnotations[i]) { // not required
			continue
		}

		if m.ServiceAnnotations[i] != nil {
			if err := m.ServiceAnnotations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesParams) validateVlanInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.VlanInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.VlanInfoVec); i++ {
		if swag.IsZero(m.VlanInfoVec[i]) { // not required
			continue
		}

		if m.VlanInfoVec[i] != nil {
			if err := m.VlanInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this kubernetes params based on the context it is used
func (m *KubernetesParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDefaultVlanParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceAnnotations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVlanInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *KubernetesParams) contextValidateDefaultVlanParams(ctx context.Context, formats strfmt.Registry) error {

	if m.DefaultVlanParams != nil {

		if swag.IsZero(m.DefaultVlanParams) { // not required
			return nil
		}

		if err := m.DefaultVlanParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultVlanParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultVlanParams")
			}
			return err
		}
	}

	return nil
}

func (m *KubernetesParams) contextValidateServiceAnnotations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServiceAnnotations); i++ {

		if m.ServiceAnnotations[i] != nil {

			if swag.IsZero(m.ServiceAnnotations[i]) { // not required
				return nil
			}

			if err := m.ServiceAnnotations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesParams) contextValidateVlanInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VlanInfoVec); i++ {

		if m.VlanInfoVec[i] != nil {

			if swag.IsZero(m.VlanInfoVec[i]) { // not required
				return nil
			}

			if err := m.VlanInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *KubernetesParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *KubernetesParams) UnmarshalBinary(b []byte) error {
	var res KubernetesParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
