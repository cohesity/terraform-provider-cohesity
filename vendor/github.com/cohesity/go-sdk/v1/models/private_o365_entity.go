// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PrivateO365Entity private o365 entity
//
// swagger:model PrivateO365Entity
type PrivateO365Entity struct {

	// Specifies the map from the Attribute type to its value for the given
	// entity proto.
	// Since the map within proto message cannot have an enum as the key, the
	// internal implementation will ensure that the keys only belong to the
	// Attribute.Type enum.
	AttributeMap map[string]string `json:"attributeMap,omitempty"`

	// The city where this Office365 user entity is located.
	// This field is deprecated. Use 'attribute_map' instead.
	// TODO(tauseef): Deprecate this once 'attribute_map' usage is implemented.
	City *string `json:"city,omitempty"`

	// The country/region in which this Office365 user entity is located.
	// This field is deprecated. Use 'attribute_map' instead.
	// TODO(tauseef): Deprecate this once 'attribute_map' usage is implemented.
	Country *string `json:"country,omitempty"`

	// Department within the Office365 enterprise which the user belongs to.
	// This field is deprecated. Use 'attribute_map' instead.
	// TODO(tauseef): Deprecate this once 'attribute_map' usage is implemented.
	Department *string `json:"department,omitempty"`

	// This is a general description that could be set for some entities.
	Description *string `json:"description,omitempty"`

	// Designation of this Office365 user entity.
	// This field is deprecated. Use 'attribute_map' instead.
	// TODO(tauseef): Deprecate this once 'attribute_map' usage is implemented.
	Designation *string `json:"designation,omitempty"`

	// The unique id of the drive.
	DriveID *string `json:"driveId,omitempty"`

	// Is the entity has Archive Mailbox enabled or not.
	// Note: Only valid when the entity type is kUser.
	EntityArchiveMailboxEnabled *bool `json:"entityArchiveMailboxEnabled,omitempty"`

	// Is the entity has Mailbox enabled or not based on a licensed service plan.
	// Note: Only valid when the entity type is kUser.
	EntityMailboxEnabled *bool `json:"entityMailboxEnabled,omitempty"`

	// Is the entity has Mailbox enabled atleast once.
	EntityMailboxEnabledAtleastOnce *bool `json:"entityMailboxEnabledAtleastOnce,omitempty"`

	// The current size of the mailbox possessed by this entity. This size comes
	// from the mailbox usage report published by microsoft.
	EntityMailboxSize *int64 `json:"entityMailboxSize,omitempty"`

	// Mail box type. Only valid when the entity type is kUser.
	EntityMailboxType *int32 `json:"entityMailboxType,omitempty"`

	// kUser : OneDrive specific fields.
	// Is the entity has OneDrive enabled or not based on a licensed service
	// plan.
	// Note: Only valid when the entity type is kUser.
	EntityOneDriveEnabled *bool `json:"entityOneDriveEnabled,omitempty"`

	// Is the entity has OneDrive enabled atleast once.
	EntityOneDriveEnabledAtleastOnce *bool `json:"entityOneDriveEnabledAtleastOnce,omitempty"`

	// The current size of the one_drive possessed by this entity. If there are
	// multiple, we show/take into account the first one. This comes from a
	// generic user_level drive_info related API.
	EntityOneDriveSize *int64 `json:"entityOneDriveSize,omitempty"`

	// Front end size information. An example use case is for billing purposes
	// in "[Backup | Data Management] as a Service" offering.
	FrontEndSizeInfo *SizeInfo `json:"frontEndSizeInfo,omitempty"`

	// The UUID of the entities from graph api. A separate field is needed for
	// this for migration. Depending on the entity type this will be:
	// 1. kUser - user_uuid (from graph api).
	// 2. kGroup - group_uuid (from graph api).
	// 3. kSite - site_uuid (from graph api).
	// TODO(suman) : Since uuid field will be same as graph_uuid, deprecate this
	// post 6.6.
	GraphUUID *string `json:"graphUuid,omitempty"`

	// Group-specific parameters.
	GroupParams *EntityGroupParams `json:"groupParams,omitempty"`

	// The unique id of the Mailbox (Mailbox GUID).
	MailboxID *string `json:"mailboxId,omitempty"`

	// membership info vec
	MembershipInfoVec []*EntityGroupMembershipInfo `json:"membershipInfoVec"`

	// A human readabale name of the entity.
	Name *string `json:"name,omitempty"`

	// This field is only set when type is kMailbox/kUser/kGroup. This is primary
	// SMTP address.
	PrimarySMTPAddress *string `json:"primarySmtpAddress,omitempty"`

	// The list of entity ids of the windows physical host which will be used for
	// backup and recovery of templates of the site that belong to a tenant.
	// This will be used for Exchange Online PST download as well.
	// TODO(sandeep ravi): Add a maximum values validation.
	ProxyEntityIDVec []int64 `json:"proxyEntityIdVec"`

	// Expiry time period in seconds for the PST download option. The generated
	// PSTs will be expired after this time period and the PST conversion view
	// will be garbage collected.
	// Default expiry time value is 72 hours.
	PstDownloadOptionExpiryTimeSecs *int64 `json:"pstDownloadOptionExpiryTimeSecs,omitempty"`

	// Sharepoint domain name.
	SharepointDomainName *string `json:"sharepointDomainName,omitempty"`

	// Site-specific parameters.
	SiteParams *EntitySiteParams `json:"siteParams,omitempty"`

	// Site-specific parameters.
	TeamParams *EntityTeamParams `json:"teamParams,omitempty"`

	// The type of entity this proto refers to.
	Type *int32 `json:"type,omitempty"`

	// Since the kMailbox/KUser entity can have either uuid/mailbox_id as Mailbox
	// GUID, this is used as a flag while generating EntityHashString. Note:
	// This field is not persisted. Deprecate this once we have all the entities
	// migrated to use graph_uuid instead of the Mailbox GUID.
	// TODO(suman) : Deprecate this after all customers post 6.6.
	UseAlternateUUIDAsHashString *bool `json:"useAlternateUuidAsHashString,omitempty"`

	// This field is only set when the primary SMTP address is different from the
	// user's UPN.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`

	// UUID of the entity. Based on the entity type it can be any of the
	// following :
	// 1. kDomain - domain name
	// 2. Psuedo entities (kOutlook, kUsers, kGroups, kSites) - hard coded
	// strings (outlook, users, groups, sites).
	// 3. kMailbox - mailbox_uuid (from ews api)
	// 4. kUser - same as graph_uuid (from graph api).
	// 5. kGroup - same as graph_uuid (from graph api).
	// 6. kSite - same as graph_uuid (from graph api).
	UUID *string `json:"uuid,omitempty"`

	// URL that displays the item in the browser; this is applicable when type is
	// 'kSite'. When type is 'kGroup', it contains the underlying group site url.
	WebURL *string `json:"webUrl,omitempty"`
}

// Validate validates this private o365 entity
func (m *PrivateO365Entity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFrontEndSizeInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMembershipInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSiteParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeamParams(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateO365Entity) validateFrontEndSizeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.FrontEndSizeInfo) { // not required
		return nil
	}

	if m.FrontEndSizeInfo != nil {
		if err := m.FrontEndSizeInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateO365Entity) validateGroupParams(formats strfmt.Registry) error {
	if swag.IsZero(m.GroupParams) { // not required
		return nil
	}

	if m.GroupParams != nil {
		if err := m.GroupParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("groupParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("groupParams")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateO365Entity) validateMembershipInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.MembershipInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.MembershipInfoVec); i++ {
		if swag.IsZero(m.MembershipInfoVec[i]) { // not required
			continue
		}

		if m.MembershipInfoVec[i] != nil {
			if err := m.MembershipInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("membershipInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("membershipInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateO365Entity) validateSiteParams(formats strfmt.Registry) error {
	if swag.IsZero(m.SiteParams) { // not required
		return nil
	}

	if m.SiteParams != nil {
		if err := m.SiteParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("siteParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("siteParams")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateO365Entity) validateTeamParams(formats strfmt.Registry) error {
	if swag.IsZero(m.TeamParams) { // not required
		return nil
	}

	if m.TeamParams != nil {
		if err := m.TeamParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("teamParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("teamParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this private o365 entity based on the context it is used
func (m *PrivateO365Entity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFrontEndSizeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMembershipInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSiteParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTeamParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateO365Entity) contextValidateFrontEndSizeInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.FrontEndSizeInfo != nil {

		if swag.IsZero(m.FrontEndSizeInfo) { // not required
			return nil
		}

		if err := m.FrontEndSizeInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateO365Entity) contextValidateGroupParams(ctx context.Context, formats strfmt.Registry) error {

	if m.GroupParams != nil {

		if swag.IsZero(m.GroupParams) { // not required
			return nil
		}

		if err := m.GroupParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("groupParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("groupParams")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateO365Entity) contextValidateMembershipInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MembershipInfoVec); i++ {

		if m.MembershipInfoVec[i] != nil {

			if swag.IsZero(m.MembershipInfoVec[i]) { // not required
				return nil
			}

			if err := m.MembershipInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("membershipInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("membershipInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateO365Entity) contextValidateSiteParams(ctx context.Context, formats strfmt.Registry) error {

	if m.SiteParams != nil {

		if swag.IsZero(m.SiteParams) { // not required
			return nil
		}

		if err := m.SiteParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("siteParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("siteParams")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateO365Entity) contextValidateTeamParams(ctx context.Context, formats strfmt.Registry) error {

	if m.TeamParams != nil {

		if swag.IsZero(m.TeamParams) { // not required
			return nil
		}

		if err := m.TeamParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("teamParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("teamParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateO365Entity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateO365Entity) UnmarshalBinary(b []byte) error {
	var res PrivateO365Entity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
