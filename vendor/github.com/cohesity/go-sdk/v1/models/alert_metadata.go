// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AlertMetadata Alert Metadata
//
// AlertMetadata specifies metadata for a given alert type. All the alerts of a
// given alert type share the same metadata.
//
// swagger:model AlertMetadata
type AlertMetadata struct {

	// Specifies alert documentation one per each language supported.
	AlertDocumentList []*AlertDocument `json:"alertDocumentList"`

	// Specifies the Alert type bucket.
	// Specifies the Alert type bucket.
	// kHardware - Alerts related to hardware on which Cohesity software is running.
	// kSoftware - Alerts which are related to software components.
	// kDataService - Alerts related to data services.
	// kMaintenance - Alerts relates to maintenance activities.
	// Enum: ["kHardware","kSoftware","kDataService","kMaintenance"]
	AlertTypeBucket *string `json:"alertTypeBucket,omitempty"`

	// Specifies unique id for the alert type.
	AlertTypeID *int32 `json:"alertTypeId,omitempty"`

	// Specifies category of the alert type.
	// Specifies the category of an Alert.
	// kDisk - Alert associated with the disk.
	// kNode - Alert associated with general hardware on a specific node.
	// kCluster - Alert associated with general hardware in cluster level.
	// kChassis - Alert associated with the Chassis.
	// kPowerSupply - Alert associated with the power supply.
	// kCPU - Alert associated with the CPU usage.
	// kMemory - Alert associated with the RAM/Memory.
	// kTemperature - Alert associated with the temperature.
	// kFan - Alert associated with the fan.
	// kNIC - Alert associated with network chips and interfaces.
	// kFirmware - Alert associated with the firmware.
	// kNodeHealth - Alert associated with node health status.
	// kOperatingSystem - Alert associated with operating systems.
	// kDataPath - Alert associated with data management in the cluster.
	// kMetadata - Alert associated with metadata management.
	// kIndexing - Alert associated with indexing services.
	// kHelios - Alert associated with Helios.
	// kAppMarketPlace - Alert associated with App MarketPlace.
	// kSystemService -Alert associated with System service apps.
	// kLicense - Alert associated with licensing.
	// kSecurity - Alert associated with security.
	// kUpgrade - Alert associated with upgrade activities.
	// kClusterManagement - Alert associated with cluster management activities.
	// kAuditLog - Alert associated with audit log events.
	// kNetworking - Alert associated with networking issue.
	// kConfiguration - Alert associated with cluster or system configurations.
	// kStorageUsage - Alert associated with the disk/domain/cluster storage usage.
	// kFaultTolerance - Alert associated with the fault tolerance in different levels.
	// kBackupRestore - Alert associated with Backup-Restore job.
	// kArchivalRestore - Alert associated with Archival-Restore job.
	// kRemoteReplication - Alert associated with Replication job.
	// kQuota - Alert associated with Quotas.
	// kCDP - Alert associated with Continuous Data Protection.
	// kViewFailover - Alert associated with view Failover.
	// kDisasterRecovery - Alert associated with Disaster Recovery.
	// kStorageDevice - Alert associated with storage hardware(tape drives & libraries, Fiber HBAs used to attach devices, etc).
	// kStoragePool - Alert associated with storage pools -- logical groupings of similar kinds of storage hardware (disk, tape, etc) into which client data is stored.
	// kGeneralSoftwareFailure - Alert associated with general software failures - that don't fall into any known categories.
	// kAgent - Alert associated with agent based protection workloads.
	// Enum: ["kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature","kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kDataPath","kMetadata","kIndexing","kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade","kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage","kFaultTolerance","kBackupRestore","kArchivalRestore","kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kStorageDevice","kStoragePool","kGeneralSoftwareFailure","kAgent"]
	Category *string `json:"category,omitempty"`

	// Specifies dedup interval in seconds. If the same alert is raised multiple
	// times by any client in this duration, only one of them will be reported.
	DedupIntervalSeconds *int32 `json:"dedupIntervalSeconds,omitempty"`

	// Specifies if the alerts are to be deduped until the current one (if
	// any) is resolved.
	DedupUntilResolved *bool `json:"dedupUntilResolved,omitempty"`

	// Specifies whether to show the alert in the iris UI and CLI.
	HideAlertFromUser *bool `json:"hideAlertFromUser,omitempty"`

	// Specifies whether to ignore duplicate occurrences completely.
	IgnoreDuplicateOccurrences *bool `json:"ignoreDuplicateOccurrences,omitempty"`

	// Specifies properties that serve as primary keys.
	PrimaryKeyList []string `json:"primaryKeyList"`

	// Specifies list of properties that the client is supposed to provide when
	// alert of this type is raised.
	PropertyList []string `json:"propertyList"`

	// Specifies whether to send support notification for the alert.
	SendSupportNotification *bool `json:"sendSupportNotification,omitempty"`

	// Specifies whether an SNMP notification is sent when an alert is raised.
	SnmpNotification *bool `json:"snmpNotification,omitempty"`

	// Specifies whether an syslog notification is sent when an alert is raised.
	SyslogNotification *bool `json:"syslogNotification,omitempty"`

	// Specifies version of the metadata.
	Version *int32 `json:"version,omitempty"`
}

// Validate validates this alert metadata
func (m *AlertMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertDocumentList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertTypeBucket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AlertMetadata) validateAlertDocumentList(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertDocumentList) { // not required
		return nil
	}

	for i := 0; i < len(m.AlertDocumentList); i++ {
		if swag.IsZero(m.AlertDocumentList[i]) { // not required
			continue
		}

		if m.AlertDocumentList[i] != nil {
			if err := m.AlertDocumentList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("alertDocumentList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("alertDocumentList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var alertMetadataTypeAlertTypeBucketPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kHardware","kSoftware","kDataService","kMaintenance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertMetadataTypeAlertTypeBucketPropEnum = append(alertMetadataTypeAlertTypeBucketPropEnum, v)
	}
}

const (

	// AlertMetadataAlertTypeBucketKHardware captures enum value "kHardware"
	AlertMetadataAlertTypeBucketKHardware string = "kHardware"

	// AlertMetadataAlertTypeBucketKSoftware captures enum value "kSoftware"
	AlertMetadataAlertTypeBucketKSoftware string = "kSoftware"

	// AlertMetadataAlertTypeBucketKDataService captures enum value "kDataService"
	AlertMetadataAlertTypeBucketKDataService string = "kDataService"

	// AlertMetadataAlertTypeBucketKMaintenance captures enum value "kMaintenance"
	AlertMetadataAlertTypeBucketKMaintenance string = "kMaintenance"
)

// prop value enum
func (m *AlertMetadata) validateAlertTypeBucketEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertMetadataTypeAlertTypeBucketPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AlertMetadata) validateAlertTypeBucket(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertTypeBucket) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertTypeBucketEnum("alertTypeBucket", "body", *m.AlertTypeBucket); err != nil {
		return err
	}

	return nil
}

var alertMetadataTypeCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature","kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kDataPath","kMetadata","kIndexing","kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade","kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage","kFaultTolerance","kBackupRestore","kArchivalRestore","kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kStorageDevice","kStoragePool","kGeneralSoftwareFailure","kAgent"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertMetadataTypeCategoryPropEnum = append(alertMetadataTypeCategoryPropEnum, v)
	}
}

const (

	// AlertMetadataCategoryKDisk captures enum value "kDisk"
	AlertMetadataCategoryKDisk string = "kDisk"

	// AlertMetadataCategoryKNode captures enum value "kNode"
	AlertMetadataCategoryKNode string = "kNode"

	// AlertMetadataCategoryKCluster captures enum value "kCluster"
	AlertMetadataCategoryKCluster string = "kCluster"

	// AlertMetadataCategoryKChassis captures enum value "kChassis"
	AlertMetadataCategoryKChassis string = "kChassis"

	// AlertMetadataCategoryKPowerSupply captures enum value "kPowerSupply"
	AlertMetadataCategoryKPowerSupply string = "kPowerSupply"

	// AlertMetadataCategoryKCPU captures enum value "kCPU"
	AlertMetadataCategoryKCPU string = "kCPU"

	// AlertMetadataCategoryKMemory captures enum value "kMemory"
	AlertMetadataCategoryKMemory string = "kMemory"

	// AlertMetadataCategoryKTemperature captures enum value "kTemperature"
	AlertMetadataCategoryKTemperature string = "kTemperature"

	// AlertMetadataCategoryKFan captures enum value "kFan"
	AlertMetadataCategoryKFan string = "kFan"

	// AlertMetadataCategoryKNIC captures enum value "kNIC"
	AlertMetadataCategoryKNIC string = "kNIC"

	// AlertMetadataCategoryKFirmware captures enum value "kFirmware"
	AlertMetadataCategoryKFirmware string = "kFirmware"

	// AlertMetadataCategoryKNodeHealth captures enum value "kNodeHealth"
	AlertMetadataCategoryKNodeHealth string = "kNodeHealth"

	// AlertMetadataCategoryKOperatingSystem captures enum value "kOperatingSystem"
	AlertMetadataCategoryKOperatingSystem string = "kOperatingSystem"

	// AlertMetadataCategoryKDataPath captures enum value "kDataPath"
	AlertMetadataCategoryKDataPath string = "kDataPath"

	// AlertMetadataCategoryKMetadata captures enum value "kMetadata"
	AlertMetadataCategoryKMetadata string = "kMetadata"

	// AlertMetadataCategoryKIndexing captures enum value "kIndexing"
	AlertMetadataCategoryKIndexing string = "kIndexing"

	// AlertMetadataCategoryKHelios captures enum value "kHelios"
	AlertMetadataCategoryKHelios string = "kHelios"

	// AlertMetadataCategoryKAppMarketPlace captures enum value "kAppMarketPlace"
	AlertMetadataCategoryKAppMarketPlace string = "kAppMarketPlace"

	// AlertMetadataCategoryKSystemService captures enum value "kSystemService"
	AlertMetadataCategoryKSystemService string = "kSystemService"

	// AlertMetadataCategoryKLicense captures enum value "kLicense"
	AlertMetadataCategoryKLicense string = "kLicense"

	// AlertMetadataCategoryKSecurity captures enum value "kSecurity"
	AlertMetadataCategoryKSecurity string = "kSecurity"

	// AlertMetadataCategoryKUpgrade captures enum value "kUpgrade"
	AlertMetadataCategoryKUpgrade string = "kUpgrade"

	// AlertMetadataCategoryKClusterManagement captures enum value "kClusterManagement"
	AlertMetadataCategoryKClusterManagement string = "kClusterManagement"

	// AlertMetadataCategoryKAuditLog captures enum value "kAuditLog"
	AlertMetadataCategoryKAuditLog string = "kAuditLog"

	// AlertMetadataCategoryKNetworking captures enum value "kNetworking"
	AlertMetadataCategoryKNetworking string = "kNetworking"

	// AlertMetadataCategoryKConfiguration captures enum value "kConfiguration"
	AlertMetadataCategoryKConfiguration string = "kConfiguration"

	// AlertMetadataCategoryKStorageUsage captures enum value "kStorageUsage"
	AlertMetadataCategoryKStorageUsage string = "kStorageUsage"

	// AlertMetadataCategoryKFaultTolerance captures enum value "kFaultTolerance"
	AlertMetadataCategoryKFaultTolerance string = "kFaultTolerance"

	// AlertMetadataCategoryKBackupRestore captures enum value "kBackupRestore"
	AlertMetadataCategoryKBackupRestore string = "kBackupRestore"

	// AlertMetadataCategoryKArchivalRestore captures enum value "kArchivalRestore"
	AlertMetadataCategoryKArchivalRestore string = "kArchivalRestore"

	// AlertMetadataCategoryKRemoteReplication captures enum value "kRemoteReplication"
	AlertMetadataCategoryKRemoteReplication string = "kRemoteReplication"

	// AlertMetadataCategoryKQuota captures enum value "kQuota"
	AlertMetadataCategoryKQuota string = "kQuota"

	// AlertMetadataCategoryKCDP captures enum value "kCDP"
	AlertMetadataCategoryKCDP string = "kCDP"

	// AlertMetadataCategoryKViewFailover captures enum value "kViewFailover"
	AlertMetadataCategoryKViewFailover string = "kViewFailover"

	// AlertMetadataCategoryKDisasterRecovery captures enum value "kDisasterRecovery"
	AlertMetadataCategoryKDisasterRecovery string = "kDisasterRecovery"

	// AlertMetadataCategoryKStorageDevice captures enum value "kStorageDevice"
	AlertMetadataCategoryKStorageDevice string = "kStorageDevice"

	// AlertMetadataCategoryKStoragePool captures enum value "kStoragePool"
	AlertMetadataCategoryKStoragePool string = "kStoragePool"

	// AlertMetadataCategoryKGeneralSoftwareFailure captures enum value "kGeneralSoftwareFailure"
	AlertMetadataCategoryKGeneralSoftwareFailure string = "kGeneralSoftwareFailure"

	// AlertMetadataCategoryKAgent captures enum value "kAgent"
	AlertMetadataCategoryKAgent string = "kAgent"
)

// prop value enum
func (m *AlertMetadata) validateCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertMetadataTypeCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AlertMetadata) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	// value enum
	if err := m.validateCategoryEnum("category", "body", *m.Category); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this alert metadata based on the context it is used
func (m *AlertMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAlertDocumentList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AlertMetadata) contextValidateAlertDocumentList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AlertDocumentList); i++ {

		if m.AlertDocumentList[i] != nil {

			if swag.IsZero(m.AlertDocumentList[i]) { // not required
				return nil
			}

			if err := m.AlertDocumentList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("alertDocumentList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("alertDocumentList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AlertMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AlertMetadata) UnmarshalBinary(b []byte) error {
	var res AlertMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
