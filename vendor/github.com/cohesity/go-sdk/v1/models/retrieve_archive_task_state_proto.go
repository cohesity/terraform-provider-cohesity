// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RetrieveArchiveTaskStateProto Persistent state of a retrieve of an archive task. Only one of either
// entity_vec or download_files_info needs to be specified in this proto, where
// entity_vec is for retrieving the whole objects from the archive, and
// download_files_info is for only downloading the specified files from the
// archive.
//
// swagger:model RetrieveArchiveTaskStateProto
type RetrieveArchiveTaskStateProto struct {

	// Target from which to retrieve the archive.
	ArchivalTarget *ArchivalTarget `json:"archivalTarget,omitempty"`

	// The uid of the archive to be retrieved.
	ArchiveTaskUID *UniversalIDProto `json:"archiveTaskUid,omitempty"`

	// The start time of the backup run whose corresponding archive is being
	// retrieved. This field is just used for logging purposes.
	BackupRunStartTimeUsecs *int64 `json:"backupRunStartTimeUsecs,omitempty"`

	// Whether this retrieval task has a pending cancellation request.
	CancellationRequested *bool `json:"cancellationRequested,omitempty"`

	// download files info
	DownloadFilesInfo *RetrieveArchiveTaskStateProtoDownloadFilesInfo `json:"downloadFilesInfo,omitempty"`

	// If the retrieval task has finished, this field contains the end time for
	// the task.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Information on the exact set of objects to retrieve from archive. Even if
	// the user wanted to retrieve all objects from the archive, this field will
	// contain all individual leaf-level objects.
	EntityVec []*EntityProto `json:"entityVec"`

	// The error encountered by task (if any). Only valid if the task has
	// finished.
	Error *ErrorProto `json:"error,omitempty"`

	// The full view name (external). This is composed of a Cohesity specific
	// prefix and the user provided view name.
	FullViewNameDEPRECATED *string `json:"fullViewName_DEPRECATED,omitempty"`

	// Glacier restore option chosen by the user.
	GlacierFlrRestoreOption *int32 `json:"glacierFlrRestoreOption,omitempty"`

	// If we also need to uptier the data to hot tiers, set this bool.
	IsUptierRestoreJob *bool `json:"isUptierRestoreJob,omitempty"`

	// The uid of the job to which the archive to be retrieved belongs to.
	JobUID *UniversalIDProto `json:"jobUid,omitempty"`

	// The name of the retrieval task.
	Name *string `json:"name,omitempty"`

	// The path of the progress monitor for this task.
	ProgressMonitorTaskPath *string `json:"progressMonitorTaskPath,omitempty"`

	// Information of the files to restore from archive to source.
	// Only one of download_files_info or restore_archive_files_info has
	// to be populated to trigger download files or restore files from archive
	// correspondingly.
	RestoreArchiveFilesInfo *RetrieveArchiveTaskStateProtoDownloadFilesInfo `json:"restoreArchiveFilesInfo,omitempty"`

	// For retrieve tasks created after the 2.8 release, this will contain the id
	// of the restore task that created this retrieve task.
	RestoreTaskID *int64 `json:"restoreTaskId,omitempty"`

	// Information about the retrieval task. This proto is created by the master
	// and info in the proto is periodically updated by querying Icebox.
	RetrievalInfo *RetrieveArchiveInfo `json:"retrievalInfo,omitempty"`

	// The start time for this retrieval task.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// The status of this task.
	Status *int32 `json:"status,omitempty"`

	// The globally unique id for this retrieval of an archive task.
	TaskUID *UniversalIDProto `json:"taskUid,omitempty"`

	// The user who requested this retrieval task.
	User *string `json:"user,omitempty"`

	// Params to be passed to Icebox while restoring data from an archive.
	VaultRestoreParams *VaultParamsRestoreParams `json:"vaultRestoreParams,omitempty"`

	// The view box id to which 'view_name' belongs to.
	ViewBoxID *int64 `json:"viewBoxId,omitempty"`

	// The view name as provided by the user for this retrieval task. Retrieved
	// snapshots of the entities will be placed in this view.
	ViewNameDEPRECATED *string `json:"viewName_DEPRECATED,omitempty"`
}

// Validate validates this retrieve archive task state proto
func (m *RetrieveArchiveTaskStateProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArchivalTarget(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchiveTaskUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadFilesInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreArchiveFilesInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetrievalInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaultRestoreParams(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateArchivalTarget(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchivalTarget) { // not required
		return nil
	}

	if m.ArchivalTarget != nil {
		if err := m.ArchivalTarget.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalTarget")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalTarget")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateArchiveTaskUID(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchiveTaskUID) { // not required
		return nil
	}

	if m.ArchiveTaskUID != nil {
		if err := m.ArchiveTaskUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveTaskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archiveTaskUid")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateDownloadFilesInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.DownloadFilesInfo) { // not required
		return nil
	}

	if m.DownloadFilesInfo != nil {
		if err := m.DownloadFilesInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("downloadFilesInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("downloadFilesInfo")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateEntityVec(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityVec) { // not required
		return nil
	}

	for i := 0; i < len(m.EntityVec); i++ {
		if swag.IsZero(m.EntityVec[i]) { // not required
			continue
		}

		if m.EntityVec[i] != nil {
			if err := m.EntityVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("entityVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("entityVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.JobUID) { // not required
		return nil
	}

	if m.JobUID != nil {
		if err := m.JobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateRestoreArchiveFilesInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreArchiveFilesInfo) { // not required
		return nil
	}

	if m.RestoreArchiveFilesInfo != nil {
		if err := m.RestoreArchiveFilesInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restoreArchiveFilesInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("restoreArchiveFilesInfo")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateRetrievalInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.RetrievalInfo) { // not required
		return nil
	}

	if m.RetrievalInfo != nil {
		if err := m.RetrievalInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retrievalInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retrievalInfo")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateTaskUID(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskUID) { // not required
		return nil
	}

	if m.TaskUID != nil {
		if err := m.TaskUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taskUid")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) validateVaultRestoreParams(formats strfmt.Registry) error {
	if swag.IsZero(m.VaultRestoreParams) { // not required
		return nil
	}

	if m.VaultRestoreParams != nil {
		if err := m.VaultRestoreParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vaultRestoreParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vaultRestoreParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this retrieve archive task state proto based on the context it is used
func (m *RetrieveArchiveTaskStateProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateArchivalTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchiveTaskUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDownloadFilesInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntityVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreArchiveFilesInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetrievalInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaskUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVaultRestoreParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateArchivalTarget(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchivalTarget != nil {

		if swag.IsZero(m.ArchivalTarget) { // not required
			return nil
		}

		if err := m.ArchivalTarget.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalTarget")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalTarget")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateArchiveTaskUID(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchiveTaskUID != nil {

		if swag.IsZero(m.ArchiveTaskUID) { // not required
			return nil
		}

		if err := m.ArchiveTaskUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveTaskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archiveTaskUid")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateDownloadFilesInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.DownloadFilesInfo != nil {

		if swag.IsZero(m.DownloadFilesInfo) { // not required
			return nil
		}

		if err := m.DownloadFilesInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("downloadFilesInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("downloadFilesInfo")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateEntityVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.EntityVec); i++ {

		if m.EntityVec[i] != nil {

			if swag.IsZero(m.EntityVec[i]) { // not required
				return nil
			}

			if err := m.EntityVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("entityVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("entityVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {

		if swag.IsZero(m.Error) { // not required
			return nil
		}

		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.JobUID != nil {

		if swag.IsZero(m.JobUID) { // not required
			return nil
		}

		if err := m.JobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateRestoreArchiveFilesInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.RestoreArchiveFilesInfo != nil {

		if swag.IsZero(m.RestoreArchiveFilesInfo) { // not required
			return nil
		}

		if err := m.RestoreArchiveFilesInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restoreArchiveFilesInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("restoreArchiveFilesInfo")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateRetrievalInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.RetrievalInfo != nil {

		if swag.IsZero(m.RetrievalInfo) { // not required
			return nil
		}

		if err := m.RetrievalInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retrievalInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retrievalInfo")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateTaskUID(ctx context.Context, formats strfmt.Registry) error {

	if m.TaskUID != nil {

		if swag.IsZero(m.TaskUID) { // not required
			return nil
		}

		if err := m.TaskUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taskUid")
			}
			return err
		}
	}

	return nil
}

func (m *RetrieveArchiveTaskStateProto) contextValidateVaultRestoreParams(ctx context.Context, formats strfmt.Registry) error {

	if m.VaultRestoreParams != nil {

		if swag.IsZero(m.VaultRestoreParams) { // not required
			return nil
		}

		if err := m.VaultRestoreParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vaultRestoreParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vaultRestoreParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RetrieveArchiveTaskStateProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RetrieveArchiveTaskStateProto) UnmarshalBinary(b []byte) error {
	var res RetrieveArchiveTaskStateProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
