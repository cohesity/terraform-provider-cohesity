// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// KubernetesProtectionSource Kubernetes Protection Source.
//
// Specifies a Protection Source in Kubernetes environment.
//
// swagger:model KubernetesProtectionSource
type KubernetesProtectionSource struct {

	// Specifies the location of Datamover image in private registry.
	DatamoverImageLocation *string `json:"datamoverImageLocation,omitempty"`

	// Specifies Type of service to be deployed for communication with DataMover
	// pods. Currently, LoadBalancer and NodePort are supported.
	// [default = kNodePort].
	DatamoverServiceType *int32 `json:"datamoverServiceType,omitempty"`

	// Specifies if the deployed Datamover image needs to be upgraded
	// for this kubernetes entity
	DatamoverUpgradability *int32 `json:"datamoverUpgradability,omitempty"`

	// Specifies the default VLAN parameters to be used for performing the
	// backup/restore of this entity.
	DefaultVlanParams *VlanParameters `json:"defaultVlanParams,omitempty"`

	// Specifies an optional description of the object.
	Description *string `json:"description,omitempty"`

	// Specifies the type of the entity in a Kubernetes environment.
	// Determines the K8s distribution.
	// Enum: ["kMainline","kOpenshift","kRancher","kEKS","kGKE","kAKS","kVMwareTanzu"]
	Distribution *string `json:"distribution,omitempty"`

	// Specifies the location of the image for init containers.
	InitContainerImageLocation *string `json:"initContainerImageLocation,omitempty"`

	// Specifies the list of label attributes of this source.
	LabelAttributes []*KubernetesLabelAttribute `json:"labelAttributes"`

	// Specifies a unique name of the Protection Source.
	Name *string `json:"name,omitempty"`

	// Specifies annotations to be put on services for IP allocation. Applicable
	// only when service is of type LoadBalancer.
	ServiceAnnotations []*VlanInfoServiceAnnotationsEntry `json:"serviceAnnotations"`

	// Specifies storage class information of source.
	StorageClass []*KubernetesStorageClassInfo `json:"storageClass"`

	// Specifies the type of the entity in a Kubernetes environment.
	// Specifies the type of a Kubernetes Protection Source.
	// 'kCluster' indicates a Kubernetes Cluster.
	// 'kNamespace' indicates a namespace in a Kubernetes Cluster.
	// 'kService' indicates a service running on a Kubernetes Cluster.
	// Enum: ["kCluster","kNamespace","kService"]
	Type *string `json:"type,omitempty"`

	// Specifies the UUID of the object.
	UUID *string `json:"uuid,omitempty"`

	// Specifies the location of Velero AWS plugin image in private registry.
	VeleroAwsPluginImageLocation *string `json:"veleroAwsPluginImageLocation,omitempty"`

	// Specifies the location of Velero image in private registry.
	VeleroImageLocation *string `json:"veleroImageLocation,omitempty"`

	// Specifies the location of the image for openshift plugin container.
	VeleroOpenshiftPluginImageLocation *string `json:"veleroOpenshiftPluginImageLocation,omitempty"`

	// Specifies if the deployed Velero image needs to be upgraded
	// for this kubernetes entity.
	VeleroUpgradability *int32 `json:"veleroUpgradability,omitempty"`

	// Specifies VLAN information provided during registration.
	VlanInfoVec []*KubernetesVlanInfo `json:"vlanInfoVec"`
}

// Validate validates this kubernetes protection source
func (m *KubernetesProtectionSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDefaultVlanParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDistribution(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabelAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceAnnotations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlanInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *KubernetesProtectionSource) validateDefaultVlanParams(formats strfmt.Registry) error {
	if swag.IsZero(m.DefaultVlanParams) { // not required
		return nil
	}

	if m.DefaultVlanParams != nil {
		if err := m.DefaultVlanParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultVlanParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultVlanParams")
			}
			return err
		}
	}

	return nil
}

var kubernetesProtectionSourceTypeDistributionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kMainline","kOpenshift","kRancher","kEKS","kGKE","kAKS","kVMwareTanzu"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		kubernetesProtectionSourceTypeDistributionPropEnum = append(kubernetesProtectionSourceTypeDistributionPropEnum, v)
	}
}

const (

	// KubernetesProtectionSourceDistributionKMainline captures enum value "kMainline"
	KubernetesProtectionSourceDistributionKMainline string = "kMainline"

	// KubernetesProtectionSourceDistributionKOpenshift captures enum value "kOpenshift"
	KubernetesProtectionSourceDistributionKOpenshift string = "kOpenshift"

	// KubernetesProtectionSourceDistributionKRancher captures enum value "kRancher"
	KubernetesProtectionSourceDistributionKRancher string = "kRancher"

	// KubernetesProtectionSourceDistributionKEKS captures enum value "kEKS"
	KubernetesProtectionSourceDistributionKEKS string = "kEKS"

	// KubernetesProtectionSourceDistributionKGKE captures enum value "kGKE"
	KubernetesProtectionSourceDistributionKGKE string = "kGKE"

	// KubernetesProtectionSourceDistributionKAKS captures enum value "kAKS"
	KubernetesProtectionSourceDistributionKAKS string = "kAKS"

	// KubernetesProtectionSourceDistributionKVMwareTanzu captures enum value "kVMwareTanzu"
	KubernetesProtectionSourceDistributionKVMwareTanzu string = "kVMwareTanzu"
)

// prop value enum
func (m *KubernetesProtectionSource) validateDistributionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, kubernetesProtectionSourceTypeDistributionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *KubernetesProtectionSource) validateDistribution(formats strfmt.Registry) error {
	if swag.IsZero(m.Distribution) { // not required
		return nil
	}

	// value enum
	if err := m.validateDistributionEnum("distribution", "body", *m.Distribution); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesProtectionSource) validateLabelAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.LabelAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.LabelAttributes); i++ {
		if swag.IsZero(m.LabelAttributes[i]) { // not required
			continue
		}

		if m.LabelAttributes[i] != nil {
			if err := m.LabelAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labelAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labelAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesProtectionSource) validateServiceAnnotations(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceAnnotations) { // not required
		return nil
	}

	for i := 0; i < len(m.ServiceAnnotations); i++ {
		if swag.IsZero(m.ServiceAnnotations[i]) { // not required
			continue
		}

		if m.ServiceAnnotations[i] != nil {
			if err := m.ServiceAnnotations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesProtectionSource) validateStorageClass(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageClass) { // not required
		return nil
	}

	for i := 0; i < len(m.StorageClass); i++ {
		if swag.IsZero(m.StorageClass[i]) { // not required
			continue
		}

		if m.StorageClass[i] != nil {
			if err := m.StorageClass[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("storageClass" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("storageClass" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var kubernetesProtectionSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCluster","kNamespace","kService"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		kubernetesProtectionSourceTypeTypePropEnum = append(kubernetesProtectionSourceTypeTypePropEnum, v)
	}
}

const (

	// KubernetesProtectionSourceTypeKCluster captures enum value "kCluster"
	KubernetesProtectionSourceTypeKCluster string = "kCluster"

	// KubernetesProtectionSourceTypeKNamespace captures enum value "kNamespace"
	KubernetesProtectionSourceTypeKNamespace string = "kNamespace"

	// KubernetesProtectionSourceTypeKService captures enum value "kService"
	KubernetesProtectionSourceTypeKService string = "kService"
)

// prop value enum
func (m *KubernetesProtectionSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, kubernetesProtectionSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *KubernetesProtectionSource) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *KubernetesProtectionSource) validateVlanInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.VlanInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.VlanInfoVec); i++ {
		if swag.IsZero(m.VlanInfoVec[i]) { // not required
			continue
		}

		if m.VlanInfoVec[i] != nil {
			if err := m.VlanInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this kubernetes protection source based on the context it is used
func (m *KubernetesProtectionSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDefaultVlanParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLabelAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceAnnotations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageClass(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVlanInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *KubernetesProtectionSource) contextValidateDefaultVlanParams(ctx context.Context, formats strfmt.Registry) error {

	if m.DefaultVlanParams != nil {

		if swag.IsZero(m.DefaultVlanParams) { // not required
			return nil
		}

		if err := m.DefaultVlanParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("defaultVlanParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("defaultVlanParams")
			}
			return err
		}
	}

	return nil
}

func (m *KubernetesProtectionSource) contextValidateLabelAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LabelAttributes); i++ {

		if m.LabelAttributes[i] != nil {

			if swag.IsZero(m.LabelAttributes[i]) { // not required
				return nil
			}

			if err := m.LabelAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("labelAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("labelAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesProtectionSource) contextValidateServiceAnnotations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServiceAnnotations); i++ {

		if m.ServiceAnnotations[i] != nil {

			if swag.IsZero(m.ServiceAnnotations[i]) { // not required
				return nil
			}

			if err := m.ServiceAnnotations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAnnotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesProtectionSource) contextValidateStorageClass(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StorageClass); i++ {

		if m.StorageClass[i] != nil {

			if swag.IsZero(m.StorageClass[i]) { // not required
				return nil
			}

			if err := m.StorageClass[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("storageClass" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("storageClass" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *KubernetesProtectionSource) contextValidateVlanInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VlanInfoVec); i++ {

		if m.VlanInfoVec[i] != nil {

			if swag.IsZero(m.VlanInfoVec[i]) { // not required
				return nil
			}

			if err := m.VlanInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vlanInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *KubernetesProtectionSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *KubernetesProtectionSource) UnmarshalBinary(b []byte) error {
	var res KubernetesProtectionSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
