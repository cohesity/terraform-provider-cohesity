// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PrivateCredentials Message that encapsulates credentials to authenticate to an environment.
//
// NOTE:- Please update CredentialsProto in api/magneto_external_base.proto
// whenever there is any change in this message.
//
// swagger:model PrivateCredentials
type PrivateCredentials struct {

	// Credentials for certificate based authentication.
	CertCredentials *CertificateBasedAuthenticationCredentials `json:"certCredentials,omitempty"`

	// Credentials needed to authenticate with cloud (Azure or AWS).
	CloudCredentials *NexusCloudCredentials `json:"cloudCredentials,omitempty"`

	// AES256 encrypted password. The key for encryption should be obtained from
	// KMS. This field stores the encrypted password when the credentials are
	// being sent to bifrost.
	EncryptedPassword []uint8 `json:"encryptedPassword"`

	// AES256 encrypted token
	EncryptedToken []uint8 `json:"encryptedToken"`

	// The credentials to get authorization key/token to use MS Graph API.
	MsGraphCredentialsVec []*MSGraphAppCredentials `json:"msGraphCredentialsVec"`

	// The credentials to use to mount a specific type of NAS mount points.
	NasMountCredentials *NasMountCredentials `json:"nasMountCredentials,omitempty"`

	// This field is not used in storage, other than historical records. The
	// field is only set for inflight rpcs.
	//
	// TODO(gaurav): Change this field type to bytes.
	Password *string `json:"password,omitempty"`

	// The credentials of optional service accounts to be used for mailbox
	// backups.
	ServiceAccountCredentialsVec []*ServiceAccountCredentials `json:"serviceAccountCredentialsVec"`

	// Optional SSL verification settings. If specified, connections to server
	// will be validated appropriately.
	SslVerification *SSLVerification `json:"sslVerification,omitempty"`

	// The token to use for authentication. For example, in a SAN environment,
	// this can be the API token that is used to create a REST session.
	//
	// TODO(gaurav): Should this field also be encrypted?
	Token *string `json:"token,omitempty"`

	// The username and password to use for authentication.
	Username *string `json:"username,omitempty"`

	// Whether the credentials are validated or not.
	Validated *bool `json:"validated,omitempty"`
}

// Validate validates this private credentials
func (m *PrivateCredentials) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCertCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMsGraphCredentialsVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNasMountCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceAccountCredentialsVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSslVerification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateCredentials) validateCertCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.CertCredentials) { // not required
		return nil
	}

	if m.CertCredentials != nil {
		if err := m.CertCredentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("certCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateCredentials) validateCloudCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudCredentials) { // not required
		return nil
	}

	if m.CloudCredentials != nil {
		if err := m.CloudCredentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateCredentials) validateMsGraphCredentialsVec(formats strfmt.Registry) error {
	if swag.IsZero(m.MsGraphCredentialsVec) { // not required
		return nil
	}

	for i := 0; i < len(m.MsGraphCredentialsVec); i++ {
		if swag.IsZero(m.MsGraphCredentialsVec[i]) { // not required
			continue
		}

		if m.MsGraphCredentialsVec[i] != nil {
			if err := m.MsGraphCredentialsVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("msGraphCredentialsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("msGraphCredentialsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateCredentials) validateNasMountCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.NasMountCredentials) { // not required
		return nil
	}

	if m.NasMountCredentials != nil {
		if err := m.NasMountCredentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nasMountCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nasMountCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateCredentials) validateServiceAccountCredentialsVec(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceAccountCredentialsVec) { // not required
		return nil
	}

	for i := 0; i < len(m.ServiceAccountCredentialsVec); i++ {
		if swag.IsZero(m.ServiceAccountCredentialsVec[i]) { // not required
			continue
		}

		if m.ServiceAccountCredentialsVec[i] != nil {
			if err := m.ServiceAccountCredentialsVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAccountCredentialsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAccountCredentialsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateCredentials) validateSslVerification(formats strfmt.Registry) error {
	if swag.IsZero(m.SslVerification) { // not required
		return nil
	}

	if m.SslVerification != nil {
		if err := m.SslVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sslVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sslVerification")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this private credentials based on the context it is used
func (m *PrivateCredentials) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCertCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMsGraphCredentialsVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNasMountCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceAccountCredentialsVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSslVerification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateCredentials) contextValidateCertCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.CertCredentials != nil {

		if swag.IsZero(m.CertCredentials) { // not required
			return nil
		}

		if err := m.CertCredentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("certCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("certCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateCredentials) contextValidateCloudCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudCredentials != nil {

		if swag.IsZero(m.CloudCredentials) { // not required
			return nil
		}

		if err := m.CloudCredentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateCredentials) contextValidateMsGraphCredentialsVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MsGraphCredentialsVec); i++ {

		if m.MsGraphCredentialsVec[i] != nil {

			if swag.IsZero(m.MsGraphCredentialsVec[i]) { // not required
				return nil
			}

			if err := m.MsGraphCredentialsVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("msGraphCredentialsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("msGraphCredentialsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateCredentials) contextValidateNasMountCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.NasMountCredentials != nil {

		if swag.IsZero(m.NasMountCredentials) { // not required
			return nil
		}

		if err := m.NasMountCredentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nasMountCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nasMountCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateCredentials) contextValidateServiceAccountCredentialsVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServiceAccountCredentialsVec); i++ {

		if m.ServiceAccountCredentialsVec[i] != nil {

			if swag.IsZero(m.ServiceAccountCredentialsVec[i]) { // not required
				return nil
			}

			if err := m.ServiceAccountCredentialsVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceAccountCredentialsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("serviceAccountCredentialsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateCredentials) contextValidateSslVerification(ctx context.Context, formats strfmt.Registry) error {

	if m.SslVerification != nil {

		if swag.IsZero(m.SslVerification) { // not required
			return nil
		}

		if err := m.SslVerification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sslVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sslVerification")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateCredentials) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateCredentials) UnmarshalBinary(b []byte) error {
	var res PrivateCredentials
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
