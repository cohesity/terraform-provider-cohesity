// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RegisteredEntityUdaParams Contains all params specified by the user while registering a UDA
// entity.
//
// swagger:model RegisteredEntityUdaParams
type RegisteredEntityUdaParams struct {

	// Types of backups supported.
	Capabilities *UdaSourceCapabilities `json:"capabilities,omitempty"`

	// Credentials that will be used to log into the application environment.
	Credentials *PrivateCredentials `json:"credentials,omitempty"`

	// Deployment type for the UDA agent.
	DeploymentType *int32 `json:"deploymentType,omitempty"`

	// Specifies whether to enable cohesity policy triggered log backups along
	// with externally triggered backups.
	// Only applicable if externally_triggered_log_backup is true.
	EtEnableLogBackupPolicy *bool `json:"etEnableLogBackupPolicy,omitempty"`

	// Specifies if the user triggered (UI) runs are allowed along with
	// externally triggered runs.
	// Only applicable if externally_triggered_log_backup is true.
	EtEnableRunNow *bool `json:"etEnableRunNow,omitempty"`

	// Indicate if a new view is required for full backups.
	FreshFullBackupView *bool `json:"freshFullBackupView,omitempty"`

	// The agent host environment type.
	HostType *int32 `json:"hostType,omitempty"`

	// List of hosts forming the UDA cluster.
	Hosts []string `json:"hosts"`

	// Should use live view for data backup.
	LiveDataView *bool `json:"liveDataView,omitempty"`

	// Should use live view for log backup.
	LiveLogView *bool `json:"liveLogView,omitempty"`

	// Mount directory path to be used for writing the backup to.
	MountDir *string `json:"mountDir,omitempty"`

	// Whether to mount a view during the source backup.
	MountView *bool `json:"mountView,omitempty"`

	// Object levels.
	ObjectTypes []string `json:"objectTypes"`

	// These object types would be excluded from entity hierarchy expansion while
	// expanding entities as part of a backup job run. For instance, when an
	// object of excluded object type is encountered during EH expansion for
	// backup, it would be treated as a leaf entity.
	// Behaviour of other EH expansion operations would remain as is such as EH
	// expansion when a source is refreshed.
	ObjectTypesExcludedFromExpansion []string `json:"objectTypesExcludedFromExpansion"`

	// Specifies whether the source supports parallel log backups.
	// Must be used with a live log view.
	ParallelLogBackups *bool `json:"parallelLogBackups,omitempty"`

	// pre backup job script failure tolerance
	PreBackupJobScriptFailureTolerance *int32 `json:"preBackupJobScriptFailureTolerance,omitempty"`

	// Control nodes to connect for control path ops.
	PreferredControlNodes []string `json:"preferredControlNodes"`

	// Specifies whether the source disallows parallel data & log backups.
	RestrictParallelDataLogBackups *bool `json:"restrictParallelDataLogBackups,omitempty"`

	// Path where various source scripts will be located.
	ScriptDir *string `json:"scriptDir,omitempty"`

	// Custom arguments which will be provided to the source registration
	// scripts. This is deprecated. Use source_args_map instead.
	SourceArgs *string `json:"sourceArgs,omitempty"`

	// Map to store custom arguments which will be provided to the source
	// registration scripts.
	SourceArgumentsMap map[string]UdaCustomArgument `json:"sourceArgumentsMap,omitempty"`

	// Universal Data Adapter (UDA) source type.
	SourceType *string `json:"sourceType,omitempty"`

	// Should the live log view be created at the time of first full backup ?
	// This will be passed to all data backups
	// This is not the same as auto_log_backup,
	// since this applies to scheduled log backups and has its limitations
	StaticLiveLogView *bool `json:"staticLiveLogView,omitempty"`

	// Whether S3 views should be used for backup/retore.
	UseS3View *bool `json:"useS3View,omitempty"`
}

// Validate validates this registered entity uda params
func (m *RegisteredEntityUdaParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCapabilities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceArgumentsMap(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RegisteredEntityUdaParams) validateCapabilities(formats strfmt.Registry) error {
	if swag.IsZero(m.Capabilities) { // not required
		return nil
	}

	if m.Capabilities != nil {
		if err := m.Capabilities.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capabilities")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capabilities")
			}
			return err
		}
	}

	return nil
}

func (m *RegisteredEntityUdaParams) validateCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.Credentials) { // not required
		return nil
	}

	if m.Credentials != nil {
		if err := m.Credentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *RegisteredEntityUdaParams) validateSourceArgumentsMap(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceArgumentsMap) { // not required
		return nil
	}

	for k := range m.SourceArgumentsMap {

		if err := validate.Required("sourceArgumentsMap"+"."+k, "body", m.SourceArgumentsMap[k]); err != nil {
			return err
		}
		if val, ok := m.SourceArgumentsMap[k]; ok {
			if err := val.Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sourceArgumentsMap" + "." + k)
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sourceArgumentsMap" + "." + k)
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this registered entity uda params based on the context it is used
func (m *RegisteredEntityUdaParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapabilities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceArgumentsMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RegisteredEntityUdaParams) contextValidateCapabilities(ctx context.Context, formats strfmt.Registry) error {

	if m.Capabilities != nil {

		if swag.IsZero(m.Capabilities) { // not required
			return nil
		}

		if err := m.Capabilities.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capabilities")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capabilities")
			}
			return err
		}
	}

	return nil
}

func (m *RegisteredEntityUdaParams) contextValidateCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.Credentials != nil {

		if swag.IsZero(m.Credentials) { // not required
			return nil
		}

		if err := m.Credentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("credentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("credentials")
			}
			return err
		}
	}

	return nil
}

func (m *RegisteredEntityUdaParams) contextValidateSourceArgumentsMap(ctx context.Context, formats strfmt.Registry) error {

	for k := range m.SourceArgumentsMap {

		if val, ok := m.SourceArgumentsMap[k]; ok {
			if err := val.ContextValidate(ctx, formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RegisteredEntityUdaParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RegisteredEntityUdaParams) UnmarshalBinary(b []byte) error {
	var res RegisteredEntityUdaParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
