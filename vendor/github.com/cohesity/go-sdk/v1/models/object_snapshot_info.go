// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ObjectSnapshotInfo Object Snapshot.
//
// Specifies information about an object that has been backed up.
//
// swagger:model ObjectSnapshotInfo
type ObjectSnapshotInfo struct {

	// Specifies the Cohesity Cluster partition id where this object is stored.
	ClusterPartitionID *int64 `json:"clusterPartitionId,omitempty"`

	// Specifies the id for the Protection Job that is currently
	// associated with the object. If the object was backed up on
	// current Cohesity Cluster, this field contains the id for the Job
	// that captured this backup object.
	// If the object was backed up on a Primary Cluster and
	// replicated to this Cohesity Cluster, a new Inactive Job is created,
	// the object is now associated with new Inactive Job, and this field
	// contains the id of the new Inactive Job.
	JobID *int64 `json:"jobId,omitempty"`

	// Specifies the name of the Protection Job that captured the backup.
	JobName *string `json:"jobName,omitempty"`

	// Specifies the globally unique id of the Protection Job that backed up
	// this object. This id is unique across Cohesity Clusters.
	// Even if this object is replicated to a Remote Cohesity Cluster
	// and the object is associated with a new Job, the value specified
	// in this field does not change.
	JobUID struct {
		UniversalID
	} `json:"jobUid,omitempty"`

	// Specifies the primary name of the object.
	ObjectName *string `json:"objectName,omitempty"`

	// Specifies the inferred OS type.
	OsType *string `json:"osType,omitempty"`

	// Specifies the id of the original root Protection Source tree
	// (such as a vCenter Server) that was accessed by the Protection Job
	// to capture a backup of this object.
	RegisteredSource *ProtectionSource `json:"registeredSource,omitempty"`

	// Specifies the Protection Source that represents the original object being
	// backed up. When a root Protection Source is registered, it creates
	// a tree of source Protection Source objects. This field defines the
	// specific Protection Source leaf object (such as a VM)
	// that was backed up.
	SnapshottedSource *ProtectionSource `json:"snapshottedSource,omitempty"`

	// Array of Snapshots.
	//
	// Specifies all snapshot versions of this object. Each time a Job Run
	// of a Job executes, it may create a new snapshot version of an object.
	// This array stores the different snapshots versions of the object.
	Versions []*SnapshotVersion `json:"versions"`

	// Specifies the id of the Domain (View Box) where this
	// object is stored.
	ViewBoxID *int64 `json:"viewBoxId,omitempty"`

	// Specifies the View name where this object is stored.
	ViewName *string `json:"viewName,omitempty"`
}

// Validate validates this object snapshot info
func (m *ObjectSnapshotInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegisteredSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshottedSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectSnapshotInfo) validateJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.JobUID) { // not required
		return nil
	}

	return nil
}

func (m *ObjectSnapshotInfo) validateRegisteredSource(formats strfmt.Registry) error {
	if swag.IsZero(m.RegisteredSource) { // not required
		return nil
	}

	if m.RegisteredSource != nil {
		if err := m.RegisteredSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registeredSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registeredSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotInfo) validateSnapshottedSource(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshottedSource) { // not required
		return nil
	}

	if m.SnapshottedSource != nil {
		if err := m.SnapshottedSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshottedSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshottedSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotInfo) validateVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.Versions) { // not required
		return nil
	}

	for i := 0; i < len(m.Versions); i++ {
		if swag.IsZero(m.Versions[i]) { // not required
			continue
		}

		if m.Versions[i] != nil {
			if err := m.Versions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this object snapshot info based on the context it is used
func (m *ObjectSnapshotInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegisteredSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshottedSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectSnapshotInfo) contextValidateJobUID(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *ObjectSnapshotInfo) contextValidateRegisteredSource(ctx context.Context, formats strfmt.Registry) error {

	if m.RegisteredSource != nil {

		if swag.IsZero(m.RegisteredSource) { // not required
			return nil
		}

		if err := m.RegisteredSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("registeredSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("registeredSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotInfo) contextValidateSnapshottedSource(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshottedSource != nil {

		if swag.IsZero(m.SnapshottedSource) { // not required
			return nil
		}

		if err := m.SnapshottedSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshottedSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshottedSource")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotInfo) contextValidateVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Versions); i++ {

		if m.Versions[i] != nil {

			if swag.IsZero(m.Versions[i]) { // not required
				return nil
			}

			if err := m.Versions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("versions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("versions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ObjectSnapshotInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ObjectSnapshotInfo) UnmarshalBinary(b []byte) error {
	var res ObjectSnapshotInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
