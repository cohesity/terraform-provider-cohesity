// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GcpProtectionSource GCP Protection Source.
//
// Specifies a Protection Source in GCP environment.
//
// swagger:model GcpProtectionSource
type GcpProtectionSource struct {

	// Specifies Client email address associated with the service account.
	ClientEmailAddress *string `json:"clientEmailAddress,omitempty"`

	// Specifies Client private associated with the service account.
	ClientPrivateKey *string `json:"clientPrivateKey,omitempty"`

	// Specifies information related to cluster. This is only valid for CE & NGCE
	// clusters. This is only populated for kIAMUser entity.
	ClusterNetworkInfo *FleetNetworkParams `json:"clusterNetworkInfo,omitempty"`

	// Specified list of disks attached to the GCP instances.
	GcpDiskInfoList []*GcpDiskInfo `json:"gcpDiskInfoList"`

	// Specifies the GCP Fleet Parameters for entity type kIAMUser in the new
	// source registration workflow.
	GcpFleetParams *GcpFleetParams `json:"gcpFleetParams,omitempty"`

	// Specifies the entity type such as 'kIAMUser' if the environment is kGCP.
	// Specifies the type of a GCP source entity.
	// 'kIAMUser' indicates a unique user within a GCP account.
	// 'kProject' represents compute resources and storage.
	// 'kRegion' indicates a geographical region in the global infrastructure.
	// 'kAvailabilityZone' indicates an availability zone within a region.
	// 'kVirtualMachine' indicates a Virtual Machine running in GCP environment.
	// 'kVPC' indicates a virtual private cloud (VPC) network within GCP.
	// 'kSubnet' indicates a subnet inside the VPC.
	// 'kNetworkSecurityGroup' represents a network security group.
	// 'kInstanceType' represents various machine types.
	// 'kLabel' represents a label present on the instances.
	// 'kMetaData' represents a custom metadata present on instances.
	// 'kTag' represents a network tag on instances.
	// 'kVPCConnector' represents a VPC connector used for serverless VPC access.
	// Enum: ["kIAMUser","kProject","kRegion","kAvailabilityZone","kVirtualMachine","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kLabel","kMetadata","kTag","kVPCConnector"]
	GcpType *string `json:"gcpType,omitempty"`

	// Specifies the host project id.
	// It is populated in entities of type kSubnet if the subnet is part of a
	// shared VPC. This contains the ID of host project the subnet belongs to.
	// Populated in entities of type kProject if the project is a service project
	// in a Shared VPC setup. This contains the ID of the host project it is
	// attached to.
	HostProjectID *string `json:"hostProjectId,omitempty"`

	// Specifies the OS type of the Protection Source of type 'kVirtualMachine'
	// such as 'kWindows' or 'kLinux'.
	// overrideDescription: true
	// 'kLinux' indicates the Linux operating system.
	// 'kWindows' indicates the Microsoft Windows operating system.
	// 'kAix' indicates the IBM AIX operating system.
	// 'kSolaris' indicates the Oracle Solaris operating system.
	// 'kSapHana' indicates the Sap Hana database system developed by SAP SE.
	// 'kSapOracle' indicates the Sap Oracle database system developed by SAP SE.
	// 'kCockroachDB' indicates the CockroachDB database system.
	// 'kMySQL' indicates the MySQL database system.
	// 'kSapSybase' indicates the SapSybase database system.
	// 'kSapMaxDB' indicates the SapMaxDB database system.
	// 'kSapSybaseIQ' indicates the SapSybaseIQ database system.
	// 'kDB2' indicates the DB2 database system.
	// 'kSapASE' indicates the SapASE database system.
	// 'kMariaDB' indicates the MariaDB database system.
	// 'kPostgreSQL' indicates the PostgreSQL database system.
	// 'kHPUX' indicates the HPUX database system.
	// 'kVOS' indicates the VOS database system.
	// 'kOther' indicates the other types of operating system.
	// Enum: ["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]
	HostType *string `json:"hostType,omitempty"`

	// Specifies the IP address of the entity of type 'kVirtualMachine'.
	IPAddressesVM *string `json:"ipAddressesVM,omitempty"`

	// Specifies the name of the Object set by the Cloud Provider.
	// If the provider did not set a name for the object, this field is not set.
	Name *string `json:"name,omitempty"`

	// Specifies the owner id of the resource in GCP environment. With type,
	// name and ownerId gives a globally unique identity to the GCP entity.
	OwnerID *string `json:"ownerId,omitempty"`

	// Specifies the Protection Source id of the registered Physical Host.
	// If the cloud entity is protected using a Physical Agent, it must be
	// registered as a physical host.
	PhysicalSourceID *int64 `json:"physicalSourceId,omitempty"`

	// Specifies the project Id.
	// For the kIAMUser entity this contains the id of the project to be used
	// to deploy proxy VMs. For entities of type kVirtualMachine this contains
	// the id of the project the virtual machine belongs to.
	ProjectID *string `json:"projectId,omitempty"`

	// Specifies the region Id.
	// For the kIAMUser entity this contains the region to be used to deploy
	// proxy VMs. For entities of type kVirtualMachine this contains the region
	// the virtual machine belongs to.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies the unique Id of the resource given by the cloud provider.
	ResourceID *string `json:"resourceId,omitempty"`

	// Specifies the id of the "convert and deploy" restore task that
	// created the entity in the cloud.
	//
	// It is required to support the DR-to-cloud usecase where we replicate an
	// on-prem entity to a cluster running in cloud, bring it up using
	// "convert and deploy" mechanism, protect it using a cloud job that uses
	// physical adapter, and convert it back to the on-prem format before
	// replication.
	//
	// Before replicating, we need to update the backup task state of the backed
	// up entity using the on-prem entity and on-prem entity's parent.
	// The id is used to lookup the restore entity that contains details about
	// the on-prem entity.
	//
	// It is set at the time of refreshing the cloud entity hierarchy if all the
	// following conditions are met:
	// Name of the current entity matches with name of any cloud entity
	// deployed using the "convert and deploy" restore task.
	// Restore entity associated with the above matched cloud entity has
	// 'failed_over' flag set to true in its cloud extension.
	RestoreTaskID *int64 `json:"restoreTaskId,omitempty"`

	// Specifies the list of GCP tag attributes.
	TagAttributes []*TagAttribute `json:"tagAttributes"`

	// Specifies the type of an GCP Protection Source Object such as
	// 'kIAMUser', 'kProject', 'kRegion', etc.
	// Specifies the type of a GCP source entity.
	// 'kIAMUser' indicates a unique user within a GCP account.
	// 'kProject' represents compute resources and storage.
	// 'kRegion' indicates a geographical region in the global infrastructure.
	// 'kAvailabilityZone' indicates an availability zone within a region.
	// 'kVirtualMachine' indicates a Virtual Machine running in GCP environment.
	// 'kVPC' indicates a virtual private cloud (VPC) network within GCP.
	// 'kSubnet' indicates a subnet inside the VPC.
	// 'kNetworkSecurityGroup' represents a network security group.
	// 'kInstanceType' represents various machine types.
	// 'kLabel' represents a label present on the instances.
	// 'kMetaData' represents a custom metadata present on instances.
	// 'kTag' represents a network tag on instances.
	// 'kVPCConnector' represents a VPC connector used for serverless VPC access.
	// Enum: ["kIAMUser","kProject","kRegion","kAvailabilityZone","kVirtualMachine","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kLabel","kMetadata","kTag","kVPCConnector"]
	Type *string `json:"type,omitempty"`

	// Specifies the VPC Network to deploy proxy VMs.
	VpcNetwork *string `json:"vpcNetwork,omitempty"`

	// Specifies the subnetwork to deploy proxy VMs.
	VpcSubnetwork *string `json:"vpcSubnetwork,omitempty"`
}

// Validate validates this gcp protection source
func (m *GcpProtectionSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClusterNetworkInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcpDiskInfoList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcpFleetParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcpType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GcpProtectionSource) validateClusterNetworkInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterNetworkInfo) { // not required
		return nil
	}

	if m.ClusterNetworkInfo != nil {
		if err := m.ClusterNetworkInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterNetworkInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterNetworkInfo")
			}
			return err
		}
	}

	return nil
}

func (m *GcpProtectionSource) validateGcpDiskInfoList(formats strfmt.Registry) error {
	if swag.IsZero(m.GcpDiskInfoList) { // not required
		return nil
	}

	for i := 0; i < len(m.GcpDiskInfoList); i++ {
		if swag.IsZero(m.GcpDiskInfoList[i]) { // not required
			continue
		}

		if m.GcpDiskInfoList[i] != nil {
			if err := m.GcpDiskInfoList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gcpDiskInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("gcpDiskInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GcpProtectionSource) validateGcpFleetParams(formats strfmt.Registry) error {
	if swag.IsZero(m.GcpFleetParams) { // not required
		return nil
	}

	if m.GcpFleetParams != nil {
		if err := m.GcpFleetParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gcpFleetParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gcpFleetParams")
			}
			return err
		}
	}

	return nil
}

var gcpProtectionSourceTypeGcpTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kIAMUser","kProject","kRegion","kAvailabilityZone","kVirtualMachine","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kLabel","kMetadata","kTag","kVPCConnector"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		gcpProtectionSourceTypeGcpTypePropEnum = append(gcpProtectionSourceTypeGcpTypePropEnum, v)
	}
}

const (

	// GcpProtectionSourceGcpTypeKIAMUser captures enum value "kIAMUser"
	GcpProtectionSourceGcpTypeKIAMUser string = "kIAMUser"

	// GcpProtectionSourceGcpTypeKProject captures enum value "kProject"
	GcpProtectionSourceGcpTypeKProject string = "kProject"

	// GcpProtectionSourceGcpTypeKRegion captures enum value "kRegion"
	GcpProtectionSourceGcpTypeKRegion string = "kRegion"

	// GcpProtectionSourceGcpTypeKAvailabilityZone captures enum value "kAvailabilityZone"
	GcpProtectionSourceGcpTypeKAvailabilityZone string = "kAvailabilityZone"

	// GcpProtectionSourceGcpTypeKVirtualMachine captures enum value "kVirtualMachine"
	GcpProtectionSourceGcpTypeKVirtualMachine string = "kVirtualMachine"

	// GcpProtectionSourceGcpTypeKVPC captures enum value "kVPC"
	GcpProtectionSourceGcpTypeKVPC string = "kVPC"

	// GcpProtectionSourceGcpTypeKSubnet captures enum value "kSubnet"
	GcpProtectionSourceGcpTypeKSubnet string = "kSubnet"

	// GcpProtectionSourceGcpTypeKNetworkSecurityGroup captures enum value "kNetworkSecurityGroup"
	GcpProtectionSourceGcpTypeKNetworkSecurityGroup string = "kNetworkSecurityGroup"

	// GcpProtectionSourceGcpTypeKInstanceType captures enum value "kInstanceType"
	GcpProtectionSourceGcpTypeKInstanceType string = "kInstanceType"

	// GcpProtectionSourceGcpTypeKLabel captures enum value "kLabel"
	GcpProtectionSourceGcpTypeKLabel string = "kLabel"

	// GcpProtectionSourceGcpTypeKMetadata captures enum value "kMetadata"
	GcpProtectionSourceGcpTypeKMetadata string = "kMetadata"

	// GcpProtectionSourceGcpTypeKTag captures enum value "kTag"
	GcpProtectionSourceGcpTypeKTag string = "kTag"

	// GcpProtectionSourceGcpTypeKVPCConnector captures enum value "kVPCConnector"
	GcpProtectionSourceGcpTypeKVPCConnector string = "kVPCConnector"
)

// prop value enum
func (m *GcpProtectionSource) validateGcpTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, gcpProtectionSourceTypeGcpTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GcpProtectionSource) validateGcpType(formats strfmt.Registry) error {
	if swag.IsZero(m.GcpType) { // not required
		return nil
	}

	// value enum
	if err := m.validateGcpTypeEnum("gcpType", "body", *m.GcpType); err != nil {
		return err
	}

	return nil
}

var gcpProtectionSourceTypeHostTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		gcpProtectionSourceTypeHostTypePropEnum = append(gcpProtectionSourceTypeHostTypePropEnum, v)
	}
}

const (

	// GcpProtectionSourceHostTypeKLinux captures enum value "kLinux"
	GcpProtectionSourceHostTypeKLinux string = "kLinux"

	// GcpProtectionSourceHostTypeKWindows captures enum value "kWindows"
	GcpProtectionSourceHostTypeKWindows string = "kWindows"

	// GcpProtectionSourceHostTypeKAix captures enum value "kAix"
	GcpProtectionSourceHostTypeKAix string = "kAix"

	// GcpProtectionSourceHostTypeKSolaris captures enum value "kSolaris"
	GcpProtectionSourceHostTypeKSolaris string = "kSolaris"

	// GcpProtectionSourceHostTypeKSapHana captures enum value "kSapHana"
	GcpProtectionSourceHostTypeKSapHana string = "kSapHana"

	// GcpProtectionSourceHostTypeKSapOracle captures enum value "kSapOracle"
	GcpProtectionSourceHostTypeKSapOracle string = "kSapOracle"

	// GcpProtectionSourceHostTypeKCockroachDB captures enum value "kCockroachDB"
	GcpProtectionSourceHostTypeKCockroachDB string = "kCockroachDB"

	// GcpProtectionSourceHostTypeKMySQL captures enum value "kMySQL"
	GcpProtectionSourceHostTypeKMySQL string = "kMySQL"

	// GcpProtectionSourceHostTypeKOther captures enum value "kOther"
	GcpProtectionSourceHostTypeKOther string = "kOther"

	// GcpProtectionSourceHostTypeKSapSybase captures enum value "kSapSybase"
	GcpProtectionSourceHostTypeKSapSybase string = "kSapSybase"

	// GcpProtectionSourceHostTypeKSapMaxDB captures enum value "kSapMaxDB"
	GcpProtectionSourceHostTypeKSapMaxDB string = "kSapMaxDB"

	// GcpProtectionSourceHostTypeKSapSybaseIQ captures enum value "kSapSybaseIQ"
	GcpProtectionSourceHostTypeKSapSybaseIQ string = "kSapSybaseIQ"

	// GcpProtectionSourceHostTypeKDB2 captures enum value "kDB2"
	GcpProtectionSourceHostTypeKDB2 string = "kDB2"

	// GcpProtectionSourceHostTypeKSapASE captures enum value "kSapASE"
	GcpProtectionSourceHostTypeKSapASE string = "kSapASE"

	// GcpProtectionSourceHostTypeKMariaDB captures enum value "kMariaDB"
	GcpProtectionSourceHostTypeKMariaDB string = "kMariaDB"

	// GcpProtectionSourceHostTypeKPostgreSQL captures enum value "kPostgreSQL"
	GcpProtectionSourceHostTypeKPostgreSQL string = "kPostgreSQL"

	// GcpProtectionSourceHostTypeKVOS captures enum value "kVOS"
	GcpProtectionSourceHostTypeKVOS string = "kVOS"

	// GcpProtectionSourceHostTypeKHPUX captures enum value "kHPUX"
	GcpProtectionSourceHostTypeKHPUX string = "kHPUX"
)

// prop value enum
func (m *GcpProtectionSource) validateHostTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, gcpProtectionSourceTypeHostTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GcpProtectionSource) validateHostType(formats strfmt.Registry) error {
	if swag.IsZero(m.HostType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHostTypeEnum("hostType", "body", *m.HostType); err != nil {
		return err
	}

	return nil
}

func (m *GcpProtectionSource) validateTagAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.TagAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.TagAttributes); i++ {
		if swag.IsZero(m.TagAttributes[i]) { // not required
			continue
		}

		if m.TagAttributes[i] != nil {
			if err := m.TagAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var gcpProtectionSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kIAMUser","kProject","kRegion","kAvailabilityZone","kVirtualMachine","kVPC","kSubnet","kNetworkSecurityGroup","kInstanceType","kLabel","kMetadata","kTag","kVPCConnector"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		gcpProtectionSourceTypeTypePropEnum = append(gcpProtectionSourceTypeTypePropEnum, v)
	}
}

const (

	// GcpProtectionSourceTypeKIAMUser captures enum value "kIAMUser"
	GcpProtectionSourceTypeKIAMUser string = "kIAMUser"

	// GcpProtectionSourceTypeKProject captures enum value "kProject"
	GcpProtectionSourceTypeKProject string = "kProject"

	// GcpProtectionSourceTypeKRegion captures enum value "kRegion"
	GcpProtectionSourceTypeKRegion string = "kRegion"

	// GcpProtectionSourceTypeKAvailabilityZone captures enum value "kAvailabilityZone"
	GcpProtectionSourceTypeKAvailabilityZone string = "kAvailabilityZone"

	// GcpProtectionSourceTypeKVirtualMachine captures enum value "kVirtualMachine"
	GcpProtectionSourceTypeKVirtualMachine string = "kVirtualMachine"

	// GcpProtectionSourceTypeKVPC captures enum value "kVPC"
	GcpProtectionSourceTypeKVPC string = "kVPC"

	// GcpProtectionSourceTypeKSubnet captures enum value "kSubnet"
	GcpProtectionSourceTypeKSubnet string = "kSubnet"

	// GcpProtectionSourceTypeKNetworkSecurityGroup captures enum value "kNetworkSecurityGroup"
	GcpProtectionSourceTypeKNetworkSecurityGroup string = "kNetworkSecurityGroup"

	// GcpProtectionSourceTypeKInstanceType captures enum value "kInstanceType"
	GcpProtectionSourceTypeKInstanceType string = "kInstanceType"

	// GcpProtectionSourceTypeKLabel captures enum value "kLabel"
	GcpProtectionSourceTypeKLabel string = "kLabel"

	// GcpProtectionSourceTypeKMetadata captures enum value "kMetadata"
	GcpProtectionSourceTypeKMetadata string = "kMetadata"

	// GcpProtectionSourceTypeKTag captures enum value "kTag"
	GcpProtectionSourceTypeKTag string = "kTag"

	// GcpProtectionSourceTypeKVPCConnector captures enum value "kVPCConnector"
	GcpProtectionSourceTypeKVPCConnector string = "kVPCConnector"
)

// prop value enum
func (m *GcpProtectionSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, gcpProtectionSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GcpProtectionSource) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this gcp protection source based on the context it is used
func (m *GcpProtectionSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateClusterNetworkInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGcpDiskInfoList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGcpFleetParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTagAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GcpProtectionSource) contextValidateClusterNetworkInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ClusterNetworkInfo != nil {

		if swag.IsZero(m.ClusterNetworkInfo) { // not required
			return nil
		}

		if err := m.ClusterNetworkInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clusterNetworkInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("clusterNetworkInfo")
			}
			return err
		}
	}

	return nil
}

func (m *GcpProtectionSource) contextValidateGcpDiskInfoList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GcpDiskInfoList); i++ {

		if m.GcpDiskInfoList[i] != nil {

			if swag.IsZero(m.GcpDiskInfoList[i]) { // not required
				return nil
			}

			if err := m.GcpDiskInfoList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gcpDiskInfoList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("gcpDiskInfoList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GcpProtectionSource) contextValidateGcpFleetParams(ctx context.Context, formats strfmt.Registry) error {

	if m.GcpFleetParams != nil {

		if swag.IsZero(m.GcpFleetParams) { // not required
			return nil
		}

		if err := m.GcpFleetParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gcpFleetParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gcpFleetParams")
			}
			return err
		}
	}

	return nil
}

func (m *GcpProtectionSource) contextValidateTagAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TagAttributes); i++ {

		if m.TagAttributes[i] != nil {

			if swag.IsZero(m.TagAttributes[i]) { // not required
				return nil
			}

			if err := m.TagAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GcpProtectionSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GcpProtectionSource) UnmarshalBinary(b []byte) error {
	var res GcpProtectionSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
