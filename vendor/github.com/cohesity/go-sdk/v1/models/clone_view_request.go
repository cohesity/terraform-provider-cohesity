// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CloneViewRequest Clone View Request.
//
// Specifies the settings for cloning an existing View.
//
// swagger:model CloneViewRequest
type CloneViewRequest struct {

	// Array of Security Identifiers (SIDs)
	//
	// Specifies the list of security identifiers (SIDs) for the restricted
	// Principals who have access to this View.
	AccessSids []string `json:"accessSids"`

	// Specifies the antivirus scan config settings for this View.
	AntivirusScanConfig *AntivirusScanConfig `json:"antivirusScanConfig,omitempty"`

	// Specifies the name of the new View that is cloned from the source View.
	CloneViewName *string `json:"cloneViewName,omitempty"`

	// DataLock (Write Once Read Many) lock expiry epoch time in microseconds. If
	// specified, a view will be marked as a DataLock view. If a view is marked
	// as a DataLock view, only a Data Security Officer (a user having Data
	// Security Privilege) can delete the view until the lock expiry time.
	DataLockExpiryUsecs *int64 `json:"dataLockExpiryUsecs,omitempty"`

	// Specifies an optional text description about the View.
	Description *string `json:"description,omitempty"`

	// Specifies whether fast durable handle is enabled. If enabled, view open
	// handle will be kept in memory, which results in a higher performance. But
	// the handles cannot be recovered if node or service crashes.
	EnableFastDurableHandle *bool `json:"enableFastDurableHandle,omitempty"`

	// Specifies if Filer Audit Logging is enabled for this view.
	EnableFilerAuditLogging *bool `json:"enableFilerAuditLogging,omitempty"`

	// Specifies whether to enable live indexing for the view.
	EnableLiveIndexing *bool `json:"enableLiveIndexing,omitempty"`

	// Specifies whether view is blur enabled.
	EnableMetadataAccelerator *bool `json:"enableMetadataAccelerator,omitempty"`

	// If set, mixed mode (NFS and SMB) access is enabled for this view.
	// This field is deprecated. Use the field SecurityMode.
	// deprecated: true
	EnableMixedModePermissions *bool `json:"enableMixedModePermissions,omitempty"`

	// If set, it enables discovery of view for NFS.
	EnableNfsViewDiscovery *bool `json:"enableNfsViewDiscovery,omitempty"`

	// Specifies whether to enable offline file caching of the view.
	EnableOfflineCaching *bool `json:"enableOfflineCaching,omitempty"`

	// Specifies if access-based enumeration should be enabled.
	// If 'true', only files and folders that the user has permissions to
	// access are visible on the SMB share for that user.
	EnableSmbAccessBasedEnumeration *bool `json:"enableSmbAccessBasedEnumeration,omitempty"`

	// Specifies the SMB encryption for the View. If set, it enables the SMB
	// encryption for the View. Encryption is supported only by SMB 3.x dialects.
	// Dialects that do not support would still access data in unencrypted
	// format.
	EnableSmbEncryption *bool `json:"enableSmbEncryption,omitempty"`

	// Specifies whether SMB opportunistic lock is enabled.
	EnableSmbOplock *bool `json:"enableSmbOplock,omitempty"`

	// If set, it enables discovery of view for SMB.
	EnableSmbViewDiscovery *bool `json:"enableSmbViewDiscovery,omitempty"`

	// Specifies the SMB encryption for all the sessions for the View.
	// If set, encryption is enforced for all the sessions for the View. When
	// enabled all future and existing unencrypted sessions are disallowed.
	EnforceSmbEncryption *bool `json:"enforceSmbEncryption,omitempty"`

	// Optional filtering criteria that should be satisfied by all the files
	// created in this view. It does not affect existing files.
	FileExtensionFilter *FileExtensionFilter `json:"fileExtensionFilter,omitempty"`

	// Optional config that enables file locking for this view. It cannot be
	// disabled during the edit of a view, if it has been enabled during the
	// creation of the view. Also, it cannot be enabled if it was disabled
	// during the creation of the view.
	FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

	// Specifies whether view is for externally triggered backup target.
	IsExternallyTriggeredBackupTarget *bool `json:"isExternallyTriggeredBackupTarget,omitempty"`

	// Specifies if the view is a read only view. User will no longer be able to
	// write to this view if this is set to true.
	IsReadOnly *bool `json:"isReadOnly,omitempty"`

	// Specifies an optional logical quota limit (in bytes) for the usage allowed
	// on this View.
	// (Logical data is when the data is fully hydrated and expanded.)
	// This limit overrides the limit inherited from the Storage Domain
	// (View Box) (if set).
	// If logicalQuota is nil, the limit is inherited from the
	// Storage Domain (View Box) (if set).
	// A new write is not allowed if the Storage Domain (View Box) will exceed the
	// specified quota.
	// However, it takes time for the Cohesity Cluster to calculate
	// the usage across Nodes, so the limit may be exceeded by a small amount.
	// In addition, if the limit is increased or data is removed,
	// there may be a delay before the Cohesity Cluster allows more data
	// to be written to the View, as the Cluster is calculating the usage
	// across Nodes.
	LogicalQuota struct {
		QuotaPolicy
	} `json:"logicalQuota,omitempty"`

	// Array of Netgroups.
	//
	// Specifies a list of Netgroups that have permissions to access the
	// View. (Overrides the Netgroups specified at the global Cohesity
	// Cluster level.)
	NetgroupWhitelist []*NisNetgroup `json:"netgroupWhitelist"`

	// Specifies the NFS all squash config.
	NfsAllSquash *NfsSquash `json:"nfsAllSquash,omitempty"`

	// Specifies the NFS root permission config of the view file system.
	NfsRootPermissions *NfsRootPermissions `json:"nfsRootPermissions,omitempty"`

	// Specifies the NFS root squash config.
	NfsRootSquash *NfsSquash `json:"nfsRootSquash,omitempty"`

	// Specifies whether view level client netgroup allowlist overrides cluster
	// and global setting.
	OverrideGlobalNetgroupWhitelist *bool `json:"overrideGlobalNetgroupWhitelist,omitempty"`

	// Specifies whether view level client subnet allowlist overrides cluster and
	// global setting.
	OverrideGlobalWhitelist *bool `json:"overrideGlobalWhitelist,omitempty"`

	// Deprecated: Specifies the supported Protocols for the View.
	// 'kAll' enables protocol access to following three views: NFS, SMB and S3.
	// 'kNFSOnly' enables protocol access to NFS only.
	// 'kSMBOnly' enables protocol access to SMB only.
	// 'kS3Only' enables protocol access to S3 only.
	// 'kSwiftOnly' enables protocol access to Swift only.
	// 'kUnknown' indicates that the protocol access of a view does not match
	// any of the above. In this case, the constant is used as 'catch-all'.
	// Enum: ["kAll","kNFSOnly","kSMBOnly","kS3Only","kSwiftOnly","kUnknown"]
	ProtocolAccess *string `json:"protocolAccess,omitempty"`

	// Specifies the Quality of Service (QoS) Policy for the View.
	Qos *QoS `json:"qos,omitempty"`

	// Specifies the security mode used for this view.
	// Currently we support the following modes: Native, Unified and NTFS style.
	// 'kNativeMode' indicates a native security mode.
	// 'kUnifiedMode' indicates a unified security mode.
	// 'kNtfsMode' indicates a NTFS style security mode.
	// Enum: ["kNativeMode","kUnifiedMode","kNtfsMode"]
	SecurityMode *string `json:"securityMode,omitempty"`

	// Specifies a list of share level permissions.
	SharePermissions []*SmbPermission `json:"sharePermissions"`

	// Specifies the SMB permissions for the View.
	SmbPermissionsInfo *SmbPermissionsInfo `json:"smbPermissionsInfo,omitempty"`

	// Specifies the name of the source View that will be cloned.
	SourceViewName *string `json:"sourceViewName,omitempty"`

	// Specifies if inline deduplication and compression settings inherited from
	// the Storage Domain (View Box) should be disabled for this View.
	StoragePolicyOverride *StoragePolicyOverride `json:"storagePolicyOverride,omitempty"`

	// Array of Subnets.
	//
	// Specifies a list of Subnets with IP addresses that have permissions to
	// access the View. (Overrides the Subnets specified at the global
	// Cohesity Cluster level.)
	SubnetWhitelist []*Subnet `json:"subnetWhitelist"`

	// Specifies a list of user sids who have Superuser access to this view.
	SuperUserSids []string `json:"superUserSids"`

	// Specifies the Keystone project domain.
	SwiftProjectDomain *string `json:"swiftProjectDomain,omitempty"`

	// Specifies the Keystone project name.
	SwiftProjectName *string `json:"swiftProjectName,omitempty"`

	// Optional tenant id who has access to this View.
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies whether view lock is enabled. If enabled the view cannot be
	// modified or deleted until unlock. By default it is disabled.
	ViewLockEnabled *bool `json:"viewLockEnabled,omitempty"`

	// Specifies the pinning config of this view.
	ViewPinningConfig *ViewPinningConfig `json:"viewPinningConfig,omitempty"`

	// Specifies the supported Protocols for the View.
	ViewProtocol []*ViewProtocol `json:"viewProtocol"`
}

// Validate validates this clone view request
func (m *CloneViewRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAntivirusScanConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileExtensionFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileLockConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogicalQuota(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetgroupWhitelist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsAllSquash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsRootPermissions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsRootSquash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocolAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSharePermissions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSmbPermissionsInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStoragePolicyOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubnetWhitelist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewPinningConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloneViewRequest) validateAntivirusScanConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AntivirusScanConfig) { // not required
		return nil
	}

	if m.AntivirusScanConfig != nil {
		if err := m.AntivirusScanConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("antivirusScanConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("antivirusScanConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateFileExtensionFilter(formats strfmt.Registry) error {
	if swag.IsZero(m.FileExtensionFilter) { // not required
		return nil
	}

	if m.FileExtensionFilter != nil {
		if err := m.FileExtensionFilter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileExtensionFilter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileExtensionFilter")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateFileLockConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FileLockConfig) { // not required
		return nil
	}

	if m.FileLockConfig != nil {
		if err := m.FileLockConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateLogicalQuota(formats strfmt.Registry) error {
	if swag.IsZero(m.LogicalQuota) { // not required
		return nil
	}

	return nil
}

func (m *CloneViewRequest) validateNetgroupWhitelist(formats strfmt.Registry) error {
	if swag.IsZero(m.NetgroupWhitelist) { // not required
		return nil
	}

	for i := 0; i < len(m.NetgroupWhitelist); i++ {
		if swag.IsZero(m.NetgroupWhitelist[i]) { // not required
			continue
		}

		if m.NetgroupWhitelist[i] != nil {
			if err := m.NetgroupWhitelist[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("netgroupWhitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("netgroupWhitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneViewRequest) validateNfsAllSquash(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsAllSquash) { // not required
		return nil
	}

	if m.NfsAllSquash != nil {
		if err := m.NfsAllSquash.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfsAllSquash")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfsAllSquash")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateNfsRootPermissions(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsRootPermissions) { // not required
		return nil
	}

	if m.NfsRootPermissions != nil {
		if err := m.NfsRootPermissions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfsRootPermissions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfsRootPermissions")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateNfsRootSquash(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsRootSquash) { // not required
		return nil
	}

	if m.NfsRootSquash != nil {
		if err := m.NfsRootSquash.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfsRootSquash")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfsRootSquash")
			}
			return err
		}
	}

	return nil
}

var cloneViewRequestTypeProtocolAccessPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAll","kNFSOnly","kSMBOnly","kS3Only","kSwiftOnly","kUnknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloneViewRequestTypeProtocolAccessPropEnum = append(cloneViewRequestTypeProtocolAccessPropEnum, v)
	}
}

const (

	// CloneViewRequestProtocolAccessKAll captures enum value "kAll"
	CloneViewRequestProtocolAccessKAll string = "kAll"

	// CloneViewRequestProtocolAccessKNFSOnly captures enum value "kNFSOnly"
	CloneViewRequestProtocolAccessKNFSOnly string = "kNFSOnly"

	// CloneViewRequestProtocolAccessKSMBOnly captures enum value "kSMBOnly"
	CloneViewRequestProtocolAccessKSMBOnly string = "kSMBOnly"

	// CloneViewRequestProtocolAccessKS3Only captures enum value "kS3Only"
	CloneViewRequestProtocolAccessKS3Only string = "kS3Only"

	// CloneViewRequestProtocolAccessKSwiftOnly captures enum value "kSwiftOnly"
	CloneViewRequestProtocolAccessKSwiftOnly string = "kSwiftOnly"

	// CloneViewRequestProtocolAccessKUnknown captures enum value "kUnknown"
	CloneViewRequestProtocolAccessKUnknown string = "kUnknown"
)

// prop value enum
func (m *CloneViewRequest) validateProtocolAccessEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloneViewRequestTypeProtocolAccessPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloneViewRequest) validateProtocolAccess(formats strfmt.Registry) error {
	if swag.IsZero(m.ProtocolAccess) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolAccessEnum("protocolAccess", "body", *m.ProtocolAccess); err != nil {
		return err
	}

	return nil
}

func (m *CloneViewRequest) validateQos(formats strfmt.Registry) error {
	if swag.IsZero(m.Qos) { // not required
		return nil
	}

	if m.Qos != nil {
		if err := m.Qos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

var cloneViewRequestTypeSecurityModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNativeMode","kUnifiedMode","kNtfsMode"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cloneViewRequestTypeSecurityModePropEnum = append(cloneViewRequestTypeSecurityModePropEnum, v)
	}
}

const (

	// CloneViewRequestSecurityModeKNativeMode captures enum value "kNativeMode"
	CloneViewRequestSecurityModeKNativeMode string = "kNativeMode"

	// CloneViewRequestSecurityModeKUnifiedMode captures enum value "kUnifiedMode"
	CloneViewRequestSecurityModeKUnifiedMode string = "kUnifiedMode"

	// CloneViewRequestSecurityModeKNtfsMode captures enum value "kNtfsMode"
	CloneViewRequestSecurityModeKNtfsMode string = "kNtfsMode"
)

// prop value enum
func (m *CloneViewRequest) validateSecurityModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cloneViewRequestTypeSecurityModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CloneViewRequest) validateSecurityMode(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateSecurityModeEnum("securityMode", "body", *m.SecurityMode); err != nil {
		return err
	}

	return nil
}

func (m *CloneViewRequest) validateSharePermissions(formats strfmt.Registry) error {
	if swag.IsZero(m.SharePermissions) { // not required
		return nil
	}

	for i := 0; i < len(m.SharePermissions); i++ {
		if swag.IsZero(m.SharePermissions[i]) { // not required
			continue
		}

		if m.SharePermissions[i] != nil {
			if err := m.SharePermissions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sharePermissions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sharePermissions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneViewRequest) validateSmbPermissionsInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.SmbPermissionsInfo) { // not required
		return nil
	}

	if m.SmbPermissionsInfo != nil {
		if err := m.SmbPermissionsInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("smbPermissionsInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("smbPermissionsInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateStoragePolicyOverride(formats strfmt.Registry) error {
	if swag.IsZero(m.StoragePolicyOverride) { // not required
		return nil
	}

	if m.StoragePolicyOverride != nil {
		if err := m.StoragePolicyOverride.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicyOverride")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicyOverride")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateSubnetWhitelist(formats strfmt.Registry) error {
	if swag.IsZero(m.SubnetWhitelist) { // not required
		return nil
	}

	for i := 0; i < len(m.SubnetWhitelist); i++ {
		if swag.IsZero(m.SubnetWhitelist[i]) { // not required
			continue
		}

		if m.SubnetWhitelist[i] != nil {
			if err := m.SubnetWhitelist[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneViewRequest) validateViewPinningConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ViewPinningConfig) { // not required
		return nil
	}

	if m.ViewPinningConfig != nil {
		if err := m.ViewPinningConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewPinningConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("viewPinningConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) validateViewProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.ViewProtocol) { // not required
		return nil
	}

	for i := 0; i < len(m.ViewProtocol); i++ {
		if swag.IsZero(m.ViewProtocol[i]) { // not required
			continue
		}

		if m.ViewProtocol[i] != nil {
			if err := m.ViewProtocol[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("viewProtocol" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("viewProtocol" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this clone view request based on the context it is used
func (m *CloneViewRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAntivirusScanConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileExtensionFilter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileLockConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogicalQuota(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetgroupWhitelist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfsAllSquash(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfsRootPermissions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfsRootSquash(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSharePermissions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSmbPermissionsInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStoragePolicyOverride(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubnetWhitelist(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViewPinningConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViewProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CloneViewRequest) contextValidateAntivirusScanConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AntivirusScanConfig != nil {

		if swag.IsZero(m.AntivirusScanConfig) { // not required
			return nil
		}

		if err := m.AntivirusScanConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("antivirusScanConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("antivirusScanConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateFileExtensionFilter(ctx context.Context, formats strfmt.Registry) error {

	if m.FileExtensionFilter != nil {

		if swag.IsZero(m.FileExtensionFilter) { // not required
			return nil
		}

		if err := m.FileExtensionFilter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileExtensionFilter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileExtensionFilter")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateFileLockConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FileLockConfig != nil {

		if swag.IsZero(m.FileLockConfig) { // not required
			return nil
		}

		if err := m.FileLockConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateLogicalQuota(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *CloneViewRequest) contextValidateNetgroupWhitelist(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetgroupWhitelist); i++ {

		if m.NetgroupWhitelist[i] != nil {

			if swag.IsZero(m.NetgroupWhitelist[i]) { // not required
				return nil
			}

			if err := m.NetgroupWhitelist[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("netgroupWhitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("netgroupWhitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneViewRequest) contextValidateNfsAllSquash(ctx context.Context, formats strfmt.Registry) error {

	if m.NfsAllSquash != nil {

		if swag.IsZero(m.NfsAllSquash) { // not required
			return nil
		}

		if err := m.NfsAllSquash.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfsAllSquash")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfsAllSquash")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateNfsRootPermissions(ctx context.Context, formats strfmt.Registry) error {

	if m.NfsRootPermissions != nil {

		if swag.IsZero(m.NfsRootPermissions) { // not required
			return nil
		}

		if err := m.NfsRootPermissions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfsRootPermissions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfsRootPermissions")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateNfsRootSquash(ctx context.Context, formats strfmt.Registry) error {

	if m.NfsRootSquash != nil {

		if swag.IsZero(m.NfsRootSquash) { // not required
			return nil
		}

		if err := m.NfsRootSquash.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfsRootSquash")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfsRootSquash")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateQos(ctx context.Context, formats strfmt.Registry) error {

	if m.Qos != nil {

		if swag.IsZero(m.Qos) { // not required
			return nil
		}

		if err := m.Qos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("qos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("qos")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateSharePermissions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SharePermissions); i++ {

		if m.SharePermissions[i] != nil {

			if swag.IsZero(m.SharePermissions[i]) { // not required
				return nil
			}

			if err := m.SharePermissions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sharePermissions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sharePermissions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneViewRequest) contextValidateSmbPermissionsInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.SmbPermissionsInfo != nil {

		if swag.IsZero(m.SmbPermissionsInfo) { // not required
			return nil
		}

		if err := m.SmbPermissionsInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("smbPermissionsInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("smbPermissionsInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateStoragePolicyOverride(ctx context.Context, formats strfmt.Registry) error {

	if m.StoragePolicyOverride != nil {

		if swag.IsZero(m.StoragePolicyOverride) { // not required
			return nil
		}

		if err := m.StoragePolicyOverride.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storagePolicyOverride")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storagePolicyOverride")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateSubnetWhitelist(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SubnetWhitelist); i++ {

		if m.SubnetWhitelist[i] != nil {

			if swag.IsZero(m.SubnetWhitelist[i]) { // not required
				return nil
			}

			if err := m.SubnetWhitelist[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("subnetWhitelist" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CloneViewRequest) contextValidateViewPinningConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ViewPinningConfig != nil {

		if swag.IsZero(m.ViewPinningConfig) { // not required
			return nil
		}

		if err := m.ViewPinningConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewPinningConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("viewPinningConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CloneViewRequest) contextValidateViewProtocol(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ViewProtocol); i++ {

		if m.ViewProtocol[i] != nil {

			if swag.IsZero(m.ViewProtocol[i]) { // not required
				return nil
			}

			if err := m.ViewProtocol[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("viewProtocol" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("viewProtocol" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CloneViewRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CloneViewRequest) UnmarshalBinary(b []byte) error {
	var res CloneViewRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
