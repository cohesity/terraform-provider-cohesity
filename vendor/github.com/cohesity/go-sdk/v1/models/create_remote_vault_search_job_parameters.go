// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateRemoteVaultSearchJobParameters Create Remote Vault Search Request.
//
// Specifies settings required to create a search of a
// remote Vault for data that has been archived from other Clusters.
//
// swagger:model CreateRemoteVaultSearchJobParameters
type CreateRemoteVaultSearchJobParameters struct {

	// Filter by specifying a list of remote job uids in form of
	// clusterId:clusterIncarnationId:jobId.
	JobUids []string `json:"JobUids"`

	// Filter by specifying a Cluster id.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Filter by specifying a Cluster name prefix string.
	// Only Clusters with names that start with this prefix string are returned
	// in the search result.
	// If not set, all Clusters archiving data to the Vault
	// are returned in the search results.
	ClusterMatchString *string `json:"clusterMatchString,omitempty"`

	// Array of Encryption Keys.
	//
	// Specifies an optional list of encryption keys that may be needed to
	// search and restore data that was archived to a remote Vault.
	// Archived data cannot be searched or restored without the
	// corresponding encryption key used by the original Cluster
	// to archive the data.
	// Encryption keys can be uploaded using the REST API
	// public/remoteVaults/encryptionKeys operation.
	// If the key is already uploaded, this field does not need to be
	// specified.
	EncryptionKeys []*VaultEncryptionKey `json:"encryptionKeys"`

	// Filter by a end time specified as a Unix epoch Timestamp
	// (in microseconds). Only Job Runs that completed before the specified
	// end time are included in the search results.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Filter by specifying a Protection Job name prefix string.
	// Only Protection Jobs with names that start with this prefix string
	// are returned in the search result.
	// If not set, all Protection Jobs archiving data to the Vault
	// are returned in the search results.
	JobMatchString *string `json:"jobMatchString,omitempty"`

	// Specifies the search Job name.
	// Required: true
	SearchJobName *string `json:"searchJobName"`

	// Filter by a start time specified as a Unix epoch Timestamp
	// (in microseconds). Only Job Runs that started after the specified
	// time are included in the search results.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// Specifies the id of the Vault to search. This id was assigned by the
	// local Cohesity Cluster when Vault was registered as an External Target.
	// Required: true
	VaultID *int64 `json:"vaultId"`
}

// Validate validates this create remote vault search job parameters
func (m *CreateRemoteVaultSearchJobParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEncryptionKeys(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchJobName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaultID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateRemoteVaultSearchJobParameters) validateEncryptionKeys(formats strfmt.Registry) error {
	if swag.IsZero(m.EncryptionKeys) { // not required
		return nil
	}

	for i := 0; i < len(m.EncryptionKeys); i++ {
		if swag.IsZero(m.EncryptionKeys[i]) { // not required
			continue
		}

		if m.EncryptionKeys[i] != nil {
			if err := m.EncryptionKeys[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("encryptionKeys" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("encryptionKeys" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CreateRemoteVaultSearchJobParameters) validateSearchJobName(formats strfmt.Registry) error {

	if err := validate.Required("searchJobName", "body", m.SearchJobName); err != nil {
		return err
	}

	return nil
}

func (m *CreateRemoteVaultSearchJobParameters) validateVaultID(formats strfmt.Registry) error {

	if err := validate.Required("vaultId", "body", m.VaultID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create remote vault search job parameters based on the context it is used
func (m *CreateRemoteVaultSearchJobParameters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEncryptionKeys(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateRemoteVaultSearchJobParameters) contextValidateEncryptionKeys(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.EncryptionKeys); i++ {

		if m.EncryptionKeys[i] != nil {

			if swag.IsZero(m.EncryptionKeys[i]) { // not required
				return nil
			}

			if err := m.EncryptionKeys[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("encryptionKeys" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("encryptionKeys" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateRemoteVaultSearchJobParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateRemoteVaultSearchJobParameters) UnmarshalBinary(b []byte) error {
	var res CreateRemoteVaultSearchJobParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
