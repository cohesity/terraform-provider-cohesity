// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CopyBackupRunStateProto This message contains persistent information about all tasks that copy the
// snapshots of a specific backup run to one or more targets.
//
// swagger:model CopyBackupRunStateProto
type CopyBackupRunStateProto struct {

	// A list of active copy tasks for the backup run.
	ActiveTasks []*CopyBackupRunTaskStateProto `json:"activeTasks"`

	// If this is an out of band copy run, this will specify the targets (and
	// retention settings on those targets) that the backup run snapshots need to
	// be copied to. This will not be populated for a regular copy run.
	CopySnapshotParamsVec []*CopySnapshotParams `json:"copySnapshotParamsVec"`

	// The time the tasks to copy the backup run's snapshots finished.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Will contain any error encountered by the task.
	Error *PrivateErrorProto `json:"error,omitempty"`

	// A list of finished copy tasks for the backup run.
	FinishedTasks []*CopyBackupRunTaskStateProto `json:"finishedTasks"`

	// Denotes whether this copy run was initiated by a user with DSO role, this
	// could be relevant for out of band copy runs triggered via 'Edit Run'.
	InitiatedByDsoRole *bool `json:"initiatedByDsoRole,omitempty"`

	// Whether this copy run was created for cascaded replication/archival.
	IsCascadedCopy *bool `json:"isCascadedCopy,omitempty"`

	// Indicates whether the copy run was initialized by garbage collection
	// in order to update the snapshot expiry on the external target.
	IsGcInitiated *bool `json:"isGcInitiated,omitempty"`

	// Whether this is an out of band (OOB) copy run triggered by the user.
	IsOutOfBandRun *bool `json:"isOutOfBandRun,omitempty"`

	// This field indicates whether the expiry time of the copy tasks under this
	// run was determined artifically by the smart retention adjustment feature.
	IsSmartRetentionSet *bool `json:"isSmartRetentionSet,omitempty"`

	// The instance id of the backup run whose snapshots are to be copied.
	JobInstanceID *int64 `json:"jobInstanceId,omitempty"`

	// The globally unique id of the backup job whose snapshots are to be copied.
	JobUID *UniversalIDProto `json:"jobUid,omitempty"`

	// This is a run sequencer which will incremented whenever run reaches a new
	// milestone. A milestone can be a change in state, or attempts, progress
	// percentage incrementals (e.g. 10%), This will be used by Helios ETL to
	// identify the latest copy of the backup run.
	LastUpdateLogicalTimestamp *int64 `json:"lastUpdateLogicalTimestamp,omitempty"`

	// Indicates whether the backup run corresponding to this copy run should be
	// locked or not.
	LockingRequired *bool `json:"lockingRequired,omitempty"`

	// The start time of the backup run whose snapshots are to be copied.
	RunStartTimeUsecs *int64 `json:"runStartTimeUsecs,omitempty"`

	// The time the tasks to copy the backup run's snapshots started.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// The overall status of the copy tasks.
	Status *int32 `json:"status,omitempty"`

	// This field will only be populated when this proto is returned in an
	// external HTTP RPC response (e.g., for Iris). The copy run returned
	// in the external call is created by merging all the copy runs for the
	// backup run. This field will contain the sum total of the duration of each
	// of the copy runs that were merged.
	TotalDurationUsecs *int64 `json:"totalDurationUsecs,omitempty"`

	// The environment type of the backup run whose snapshots are to be copied.
	Type *int32 `json:"type,omitempty"`
}

// Validate validates this copy backup run state proto
func (m *CopyBackupRunStateProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActiveTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCopySnapshotParamsVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinishedTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJobUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CopyBackupRunStateProto) validateActiveTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.ActiveTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.ActiveTasks); i++ {
		if swag.IsZero(m.ActiveTasks[i]) { // not required
			continue
		}

		if m.ActiveTasks[i] != nil {
			if err := m.ActiveTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunStateProto) validateCopySnapshotParamsVec(formats strfmt.Registry) error {
	if swag.IsZero(m.CopySnapshotParamsVec) { // not required
		return nil
	}

	for i := 0; i < len(m.CopySnapshotParamsVec); i++ {
		if swag.IsZero(m.CopySnapshotParamsVec[i]) { // not required
			continue
		}

		if m.CopySnapshotParamsVec[i] != nil {
			if err := m.CopySnapshotParamsVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunStateProto) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunStateProto) validateFinishedTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.FinishedTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.FinishedTasks); i++ {
		if swag.IsZero(m.FinishedTasks[i]) { // not required
			continue
		}

		if m.FinishedTasks[i] != nil {
			if err := m.FinishedTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunStateProto) validateJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.JobUID) { // not required
		return nil
	}

	if m.JobUID != nil {
		if err := m.JobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this copy backup run state proto based on the context it is used
func (m *CopyBackupRunStateProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActiveTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCopySnapshotParamsVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinishedTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CopyBackupRunStateProto) contextValidateActiveTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ActiveTasks); i++ {

		if m.ActiveTasks[i] != nil {

			if swag.IsZero(m.ActiveTasks[i]) { // not required
				return nil
			}

			if err := m.ActiveTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activeTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunStateProto) contextValidateCopySnapshotParamsVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CopySnapshotParamsVec); i++ {

		if m.CopySnapshotParamsVec[i] != nil {

			if swag.IsZero(m.CopySnapshotParamsVec[i]) { // not required
				return nil
			}

			if err := m.CopySnapshotParamsVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunStateProto) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {

		if swag.IsZero(m.Error) { // not required
			return nil
		}

		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunStateProto) contextValidateFinishedTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FinishedTasks); i++ {

		if m.FinishedTasks[i] != nil {

			if swag.IsZero(m.FinishedTasks[i]) { // not required
				return nil
			}

			if err := m.FinishedTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunStateProto) contextValidateJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.JobUID != nil {

		if swag.IsZero(m.JobUID) { // not required
			return nil
		}

		if err := m.JobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CopyBackupRunStateProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CopyBackupRunStateProto) UnmarshalBinary(b []byte) error {
	var res CopyBackupRunStateProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
