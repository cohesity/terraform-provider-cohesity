// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// O365BackupParams This message contains additional params for an O365 backup job run.
//
// swagger:model O365BackupParams
type O365BackupParams struct {

	// Indicates whether scaling o365 permits based on number of application ids
	// installed is enabled.
	ApplicationIdsPermitScalingEnabled *bool `json:"applicationIdsPermitScalingEnabled,omitempty"`

	// This field is only used for site entities.
	ChildSiteVec []*O365BackupParamsSiteInfo `json:"childSiteVec"`

	// If true, delete cloned directory.
	DeleteClonedDirectory *bool `json:"deleteClonedDirectory,omitempty"`

	// Dir to renamed when cloning. Incase if the prev run failed, we need to
	// send this from master to slave.
	DirToBeRenamed *string `json:"dirToBeRenamed,omitempty"`

	// This flag indicates whether we are in the view cloning paradigm for the
	// first time or not. i.e. the previous run used the default magneto backup
	// view.
	FirstTimeViewClone *bool `json:"firstTimeViewClone,omitempty"`

	// If true, then automatic full backup was triggered for this attempt.
	IsAutomaticFullBackup *bool `json:"isAutomaticFullBackup,omitempty"`

	// Indicates whether sharepoint template backup can be skipped or not.
	MaybeSkipSharepointTemplateBackup *bool `json:"maybeSkipSharepointTemplateBackup,omitempty"`

	// parent site
	ParentSite *O365BackupParamsSiteInfo `json:"parentSite,omitempty"`

	// For view cloning per run, o365 environment needs the view name used in
	// the last run (with at least one finished attempt).
	PreviousRunViewName *string `json:"previousRunViewName,omitempty"`

	// If true, check for the lookup error and trigger full backup if required.
	ReportLookupError *bool `json:"reportLookupError,omitempty"`

	// Whether to backup onedrive of entity being backed up. This is only used
	// for user and group type entities.
	ShouldBackupOnedrive *bool `json:"shouldBackupOnedrive,omitempty"`

	// Whether the entity to be backed up is a sharepoint entity or not.
	ShouldBackupSharepoint *bool `json:"shouldBackupSharepoint,omitempty"`

	// Only used for onedrive, whether we should do recon data run due to resync
	// error in prev run for this drive.
	ShouldReconDataForResync *bool `json:"shouldReconDataForResync,omitempty"`

	// If slave needs to clone the entity snapshot directory recursively.
	ShouldRecursivelyCloneSharepointDir *bool `json:"shouldRecursivelyCloneSharepointDir,omitempty"`

	// Whether the onedrive task should use flat file structure or not.
	ShouldUseFlatFileStructure *bool `json:"shouldUseFlatFileStructure,omitempty"`

	// Relative path of sharepoint site in snapfs. If there is a subsite A
	// inside a site B, its path will be
	// {domain}/site-{site id of A}/site-{site id of B}
	// This field will contain path relative to {domain} i.e.
	// site-{site id of A}/site-{site id of B}
	SiteRelativePath *string `json:"siteRelativePath,omitempty"`

	// Sla deadline from backup job policy.
	SLADeadlineTimeUsecs *int64 `json:"slaDeadlineTimeUsecs,omitempty"`

	// The total size of the entity known at the time of registration.
	TotalEntityLogicalSize *int64 `json:"totalEntityLogicalSize,omitempty"`

	// This is an explicit flag to intimate slave that master already cloned the
	// view.
	ViewCloningEnabled *bool `json:"viewCloningEnabled,omitempty"`
}

// Validate validates this o365 backup params
func (m *O365BackupParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChildSiteVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentSite(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *O365BackupParams) validateChildSiteVec(formats strfmt.Registry) error {
	if swag.IsZero(m.ChildSiteVec) { // not required
		return nil
	}

	for i := 0; i < len(m.ChildSiteVec); i++ {
		if swag.IsZero(m.ChildSiteVec[i]) { // not required
			continue
		}

		if m.ChildSiteVec[i] != nil {
			if err := m.ChildSiteVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("childSiteVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("childSiteVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *O365BackupParams) validateParentSite(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentSite) { // not required
		return nil
	}

	if m.ParentSite != nil {
		if err := m.ParentSite.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parentSite")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parentSite")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o365 backup params based on the context it is used
func (m *O365BackupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateChildSiteVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentSite(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *O365BackupParams) contextValidateChildSiteVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ChildSiteVec); i++ {

		if m.ChildSiteVec[i] != nil {

			if swag.IsZero(m.ChildSiteVec[i]) { // not required
				return nil
			}

			if err := m.ChildSiteVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("childSiteVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("childSiteVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *O365BackupParams) contextValidateParentSite(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentSite != nil {

		if swag.IsZero(m.ParentSite) { // not required
			return nil
		}

		if err := m.ParentSite.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parentSite")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parentSite")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *O365BackupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *O365BackupParams) UnmarshalBinary(b []byte) error {
	var res O365BackupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
