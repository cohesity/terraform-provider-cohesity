// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NasEnvJobParameters NAS Environment Job Parameters.
//
// Specifies job parameters applicable for all 'kGenericNas' Environment type
// Protection Sources in a Protection Job.
//
// swagger:model NasEnvJobParameters
type NasEnvJobParameters struct {

	// Specifies if the protection job should use existing snapshot while
	// backing up.
	BackupExistingSnapshot *bool `json:"backupExistingSnapshot,omitempty"`

	// Specifies if the backup should continue on with other Protection Sources
	// even if the backup operation of some Protection Source fails. If true,
	// the Cohesity Cluster ignores the errors and continues with remaining
	// Protection Sources in the job. If false, the backup operation stops when
	// an error occurs. This does not apply to non-snapshot based generic NAS
	// backup jobs. If not set, default value is true.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Specifies additional parameters that are applicable only to the data
	// migration jobs in NAS environment.
	DataMigrationJobParameters *DataMigrationJobParameters `json:"dataMigrationJobParameters,omitempty"`

	// Specifies additional parameters that are applicable only to the data
	// uptier jobs in NAS environment.
	DataUptierJobParameters *DataUptierJobParameters `json:"dataUptierJobParameters,omitempty"`

	// Specifies whether this job will enable faster incremental backups using
	// change list or similar APIs
	EnableFasterIncrementalBackups *bool `json:"enableFasterIncrementalBackups,omitempty"`

	// Specifies if the protection job should use encryption while backing up.
	EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

	// Optional config that enables file locking for this job. It cannot be
	// disabled during the edit of a job, if it has been enabled during the
	// creation of the job. Also, it cannot be enabled if it was disabled
	// during the creation of the job.
	FileLockConfig *FileLevelDataLockConfig `json:"fileLockConfig,omitempty"`

	// Specifies filters on the backup objects like files and directories.
	// Specifying filters decide which objects within a source should be backed
	// up. If this field is not specified, then all of the objects within the
	// source will be backed up.
	FilePathFilters *FilePathFilter `json:"filePathFilters,omitempty"`

	// Specifies the list of IP addresses that are allowed or denied at the job
	// level. Allowed IPs and Denied IPs cannot be used together.
	FilterIPConfig *FilterIPConfig `json:"filterIpConfig,omitempty"`

	// Specifies the preferred protocol to use for backup. This does not
	// apply to generic NAS and will be ignored.
	// Specifies the protocol used by a NAS server.
	// 'kNoProtocol' indicates no protocol set.
	// 'kNfs3' indicates NFS v3 protocol.
	// 'kNfs4_1' indicates NFS v4.1 protocol.
	// 'kCifs1' indicates CIFS v1.0 protocol.
	// 'kCifs2' indicates CIFS v2.0 protocol.
	// 'kCifs3' indicates CIFS v3.0 protocol.
	// Enum: ["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]
	NasProtocol *string `json:"nasProtocol,omitempty"`

	// Specifies the preferred NFS protocol to use for the backup when multiple
	// NFS protocols are present on a single volume.
	// Specifies the protocol used by a NAS server.
	// 'kNoProtocol' indicates no protocol set.
	// 'kNfs3' indicates NFS v3 protocol.
	// 'kNfs4_1' indicates NFS v4.1 protocol.
	// 'kCifs1' indicates CIFS v1.0 protocol.
	// 'kCifs2' indicates CIFS v2.0 protocol.
	// 'kCifs3' indicates CIFS v3.0 protocol.
	// Enum: ["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]
	NfsVersionPreference *string `json:"nfsVersionPreference,omitempty"`

	// Specifies the incremental and full snapshot label for
	// Data-Protect Netapp Volumes backup. If field is set , incremental
	// and full snapshot label has to be provided. If field is not set, the
	// snapshot label will be automatically set using timestamp.
	SnapshotLabel *SnapshotLabel `json:"snapshotLabel,omitempty"`

	// Specifies the NAS specific source throttling parameters during full or
	// incremental backup of the source.
	ThrottlingConfig *NasSourceThrottlingParams `json:"throttlingConfig,omitempty"`
}

// Validate validates this nas env job parameters
func (m *NasEnvJobParameters) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDataMigrationJobParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataUptierJobParameters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileLockConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilePathFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilterIPConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNasProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfsVersionPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThrottlingConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasEnvJobParameters) validateDataMigrationJobParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.DataMigrationJobParameters) { // not required
		return nil
	}

	if m.DataMigrationJobParameters != nil {
		if err := m.DataMigrationJobParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataMigrationJobParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataMigrationJobParameters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) validateDataUptierJobParameters(formats strfmt.Registry) error {
	if swag.IsZero(m.DataUptierJobParameters) { // not required
		return nil
	}

	if m.DataUptierJobParameters != nil {
		if err := m.DataUptierJobParameters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataUptierJobParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataUptierJobParameters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) validateFileLockConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FileLockConfig) { // not required
		return nil
	}

	if m.FileLockConfig != nil {
		if err := m.FileLockConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) validateFilePathFilters(formats strfmt.Registry) error {
	if swag.IsZero(m.FilePathFilters) { // not required
		return nil
	}

	if m.FilePathFilters != nil {
		if err := m.FilePathFilters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filePathFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filePathFilters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) validateFilterIPConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FilterIPConfig) { // not required
		return nil
	}

	if m.FilterIPConfig != nil {
		if err := m.FilterIPConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

var nasEnvJobParametersTypeNasProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasEnvJobParametersTypeNasProtocolPropEnum = append(nasEnvJobParametersTypeNasProtocolPropEnum, v)
	}
}

const (

	// NasEnvJobParametersNasProtocolKNoProtocol captures enum value "kNoProtocol"
	NasEnvJobParametersNasProtocolKNoProtocol string = "kNoProtocol"

	// NasEnvJobParametersNasProtocolKNfs3 captures enum value "kNfs3"
	NasEnvJobParametersNasProtocolKNfs3 string = "kNfs3"

	// NasEnvJobParametersNasProtocolKNfs41 captures enum value "kNfs4_1"
	NasEnvJobParametersNasProtocolKNfs41 string = "kNfs4_1"

	// NasEnvJobParametersNasProtocolKCifs1 captures enum value "kCifs1"
	NasEnvJobParametersNasProtocolKCifs1 string = "kCifs1"

	// NasEnvJobParametersNasProtocolKCifs2 captures enum value "kCifs2"
	NasEnvJobParametersNasProtocolKCifs2 string = "kCifs2"

	// NasEnvJobParametersNasProtocolKCifs3 captures enum value "kCifs3"
	NasEnvJobParametersNasProtocolKCifs3 string = "kCifs3"
)

// prop value enum
func (m *NasEnvJobParameters) validateNasProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasEnvJobParametersTypeNasProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasEnvJobParameters) validateNasProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.NasProtocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateNasProtocolEnum("nasProtocol", "body", *m.NasProtocol); err != nil {
		return err
	}

	return nil
}

var nasEnvJobParametersTypeNfsVersionPreferencePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNoProtocol","kNfs3","kNfs4_1","kCifs1","kCifs2","kCifs3"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nasEnvJobParametersTypeNfsVersionPreferencePropEnum = append(nasEnvJobParametersTypeNfsVersionPreferencePropEnum, v)
	}
}

const (

	// NasEnvJobParametersNfsVersionPreferenceKNoProtocol captures enum value "kNoProtocol"
	NasEnvJobParametersNfsVersionPreferenceKNoProtocol string = "kNoProtocol"

	// NasEnvJobParametersNfsVersionPreferenceKNfs3 captures enum value "kNfs3"
	NasEnvJobParametersNfsVersionPreferenceKNfs3 string = "kNfs3"

	// NasEnvJobParametersNfsVersionPreferenceKNfs41 captures enum value "kNfs4_1"
	NasEnvJobParametersNfsVersionPreferenceKNfs41 string = "kNfs4_1"

	// NasEnvJobParametersNfsVersionPreferenceKCifs1 captures enum value "kCifs1"
	NasEnvJobParametersNfsVersionPreferenceKCifs1 string = "kCifs1"

	// NasEnvJobParametersNfsVersionPreferenceKCifs2 captures enum value "kCifs2"
	NasEnvJobParametersNfsVersionPreferenceKCifs2 string = "kCifs2"

	// NasEnvJobParametersNfsVersionPreferenceKCifs3 captures enum value "kCifs3"
	NasEnvJobParametersNfsVersionPreferenceKCifs3 string = "kCifs3"
)

// prop value enum
func (m *NasEnvJobParameters) validateNfsVersionPreferenceEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nasEnvJobParametersTypeNfsVersionPreferencePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NasEnvJobParameters) validateNfsVersionPreference(formats strfmt.Registry) error {
	if swag.IsZero(m.NfsVersionPreference) { // not required
		return nil
	}

	// value enum
	if err := m.validateNfsVersionPreferenceEnum("nfsVersionPreference", "body", *m.NfsVersionPreference); err != nil {
		return err
	}

	return nil
}

func (m *NasEnvJobParameters) validateSnapshotLabel(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotLabel) { // not required
		return nil
	}

	if m.SnapshotLabel != nil {
		if err := m.SnapshotLabel.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotLabel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotLabel")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) validateThrottlingConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ThrottlingConfig) { // not required
		return nil
	}

	if m.ThrottlingConfig != nil {
		if err := m.ThrottlingConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas env job parameters based on the context it is used
func (m *NasEnvJobParameters) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDataMigrationJobParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataUptierJobParameters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileLockConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilePathFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilterIPConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotLabel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThrottlingConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasEnvJobParameters) contextValidateDataMigrationJobParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.DataMigrationJobParameters != nil {

		if swag.IsZero(m.DataMigrationJobParameters) { // not required
			return nil
		}

		if err := m.DataMigrationJobParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataMigrationJobParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataMigrationJobParameters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) contextValidateDataUptierJobParameters(ctx context.Context, formats strfmt.Registry) error {

	if m.DataUptierJobParameters != nil {

		if swag.IsZero(m.DataUptierJobParameters) { // not required
			return nil
		}

		if err := m.DataUptierJobParameters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataUptierJobParameters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataUptierJobParameters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) contextValidateFileLockConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FileLockConfig != nil {

		if swag.IsZero(m.FileLockConfig) { // not required
			return nil
		}

		if err := m.FileLockConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileLockConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fileLockConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) contextValidateFilePathFilters(ctx context.Context, formats strfmt.Registry) error {

	if m.FilePathFilters != nil {

		if swag.IsZero(m.FilePathFilters) { // not required
			return nil
		}

		if err := m.FilePathFilters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filePathFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filePathFilters")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) contextValidateFilterIPConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FilterIPConfig != nil {

		if swag.IsZero(m.FilterIPConfig) { // not required
			return nil
		}

		if err := m.FilterIPConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterIpConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterIpConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) contextValidateSnapshotLabel(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotLabel != nil {

		if swag.IsZero(m.SnapshotLabel) { // not required
			return nil
		}

		if err := m.SnapshotLabel.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotLabel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotLabel")
			}
			return err
		}
	}

	return nil
}

func (m *NasEnvJobParameters) contextValidateThrottlingConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ThrottlingConfig != nil {

		if swag.IsZero(m.ThrottlingConfig) { // not required
			return nil
		}

		if err := m.ThrottlingConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasEnvJobParameters) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasEnvJobParameters) UnmarshalBinary(b []byte) error {
	var res NasEnvJobParameters
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
