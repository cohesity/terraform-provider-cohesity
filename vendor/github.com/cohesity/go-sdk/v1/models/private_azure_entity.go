// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PrivateAzureEntity private azure entity
//
// swagger:model PrivateAzureEntity
type PrivateAzureEntity struct {

	// Administrator Login of the SQL Server. This is set for entities of type
	// kSQLServer and kSQLManagedInstance.
	AdministratorLogin *string `json:"administratorLogin,omitempty"`

	// Collation of the SQL Database. This is set for entities of type
	// kSQLDatabase.
	Collation *string `json:"collation,omitempty"`

	// Information common to all types of cloud entities.
	CommonInfo *EntityCommonInfo `json:"commonInfo,omitempty"`

	// Creation date of the SQL Database. This is set for entities of type
	// kSQLDatabase.
	CreationDate *string `json:"creationDate,omitempty"`

	// Size of the resource, currently set for kSQLDatabase type entity.
	CurrentSizeBytes *int64 `json:"currentSizeBytes,omitempty"`

	// List of disks attached to the VM. Only applicable for entities of type
	// kVirtualMachine.
	DiskInfoVec []*DiskInfo `json:"diskInfoVec"`

	// FQDN of the SQL Server. This is set for entities of type
	// kSQLServer and kSQLManagedInstance.
	Fqdn *string `json:"fqdn,omitempty"`

	// Front end size information. An example use case is for billing purposes
	// in "[Backup | Data Management] as a Service" offering.
	// The total size of this entity. Currently this is only set for databases
	// and has the same value as 'current_size_bytes'.
	FrontEndSizeInfo *SizeInfo `json:"frontEndSizeInfo,omitempty"`

	// The host environment type. This is set for entities of type
	// kVirtualMachine.
	HostType *int32 `json:"hostType,omitempty"`

	// Use 'id' in 'common_info'.
	//
	// Azure specific ID for the entity. Depending on the type of the entity
	// Azure returns unix path style id. e.g.
	//
	// Id for a subscription: /subscriptions/3215d0a4-e99d-4b0c-b106-e2a7708e0024
	// Id for a resource group:
	// subscriptions/3215d0a4-e99d-4b0c-b106-e2a7708e0024/resourceGroups/tumri
	//
	// For storage container and storage key we generate the id ourself.
	//
	// storage container: <storage account>/c/<storage container>
	// storage key: <storage account>/k/<storage key>
	ID *string `json:"id,omitempty"`

	// Whether this entity is a kSQLDatabase & its parent is a
	// kSQLManagedInstance. Useful for UI to display conditional icons.
	IsManagedDb *bool `json:"isManagedDb,omitempty"`

	// Whether the VM is managed. This is set for entities of type
	// kVirtualMachine.
	IsManagedVM *bool `json:"isManagedVm,omitempty"`

	// Whether the subscription is registered as top level entity. This is set
	// for entites of type kSubscription.
	IsTopLevelEntity *bool `json:"isTopLevelEntity,omitempty"`

	// Applicable to entity of type kResourceGroup, kStorageAccount and
	// kVirtualNetwork.
	//
	// Physical location of the (resource group/storage account/virtual network/
	// virtual machine).
	Location *string `json:"location,omitempty"`

	// Applicable to entity of type kComputeOptions.
	//
	// Number of data disks supported by the vm type.
	MaxNoOfDataDisksSupported *int32 `json:"maxNoOfDataDisksSupported,omitempty"`

	// Max size bytes of the SQL Database. This is set for entities of type
	// kSQLDatabase.
	MaxSizeBytes *int64 `json:"maxSizeBytes,omitempty"`

	// Applicable to entity of type kComputeOptions.
	//
	// Amount of memory in MB available in the compute option.
	MemoryMb *int64 `json:"memoryMb,omitempty"`

	// Use 'name' in 'common_info'.
	//
	// Name for the entity. It is used to refer to the entity in the UI by us
	// as well as by Azure.
	Name *string `json:"name,omitempty"`

	// Applicable to entity of type kComputeOptions.
	//
	// Number of cores available in the compute option.
	NumCores *int32 `json:"numCores,omitempty"`

	// The private endpoint connections configured for this azure resource. We
	// will use the subnet azure IDs to select the rigel mapped to the VNET of
	// this subnet to enable backup of sql servers only accessible by private
	// endpoints.
	PrivateEndpointConnectionVec []*EntityPrivateEndpointConnection `json:"privateEndpointConnectionVec"`

	// List of ip addresses. This is set for entities of type kVirtualMachine.
	PrivateIPAddressVec []string `json:"privateIpAddressVec"`

	// Whether public network access enabled for the SQL Server. This is set for
	// entities of type kSQLServer and kSQLManagedInstance.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// SKU of the entity.
	Sku *EntitySKU `json:"sku,omitempty"`

	// State of the SQL Server. This is set for entities of type
	// kSQLServer and kSQLManagedInstance.
	State *string `json:"state,omitempty"`

	// Status of the SQL Database. This is set for entities of type
	// kSQLDatabase.
	Status *string `json:"status,omitempty"`

	// Optional list of tag attributes associated with this entity.
	TagAttributesVec []*TagAttributes `json:"tagAttributesVec"`

	// The type of entity this proto refers to.
	Type *int32 `json:"type,omitempty"`

	// Version of the SQL Server. This is set for entities of type
	// kSQLServer and kSQLManagedInstance.
	Version *string `json:"version,omitempty"`
}

// Validate validates this private azure entity
func (m *PrivateAzureEntity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommonInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDiskInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrontEndSizeInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivateEndpointConnectionVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSku(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagAttributesVec(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateAzureEntity) validateCommonInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.CommonInfo) { // not required
		return nil
	}

	if m.CommonInfo != nil {
		if err := m.CommonInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("commonInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("commonInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateAzureEntity) validateDiskInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.DiskInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.DiskInfoVec); i++ {
		if swag.IsZero(m.DiskInfoVec[i]) { // not required
			continue
		}

		if m.DiskInfoVec[i] != nil {
			if err := m.DiskInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateAzureEntity) validateFrontEndSizeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.FrontEndSizeInfo) { // not required
		return nil
	}

	if m.FrontEndSizeInfo != nil {
		if err := m.FrontEndSizeInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateAzureEntity) validatePrivateEndpointConnectionVec(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivateEndpointConnectionVec) { // not required
		return nil
	}

	for i := 0; i < len(m.PrivateEndpointConnectionVec); i++ {
		if swag.IsZero(m.PrivateEndpointConnectionVec[i]) { // not required
			continue
		}

		if m.PrivateEndpointConnectionVec[i] != nil {
			if err := m.PrivateEndpointConnectionVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("privateEndpointConnectionVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("privateEndpointConnectionVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateAzureEntity) validateSku(formats strfmt.Registry) error {
	if swag.IsZero(m.Sku) { // not required
		return nil
	}

	if m.Sku != nil {
		if err := m.Sku.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sku")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sku")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateAzureEntity) validateTagAttributesVec(formats strfmt.Registry) error {
	if swag.IsZero(m.TagAttributesVec) { // not required
		return nil
	}

	for i := 0; i < len(m.TagAttributesVec); i++ {
		if swag.IsZero(m.TagAttributesVec[i]) { // not required
			continue
		}

		if m.TagAttributesVec[i] != nil {
			if err := m.TagAttributesVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this private azure entity based on the context it is used
func (m *PrivateAzureEntity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommonInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDiskInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrontEndSizeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrivateEndpointConnectionVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSku(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTagAttributesVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateAzureEntity) contextValidateCommonInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CommonInfo != nil {

		if swag.IsZero(m.CommonInfo) { // not required
			return nil
		}

		if err := m.CommonInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("commonInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("commonInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateAzureEntity) contextValidateDiskInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DiskInfoVec); i++ {

		if m.DiskInfoVec[i] != nil {

			if swag.IsZero(m.DiskInfoVec[i]) { // not required
				return nil
			}

			if err := m.DiskInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("diskInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("diskInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateAzureEntity) contextValidateFrontEndSizeInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.FrontEndSizeInfo != nil {

		if swag.IsZero(m.FrontEndSizeInfo) { // not required
			return nil
		}

		if err := m.FrontEndSizeInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateAzureEntity) contextValidatePrivateEndpointConnectionVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PrivateEndpointConnectionVec); i++ {

		if m.PrivateEndpointConnectionVec[i] != nil {

			if swag.IsZero(m.PrivateEndpointConnectionVec[i]) { // not required
				return nil
			}

			if err := m.PrivateEndpointConnectionVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("privateEndpointConnectionVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("privateEndpointConnectionVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateAzureEntity) contextValidateSku(ctx context.Context, formats strfmt.Registry) error {

	if m.Sku != nil {

		if swag.IsZero(m.Sku) { // not required
			return nil
		}

		if err := m.Sku.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sku")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sku")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateAzureEntity) contextValidateTagAttributesVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TagAttributesVec); i++ {

		if m.TagAttributesVec[i] != nil {

			if swag.IsZero(m.TagAttributesVec[i]) { // not required
				return nil
			}

			if err := m.TagAttributesVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateAzureEntity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateAzureEntity) UnmarshalBinary(b []byte) error {
	var res PrivateAzureEntity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
