// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MonthlySchedule Monthly Schedule.
//
// Specifies a monthly backup schedule by specifying a day in the week
// and a week in the month.
// For example, if day is set to 'kMonday' and dayCount is set
// to 'kThird', a Job Run is started on the third Monday of every month.
//
// swagger:model MonthlySchedule
type MonthlySchedule struct {

	// Specifies the day of the week (such as 'kMonday') to start the Job Run.
	// Used with day count to define the day in the month to start
	// the Job Run.
	// Specifies a day in a week such as 'kSunday', 'kMonday', etc.
	// Enum: ["kSunday","kMonday","kTuesday","kWednesday","kThursday","kFriday","kSaturday"]
	Day *string `json:"day,omitempty"`

	// Specifies the day count in the month (such as 'kThird') to start
	// the Job Run.
	// Used in combination with day to define the day in the month to start
	// the Job Run.
	// Specifies the day count in the month to start the backup.
	// For example if day count is set to 'kThird' and day is set to 'kMonday',
	// a backup is performed on the third Monday of every month.
	// 'kFirst' indicates that the first week should be chosen for specified
	// day of every month.
	// 'kSecond' indicates that the second week should be chosen for specified
	// day of every month.
	// 'kThird' indicates that the third week should be chosen for specified
	// day of every month.
	// 'kFourth' indicates that the fourth week should be chosen for specified
	// day of every month.
	// 'kLast' indicates that the last week should be chosen for specified
	// day of every month.
	// Enum: ["kFirst","kSecond","kThird","kFourth","kLast"]
	DayCount *string `json:"dayCount,omitempty"`
}

// Validate validates this monthly schedule
func (m *MonthlySchedule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDayCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var monthlyScheduleTypeDayPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kSunday","kMonday","kTuesday","kWednesday","kThursday","kFriday","kSaturday"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		monthlyScheduleTypeDayPropEnum = append(monthlyScheduleTypeDayPropEnum, v)
	}
}

const (

	// MonthlyScheduleDayKSunday captures enum value "kSunday"
	MonthlyScheduleDayKSunday string = "kSunday"

	// MonthlyScheduleDayKMonday captures enum value "kMonday"
	MonthlyScheduleDayKMonday string = "kMonday"

	// MonthlyScheduleDayKTuesday captures enum value "kTuesday"
	MonthlyScheduleDayKTuesday string = "kTuesday"

	// MonthlyScheduleDayKWednesday captures enum value "kWednesday"
	MonthlyScheduleDayKWednesday string = "kWednesday"

	// MonthlyScheduleDayKThursday captures enum value "kThursday"
	MonthlyScheduleDayKThursday string = "kThursday"

	// MonthlyScheduleDayKFriday captures enum value "kFriday"
	MonthlyScheduleDayKFriday string = "kFriday"

	// MonthlyScheduleDayKSaturday captures enum value "kSaturday"
	MonthlyScheduleDayKSaturday string = "kSaturday"
)

// prop value enum
func (m *MonthlySchedule) validateDayEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, monthlyScheduleTypeDayPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MonthlySchedule) validateDay(formats strfmt.Registry) error {
	if swag.IsZero(m.Day) { // not required
		return nil
	}

	// value enum
	if err := m.validateDayEnum("day", "body", *m.Day); err != nil {
		return err
	}

	return nil
}

var monthlyScheduleTypeDayCountPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kFirst","kSecond","kThird","kFourth","kLast"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		monthlyScheduleTypeDayCountPropEnum = append(monthlyScheduleTypeDayCountPropEnum, v)
	}
}

const (

	// MonthlyScheduleDayCountKFirst captures enum value "kFirst"
	MonthlyScheduleDayCountKFirst string = "kFirst"

	// MonthlyScheduleDayCountKSecond captures enum value "kSecond"
	MonthlyScheduleDayCountKSecond string = "kSecond"

	// MonthlyScheduleDayCountKThird captures enum value "kThird"
	MonthlyScheduleDayCountKThird string = "kThird"

	// MonthlyScheduleDayCountKFourth captures enum value "kFourth"
	MonthlyScheduleDayCountKFourth string = "kFourth"

	// MonthlyScheduleDayCountKLast captures enum value "kLast"
	MonthlyScheduleDayCountKLast string = "kLast"
)

// prop value enum
func (m *MonthlySchedule) validateDayCountEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, monthlyScheduleTypeDayCountPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MonthlySchedule) validateDayCount(formats strfmt.Registry) error {
	if swag.IsZero(m.DayCount) { // not required
		return nil
	}

	// value enum
	if err := m.validateDayCountEnum("dayCount", "body", *m.DayCount); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this monthly schedule based on context it is used
func (m *MonthlySchedule) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MonthlySchedule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MonthlySchedule) UnmarshalBinary(b []byte) error {
	var res MonthlySchedule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
