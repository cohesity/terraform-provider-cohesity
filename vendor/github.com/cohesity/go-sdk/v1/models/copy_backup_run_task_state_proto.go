// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CopyBackupRunTaskStateProto This message contains persistent information about a task that copies the
// snapshots of a specific backup run to a particular target.
//
// swagger:model CopyBackupRunTaskStateProto
type CopyBackupRunTaskStateProto struct {

	// A list of active sub tasks that copy the snapshot of leaf-level entity to
	// the snapshot target.
	ActiveCopySubTasks []*CopyBackupSubTaskStateProto `json:"activeCopySubTasks"`

	// If this is an archive task, this field will contain some basic info about
	// the archive task.
	ArchivalInfo *ArchivalInfoBase `json:"archivalInfo,omitempty"`

	// The type of the backup run whose snapshots are being copied.
	BackupType *int32 `json:"backupType,omitempty"`

	// If this is a replication task, this will contain the constituent id of the
	// Bridge instance where this task has been scheduled (if the task has been
	// scheduled).
	BridgeConstituentID *int64 `json:"bridgeConstituentId,omitempty"`

	// Whether this copy task has a pending cancellation request.
	CancellationRequested *bool `json:"cancellationRequested,omitempty"`

	// If this is a vm deploy task, then this is the temporary view name where
	// the VM files will be cloned. The view would be deleted at the end of the
	// copy task. This view name holds name for both cloud vm deploy and onprem
	// vm deploy.
	CloudDeployViewName *string `json:"cloudDeployViewName,omitempty"`

	// Cohesion copy job specific params.
	CohesionCopyJobParams *CopyJobParams `json:"cohesionCopyJobParams,omitempty"`

	// Whether to allow copy of partially successful run or not. If set to false,
	// copy task is failed if the backup run does not finish successfully. Else,
	// copy task copies successful tasks.
	CopyPartiallySuccessfulRun *bool `json:"copyPartiallySuccessfulRun,omitempty"`

	// Contains information about the objects which were copied as part of the
	// copy task.
	CopyTaskObjectInfoVec []*CopyObjectBaseInfo `json:"copyTaskObjectInfoVec"`

	// The timeout duration taken from the policy(based on full/incremental
	// backup). A cancellation will automatically gets triggered if the copy
	// task has been running for more than this timeout duration(currently
	// applicable for archival).
	CopyTaskTimeoutMins *int64 `json:"copyTaskTimeoutMins,omitempty"`

	// copy task type
	CopyTaskType *int32 `json:"copyTaskType,omitempty"`

	// Data lock contraints if any applicable to this copy task. For copy tasks
	// of type kLocal, if this is set it should take precedence over the backup
	// run's setting.
	DataLockConstraints *DataLockConstraintsProto `json:"dataLockConstraints,omitempty"`

	// Whether to disable creation of MegaFiles on the Rx cluster for a
	// replication task, even if the Rx cluster supports it.
	DisableRxMegafile *bool `json:"disableRxMegafile,omitempty"`

	// If this bool is set and the sub-task is finished but the copy task is not
	// finished, while returning the response to iris display all it's sub-tasks
	// as pending.
	DisplaySubTasksStatusBasedOnParent *bool `json:"displaySubTasksStatusBasedOnParent,omitempty"`

	// The time this task finished.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// A map that specifies expiry time overrides for specific entities. The key
	// in the map is the id of an entity, and the value is the expiry time that
	// should be used for that entity.
	EntityExpiryTimeUsecsMap interface{} `json:"entityExpiryTimeUsecsMap,omitempty"`

	// A map that specifies legal hold status for specific entities. The key
	// in the map is the id of an entity, and the value is the boolean indicating
	// if the entity is on legal hold.
	EntityLegalHoldMap interface{} `json:"entityLegalHoldMap,omitempty"`

	// Will contain any error encountered by this task.
	Error *PrivateErrorProto `json:"error,omitempty"`

	// The time (in usecs) when the snapshots should be expired at the target.
	// If this field is not set, it implies that the snapshots should never be
	// expired at the target. Expiry time can be subjected to WORM retention.
	// Whether WORM property is set for a given run can always be looked up in
	// the corresponding BackupJobRunStateProto.base.
	ExpiryTimeUsecs *int64 `json:"expiryTimeUsecs,omitempty"`

	// Boolean to tell whether to fail the progress monitor if there an
	// kAlreadyExists error in creating the progress monitor for cloud spin
	// tasks.
	FailProgressMonitorOnAlreadyExistsError *bool `json:"failProgressMonitorOnAlreadyExistsError,omitempty"`

	// A list of finished sub tasks that copy the snapshot of leaf-level entity
	// to the snapshot target..
	FinishedCopySubTasks []*CopyBackupSubTaskStateProto `json:"finishedCopySubTasks"`

	// A list of granularity buckets that triggered this copy task.
	GranularityBucketVec []*GranularityBucket `json:"granularityBucketVec"`

	// Whether this is an out of band (OOB) copy task triggered by the user.
	IsOutOfBandTask *bool `json:"isOutOfBandTask,omitempty"`

	// This field indicates whether the expiry time on this proto is artificially
	// determined by the smart retention adjustment feature.
	IsSmartRetentionSet *bool `json:"isSmartRetentionSet,omitempty"`

	// The instance id of the backup run whose snapshots are to be copied.
	JobInstanceID *int64 `json:"jobInstanceId,omitempty"`

	// The globally unique id of the backup job whose snapshots are to be copied.
	JobUID *UniversalIDProto `json:"jobUid,omitempty"`

	// This is a run sequencer which will incremented whenever run reaches a new
	// milestone. A milestone can be a change in state, or attempts, progress
	// percentage incrementals (e.g. 10%), This will be used by Helios ETL to
	// identify the latest copy of the backup run.
	LastUpdateLogicalTimestamp *int64 `json:"lastUpdateLogicalTimestamp,omitempty"`

	// If legal hold is set on the run, then this run is not deletable.
	// expiry_time_usecs remain irrelevant while the run/objects are on
	// legal hold. It is possible to extend expiry_time_usecs while the
	// run is on the legal hold, but it can not be shortened.
	LegalHoldEnabled *bool `json:"legalHoldEnabled,omitempty"`

	// If specified, this task will be linked to the given copy task.
	LinkedTaskInfo *CopyBackupRunTaskStateProtoLinkedTaskInfo `json:"linkedTaskInfo,omitempty"`

	// If this is a copy to local task, this field will contain some basic info
	// about the copy to local task.
	LocalCopyInfo *LocalCopyInfoBase `json:"localCopyInfo,omitempty"`

	// Whether any metadata for this copy task has been deleted from the master's
	// state. This will only be set for copy tasks that use object level copy.
	MetadataDeleted *bool `json:"metadataDeleted,omitempty"`

	// Whether this task performs granular copy of snapshots at an object level.
	// This field can only be set for snapshot target of type 'kRemote'. If set
	// to true, this task will create and schedule child copy tasks as soon as
	// the backup of an object finishes. Else, this task is expected to wait for
	// the backup run to finish before starting the copy task.
	ObjectLevelCopy *bool `json:"objectLevelCopy,omitempty"`

	// This field will be populated when the copy task target also happens to be
	// the primary backup target, for eg. in case of CloudArchiveDirect job.
	PrimaryBackupRunStats *PrimaryBackupRunStats `json:"primaryBackupRunStats,omitempty"`

	// Full path of the Pulse task tracking the progress of this task.
	ProgressMonitorTaskPath *string `json:"progressMonitorTaskPath,omitempty"`

	// Iris-facing task state. This field is stamped during the export except for
	// archive task, i.e., this field is always stamped for archive task.
	PublicStatus *int32 `json:"publicStatus,omitempty"`

	// Specifies the time at which the latest snapshot on target was queued to
	// schedule to copy from the local snapshot.
	//
	// Note:
	// 1. Currently this is used for displaying queued time in the archival
	// page.
	// 2. This is set to backup run end time if this is part of the first copy
	// run else is copied from queued time of previous unexpired copy task.
	// If there is no previous unexpired copy task then it is set to that copy
	// run start time.
	QueuedTimestampUsecs *int64 `json:"queuedTimestampUsecs,omitempty"`

	// If this is a replication task, this field will contain some basic info
	// about the replication task.
	ReplicationInfo *ReplicationInfoBase `json:"replicationInfo,omitempty"`

	// The retention policy that should be used to determine the expiry time of
	// this copy task.
	RetentionPolicy *RetentionPolicyProto `json:"retentionPolicy,omitempty"`

	// The start time of the backup run whose snapshots are to be copied.
	RunStartTimeUsecs *int64 `json:"runStartTimeUsecs,omitempty"`

	// Set to true in case leaf level entities need to be converted to on-prem
	// format for "DR to cloud" failback use case.
	ShouldConvert *bool `json:"shouldConvert,omitempty"`

	// True if the SLA for the copy task was violated.
	SLAViolated *bool `json:"slaViolated,omitempty"`

	// The target location where the snapshots should be copied to.
	SnapshotTarget *SnapshotTarget `json:"snapshotTarget,omitempty"`

	// The time this task started.
	StartTimeUsecs *int64 `json:"startTimeUsecs,omitempty"`

	// The status of this task.
	Status *int32 `json:"status,omitempty"`

	// The globally unique id for this task.
	TaskUID *UniversalIDProto `json:"taskUid,omitempty"`

	// This boolean is used for kOnPremDeploy, kCloudSpin and kCloudReplication
	// copy tasks. All the copy tasks will have this bit set to true if they goes
	// in kScheduled state. The copy tasks which have started before the upgrade
	// will go directy from kStarted to kAccepted state.
	TaskWithScheduledState *bool `json:"taskWithScheduledState,omitempty"`

	// This field will only be populated when this proto is returned in an
	// external HTTP RPC response (e.g., for Iris). The copy task returned
	// in the external call is created by merging all the copy tasks for the
	// backup run and target. This field will contain the sum total of the
	// duration of each of the copy tasks that were merged.
	TotalDurationUsecs *int64 `json:"totalDurationUsecs,omitempty"`

	// A message displayed to the user for this job or task instance (if any).
	// Only valid if the status of the job is kFinished. This is used for
	// informing the user about a finished job or task, when there is not an
	// error.
	UserMessage *string `json:"userMessage,omitempty"`

	// Currently we are using this field for o365 view based replication, where
	// we are doing replication using view cloning, object_level_copy will be set
	// to false in this case which means instead of copying each object's
	// snapshot we will be cloning the whole view with all objects snapshots
	// present there.
	ViewLevelCopy *bool `json:"viewLevelCopy,omitempty"`

	// Whether setting max expiry time for local backup task in yoda is enabled.
	// Once this feature is enabled, maximum expiry time of all the copy tasks
	// in the run will be set to the local backup in yoda initially and then
	// once all copy tasks are completed expiry time will be reset to the
	// correct value.
	YodaMaxExpiryTimeLocalTaskEnabled *bool `json:"yodaMaxExpiryTimeLocalTaskEnabled,omitempty"`
}

// Validate validates this copy backup run task state proto
func (m *CopyBackupRunTaskStateProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActiveCopySubTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchivalInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCohesionCopyJobParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCopyTaskObjectInfoVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLockConstraints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinishedCopySubTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGranularityBucketVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinkedTaskInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalCopyInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryBackupRunStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicationInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetentionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotTarget(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CopyBackupRunTaskStateProto) validateActiveCopySubTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.ActiveCopySubTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.ActiveCopySubTasks); i++ {
		if swag.IsZero(m.ActiveCopySubTasks[i]) { // not required
			continue
		}

		if m.ActiveCopySubTasks[i] != nil {
			if err := m.ActiveCopySubTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeCopySubTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activeCopySubTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateArchivalInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchivalInfo) { // not required
		return nil
	}

	if m.ArchivalInfo != nil {
		if err := m.ArchivalInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateCohesionCopyJobParams(formats strfmt.Registry) error {
	if swag.IsZero(m.CohesionCopyJobParams) { // not required
		return nil
	}

	if m.CohesionCopyJobParams != nil {
		if err := m.CohesionCopyJobParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cohesionCopyJobParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cohesionCopyJobParams")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateCopyTaskObjectInfoVec(formats strfmt.Registry) error {
	if swag.IsZero(m.CopyTaskObjectInfoVec) { // not required
		return nil
	}

	for i := 0; i < len(m.CopyTaskObjectInfoVec); i++ {
		if swag.IsZero(m.CopyTaskObjectInfoVec[i]) { // not required
			continue
		}

		if m.CopyTaskObjectInfoVec[i] != nil {
			if err := m.CopyTaskObjectInfoVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copyTaskObjectInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copyTaskObjectInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateDataLockConstraints(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLockConstraints) { // not required
		return nil
	}

	if m.DataLockConstraints != nil {
		if err := m.DataLockConstraints.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConstraints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConstraints")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateError(formats strfmt.Registry) error {
	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateFinishedCopySubTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.FinishedCopySubTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.FinishedCopySubTasks); i++ {
		if swag.IsZero(m.FinishedCopySubTasks[i]) { // not required
			continue
		}

		if m.FinishedCopySubTasks[i] != nil {
			if err := m.FinishedCopySubTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedCopySubTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedCopySubTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateGranularityBucketVec(formats strfmt.Registry) error {
	if swag.IsZero(m.GranularityBucketVec) { // not required
		return nil
	}

	for i := 0; i < len(m.GranularityBucketVec); i++ {
		if swag.IsZero(m.GranularityBucketVec[i]) { // not required
			continue
		}

		if m.GranularityBucketVec[i] != nil {
			if err := m.GranularityBucketVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("granularityBucketVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("granularityBucketVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.JobUID) { // not required
		return nil
	}

	if m.JobUID != nil {
		if err := m.JobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateLinkedTaskInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.LinkedTaskInfo) { // not required
		return nil
	}

	if m.LinkedTaskInfo != nil {
		if err := m.LinkedTaskInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("linkedTaskInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("linkedTaskInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateLocalCopyInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.LocalCopyInfo) { // not required
		return nil
	}

	if m.LocalCopyInfo != nil {
		if err := m.LocalCopyInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localCopyInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localCopyInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validatePrimaryBackupRunStats(formats strfmt.Registry) error {
	if swag.IsZero(m.PrimaryBackupRunStats) { // not required
		return nil
	}

	if m.PrimaryBackupRunStats != nil {
		if err := m.PrimaryBackupRunStats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryBackupRunStats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("primaryBackupRunStats")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateReplicationInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicationInfo) { // not required
		return nil
	}

	if m.ReplicationInfo != nil {
		if err := m.ReplicationInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicationInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateRetentionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.RetentionPolicy) { // not required
		return nil
	}

	if m.RetentionPolicy != nil {
		if err := m.RetentionPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retentionPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retentionPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateSnapshotTarget(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotTarget) { // not required
		return nil
	}

	if m.SnapshotTarget != nil {
		if err := m.SnapshotTarget.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotTarget")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotTarget")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) validateTaskUID(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskUID) { // not required
		return nil
	}

	if m.TaskUID != nil {
		if err := m.TaskUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taskUid")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this copy backup run task state proto based on the context it is used
func (m *CopyBackupRunTaskStateProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActiveCopySubTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchivalInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCohesionCopyJobParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCopyTaskObjectInfoVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataLockConstraints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinishedCopySubTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGranularityBucketVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinkedTaskInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocalCopyInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimaryBackupRunStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicationInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetentionPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotTarget(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaskUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateActiveCopySubTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ActiveCopySubTasks); i++ {

		if m.ActiveCopySubTasks[i] != nil {

			if swag.IsZero(m.ActiveCopySubTasks[i]) { // not required
				return nil
			}

			if err := m.ActiveCopySubTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeCopySubTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activeCopySubTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateArchivalInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchivalInfo != nil {

		if swag.IsZero(m.ArchivalInfo) { // not required
			return nil
		}

		if err := m.ArchivalInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archivalInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archivalInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateCohesionCopyJobParams(ctx context.Context, formats strfmt.Registry) error {

	if m.CohesionCopyJobParams != nil {

		if swag.IsZero(m.CohesionCopyJobParams) { // not required
			return nil
		}

		if err := m.CohesionCopyJobParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cohesionCopyJobParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cohesionCopyJobParams")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateCopyTaskObjectInfoVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CopyTaskObjectInfoVec); i++ {

		if m.CopyTaskObjectInfoVec[i] != nil {

			if swag.IsZero(m.CopyTaskObjectInfoVec[i]) { // not required
				return nil
			}

			if err := m.CopyTaskObjectInfoVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copyTaskObjectInfoVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copyTaskObjectInfoVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateDataLockConstraints(ctx context.Context, formats strfmt.Registry) error {

	if m.DataLockConstraints != nil {

		if swag.IsZero(m.DataLockConstraints) { // not required
			return nil
		}

		if err := m.DataLockConstraints.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataLockConstraints")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataLockConstraints")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateError(ctx context.Context, formats strfmt.Registry) error {

	if m.Error != nil {

		if swag.IsZero(m.Error) { // not required
			return nil
		}

		if err := m.Error.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateFinishedCopySubTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FinishedCopySubTasks); i++ {

		if m.FinishedCopySubTasks[i] != nil {

			if swag.IsZero(m.FinishedCopySubTasks[i]) { // not required
				return nil
			}

			if err := m.FinishedCopySubTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedCopySubTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedCopySubTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateGranularityBucketVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GranularityBucketVec); i++ {

		if m.GranularityBucketVec[i] != nil {

			if swag.IsZero(m.GranularityBucketVec[i]) { // not required
				return nil
			}

			if err := m.GranularityBucketVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("granularityBucketVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("granularityBucketVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.JobUID != nil {

		if swag.IsZero(m.JobUID) { // not required
			return nil
		}

		if err := m.JobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateLinkedTaskInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.LinkedTaskInfo != nil {

		if swag.IsZero(m.LinkedTaskInfo) { // not required
			return nil
		}

		if err := m.LinkedTaskInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("linkedTaskInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("linkedTaskInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateLocalCopyInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.LocalCopyInfo != nil {

		if swag.IsZero(m.LocalCopyInfo) { // not required
			return nil
		}

		if err := m.LocalCopyInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("localCopyInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("localCopyInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidatePrimaryBackupRunStats(ctx context.Context, formats strfmt.Registry) error {

	if m.PrimaryBackupRunStats != nil {

		if swag.IsZero(m.PrimaryBackupRunStats) { // not required
			return nil
		}

		if err := m.PrimaryBackupRunStats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryBackupRunStats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("primaryBackupRunStats")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateReplicationInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicationInfo != nil {

		if swag.IsZero(m.ReplicationInfo) { // not required
			return nil
		}

		if err := m.ReplicationInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicationInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicationInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateRetentionPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.RetentionPolicy != nil {

		if swag.IsZero(m.RetentionPolicy) { // not required
			return nil
		}

		if err := m.RetentionPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retentionPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retentionPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateSnapshotTarget(ctx context.Context, formats strfmt.Registry) error {

	if m.SnapshotTarget != nil {

		if swag.IsZero(m.SnapshotTarget) { // not required
			return nil
		}

		if err := m.SnapshotTarget.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshotTarget")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("snapshotTarget")
			}
			return err
		}
	}

	return nil
}

func (m *CopyBackupRunTaskStateProto) contextValidateTaskUID(ctx context.Context, formats strfmt.Registry) error {

	if m.TaskUID != nil {

		if swag.IsZero(m.TaskUID) { // not required
			return nil
		}

		if err := m.TaskUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taskUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taskUid")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CopyBackupRunTaskStateProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CopyBackupRunTaskStateProto) UnmarshalBinary(b []byte) error {
	var res CopyBackupRunTaskStateProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
