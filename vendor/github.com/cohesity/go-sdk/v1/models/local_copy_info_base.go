// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// LocalCopyInfoBase local copy info base
//
// swagger:model LocalCopyInfoBase
type LocalCopyInfoBase struct {

	// In case this local copy was recreated from another remote copy, this field
	// stores the recreated copy state. E.g.: If the local copy has expired
	// magneto allows RecreateLocalCopy gRPC API to recreate the local copy by
	// restoring from some other remote copy. RecreateLocalCopy API could be used
	// by other services/clients for indexing (e.g., yoda and gaia) or for
	// browsing (e.g., azure adapter).
	//
	// Note: Even if a recreated local copy eventually expires, it can again get
	// recreated multiple times from any available unexpired remote copies of the
	// backup snapshot.
	RecreatedCopyState *LocalCopyInfoBaseRecreatedCopyState `json:"recreatedCopyState,omitempty"`

	// If the flag magneto_master_notify_yoda_task_wise is set, magneto starts
	// notifying yoda whenever a task completes. This field is used for storing
	// task ids where were already yoda notified.
	YodaNotifiedTaskIds interface{} `json:"yodaNotifiedTaskIds,omitempty"`

	// This contains the value of flag magneto_master_notify_yoda_task_wise set
	// at the beginning of this run.
	YodaObjectLevelNotifyEnabled *bool `json:"yodaObjectLevelNotifyEnabled,omitempty"`
}

// Validate validates this local copy info base
func (m *LocalCopyInfoBase) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRecreatedCopyState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCopyInfoBase) validateRecreatedCopyState(formats strfmt.Registry) error {
	if swag.IsZero(m.RecreatedCopyState) { // not required
		return nil
	}

	if m.RecreatedCopyState != nil {
		if err := m.RecreatedCopyState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recreatedCopyState")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recreatedCopyState")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this local copy info base based on the context it is used
func (m *LocalCopyInfoBase) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRecreatedCopyState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LocalCopyInfoBase) contextValidateRecreatedCopyState(ctx context.Context, formats strfmt.Registry) error {

	if m.RecreatedCopyState != nil {

		if swag.IsZero(m.RecreatedCopyState) { // not required
			return nil
		}

		if err := m.RecreatedCopyState.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recreatedCopyState")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recreatedCopyState")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LocalCopyInfoBase) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LocalCopyInfoBase) UnmarshalBinary(b []byte) error {
	var res LocalCopyInfoBase
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
