// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Alert Alert.
//
// Specifies information about an Alert such as the type, id assigned by
// the Cohesity Cluster, number of duplicates, severity, etc.
//
// swagger:model Alert
type Alert struct {

	// Specifies the category of an Alert.
	// kDisk - Alert associated with the disk.
	// kNode - Alert associated with general hardware on a specific node.
	// kCluster - Alert associated with general hardware in cluster level.
	// kChassis - Alert associated with the Chassis.
	// kPowerSupply - Alert associated with the power supply.
	// kCPU - Alert associated with the CPU usage.
	// kMemory - Alert associated with the RAM/Memory.
	// kTemperature - Alert associated with the temperature.
	// kFan - Alert associated with the fan.
	// kNIC - Alert associated with network chips and interfaces.
	// kFirmware - Alert associated with the firmware.
	// kNodeHealth - Alert associated with node health status.
	// kOperatingSystem - Alert associated with operating systems.
	// kDataPath - Alert associated with data management in the cluster.
	// kMetadata - Alert associated with metadata management.
	// kIndexing - Alert associated with indexing services.
	// kHelios - Alert associated with Helios.
	// kAppMarketPlace - Alert associated with App MarketPlace.
	// kSystemService -Alert associated with System service apps.
	// kLicense - Alert associated with licensing.
	// kSecurity - Alert associated with security.
	// kUpgrade - Alert associated with upgrade activities.
	// kClusterManagement - Alert associated with cluster management activities.
	// kAuditLog - Alert associated with audit log events.
	// kNetworking - Alert associated with networking issue.
	// kConfiguration - Alert associated with cluster or system configurations.
	// kStorageUsage - Alert associated with the disk/domain/cluster storage usage.
	// kFaultTolerance - Alert associated with the fault tolerance in different levels.
	// kBackupRestore - Alert associated with Backup-Restore job.
	// kArchivalRestore - Alert associated with Archival-Restore job.
	// kRemoteReplication - Alert associated with Replication job.
	// kQuota - Alert associated with Quotas.
	// kCDP - Alert associated with Continuous Data Protection.
	// kViewFailover - Alert associated with view Failover.
	// kDisasterRecovery - Alert associated with Disaster Recovery.
	// kStorageDevice - Alert associated with storage hardware(tape drives & libraries, Fiber HBAs used to attach devices, etc).
	// kStoragePool - Alert associated with storage pools -- logical groupings of similar kinds of storage hardware (disk, tape, etc) into which client data is stored.
	// kGeneralSoftwareFailure - Alert associated with general software failures - that don't fall into any known categories.
	// kAgent - Alert associated with agent based protection workloads.
	// Enum: ["kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature","kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kDataPath","kMetadata","kIndexing","kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade","kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage","kFaultTolerance","kBackupRestore","kArchivalRestore","kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kStorageDevice","kStoragePool","kGeneralSoftwareFailure","kAgent"]
	AlertCategory *string `json:"alertCategory,omitempty"`

	// Specifies a unique code that categorizes the Alert,
	// for example: CE00200014, where CE stands for Cohesity Error, the alert
	// state next 3 digits is the id of the Alert Category
	// (e.g. 002 for 'kNode') and the last 5 digits is the id of
	// the Alert Type (e.g. 00014 for 'kNodeHighCpuUsage').
	AlertCode *string `json:"alertCode,omitempty"`

	// Specifies documentation about the Alert such as name, description, cause
	// and how to resolve the Alert.
	AlertDocument *AlertDocument `json:"alertDocument,omitempty"`

	// Specifies the current state of the Alert.
	// kAlertNote - Alerts that are just for note.
	// kAlertOpen - Alerts that are unresolved.
	// kAlertResolved - Alerts that are already marked as resolved.
	// kAlertSuppressed - Alerts that are suppressed due to snooze settings.
	// Enum: ["kNote","kOpen","kResolved","kSuppressed"]
	AlertState *string `json:"alertState,omitempty"`

	// Specifies a 5 digit unique digital id for the Alert Type, such as 00014
	// for 'kNodeHighCpuUsage'. This id is used in alertCode.
	AlertType *int32 `json:"alertType,omitempty"`

	// Specifies the Alert type bucket.
	// Specifies the Alert type bucket.
	// kHardware - Alerts related to hardware on which Cohesity software is running.
	// kSoftware - Alerts which are related to software components.
	// kDataService - Alerts related to data services.
	// kMaintenance - Alerts relates to maintenance activities.
	// Enum: ["kHardware","kSoftware","kDataService","kMaintenance"]
	AlertTypeBucket *string `json:"alertTypeBucket,omitempty"`

	// Specifies id of the cluster where the alert was raised.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies name of the cluster where the alert was raised.
	ClusterName *string `json:"clusterName,omitempty"`

	// Specifies total count of duplicated Alerts even if there are more than
	// 25 occurrences.
	DedupCount *int32 `json:"dedupCount,omitempty"`

	// Specifies Unix epoch Timestamps (in microseconds) for the last 25
	// occurrences of duplicated Alerts that are stored with the original/primary
	// Alert. Alerts are grouped into one Alert if the Alerts
	// are the same type, are reporting on the same Object
	// and occur within one hour.
	// 'dedupCount' always reports the total count of duplicated Alerts
	// even if there are more than 25 occurrences.
	// For example, if there are 100 occurrences of this Alert,
	// dedupTimestamps stores the timestamps of the
	// last 25 occurrences and dedupCount equals 100.
	DedupTimestamps []int64 `json:"dedupTimestamps"`

	// Specifies source where the event occurred.
	EventSource *string `json:"eventSource,omitempty"`

	// Specifies Unix epoch Timestamp (in microseconds) of the first
	// occurrence of the Alert.
	FirstTimestampUsecs *int64 `json:"firstTimestampUsecs,omitempty"`

	// Specifies unique id of this Alert.
	ID *string `json:"id,omitempty"`

	// Specifies the labels for which this alert has been raised.
	LabelIds []string `json:"labelIds"`

	// Specifies Unix epoch Timestamp (in microseconds) of the most
	// recent occurrence of the Alert.
	LatestTimestampUsecs *int64 `json:"latestTimestampUsecs,omitempty"`

	// Specifies array of key-value pairs associated with the Alert.
	// The Cohesity Cluster may autogenerate properties depending on
	// the Alert type. This list includes both autogenerated and specified
	// properties.
	PropertyList []*AlertProperty `json:"propertyList"`

	// Specifies the region id of the cluster.
	RegionID *string `json:"regionId,omitempty"`

	// Specifies information about the Alert Resolution such as a summary,
	// id assigned by the Cohesity Cluster, user who resolved the Alerts, etc.
	ResolutionDetails *AlertResolutionDetails `json:"resolutionDetails,omitempty"`

	// Resolution Id String
	ResolutionIDString *string `json:"resolutionIdString,omitempty"`

	// Specifies Unix epoch Timestamps in microseconds when alert is resolved.
	ResolvedTimestampUsecs *int64 `json:"resolvedTimestampUsecs,omitempty"`

	// Specifies the severity level of an Alert.
	// kCritical - Alerts whose severity type is Critical.
	// kWarning - Alerts whose severity type is Warning.
	// kInfo - Alerts whose severity type is Info.
	// Enum: ["kCritical","kWarning","kInfo"]
	Severity *string `json:"severity,omitempty"`

	// Specifies unique id generated when the Alert is suppressed by the admin.
	SuppressionID *int64 `json:"suppressionId,omitempty"`

	// Specifies the tenants for which this alert has been raised.
	TenantIds []string `json:"tenantIds"`

	// Vaults where source object associated with alert is vaulted.
	Vaults []*AlertVaultInfo `json:"vaults"`
}

// Validate validates this alert
func (m *Alert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertDocument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertTypeBucket(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePropertyList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResolutionDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaults(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var alertTypeAlertCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature","kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kDataPath","kMetadata","kIndexing","kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade","kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage","kFaultTolerance","kBackupRestore","kArchivalRestore","kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kStorageDevice","kStoragePool","kGeneralSoftwareFailure","kAgent"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertCategoryPropEnum = append(alertTypeAlertCategoryPropEnum, v)
	}
}

const (

	// AlertAlertCategoryKDisk captures enum value "kDisk"
	AlertAlertCategoryKDisk string = "kDisk"

	// AlertAlertCategoryKNode captures enum value "kNode"
	AlertAlertCategoryKNode string = "kNode"

	// AlertAlertCategoryKCluster captures enum value "kCluster"
	AlertAlertCategoryKCluster string = "kCluster"

	// AlertAlertCategoryKChassis captures enum value "kChassis"
	AlertAlertCategoryKChassis string = "kChassis"

	// AlertAlertCategoryKPowerSupply captures enum value "kPowerSupply"
	AlertAlertCategoryKPowerSupply string = "kPowerSupply"

	// AlertAlertCategoryKCPU captures enum value "kCPU"
	AlertAlertCategoryKCPU string = "kCPU"

	// AlertAlertCategoryKMemory captures enum value "kMemory"
	AlertAlertCategoryKMemory string = "kMemory"

	// AlertAlertCategoryKTemperature captures enum value "kTemperature"
	AlertAlertCategoryKTemperature string = "kTemperature"

	// AlertAlertCategoryKFan captures enum value "kFan"
	AlertAlertCategoryKFan string = "kFan"

	// AlertAlertCategoryKNIC captures enum value "kNIC"
	AlertAlertCategoryKNIC string = "kNIC"

	// AlertAlertCategoryKFirmware captures enum value "kFirmware"
	AlertAlertCategoryKFirmware string = "kFirmware"

	// AlertAlertCategoryKNodeHealth captures enum value "kNodeHealth"
	AlertAlertCategoryKNodeHealth string = "kNodeHealth"

	// AlertAlertCategoryKOperatingSystem captures enum value "kOperatingSystem"
	AlertAlertCategoryKOperatingSystem string = "kOperatingSystem"

	// AlertAlertCategoryKDataPath captures enum value "kDataPath"
	AlertAlertCategoryKDataPath string = "kDataPath"

	// AlertAlertCategoryKMetadata captures enum value "kMetadata"
	AlertAlertCategoryKMetadata string = "kMetadata"

	// AlertAlertCategoryKIndexing captures enum value "kIndexing"
	AlertAlertCategoryKIndexing string = "kIndexing"

	// AlertAlertCategoryKHelios captures enum value "kHelios"
	AlertAlertCategoryKHelios string = "kHelios"

	// AlertAlertCategoryKAppMarketPlace captures enum value "kAppMarketPlace"
	AlertAlertCategoryKAppMarketPlace string = "kAppMarketPlace"

	// AlertAlertCategoryKSystemService captures enum value "kSystemService"
	AlertAlertCategoryKSystemService string = "kSystemService"

	// AlertAlertCategoryKLicense captures enum value "kLicense"
	AlertAlertCategoryKLicense string = "kLicense"

	// AlertAlertCategoryKSecurity captures enum value "kSecurity"
	AlertAlertCategoryKSecurity string = "kSecurity"

	// AlertAlertCategoryKUpgrade captures enum value "kUpgrade"
	AlertAlertCategoryKUpgrade string = "kUpgrade"

	// AlertAlertCategoryKClusterManagement captures enum value "kClusterManagement"
	AlertAlertCategoryKClusterManagement string = "kClusterManagement"

	// AlertAlertCategoryKAuditLog captures enum value "kAuditLog"
	AlertAlertCategoryKAuditLog string = "kAuditLog"

	// AlertAlertCategoryKNetworking captures enum value "kNetworking"
	AlertAlertCategoryKNetworking string = "kNetworking"

	// AlertAlertCategoryKConfiguration captures enum value "kConfiguration"
	AlertAlertCategoryKConfiguration string = "kConfiguration"

	// AlertAlertCategoryKStorageUsage captures enum value "kStorageUsage"
	AlertAlertCategoryKStorageUsage string = "kStorageUsage"

	// AlertAlertCategoryKFaultTolerance captures enum value "kFaultTolerance"
	AlertAlertCategoryKFaultTolerance string = "kFaultTolerance"

	// AlertAlertCategoryKBackupRestore captures enum value "kBackupRestore"
	AlertAlertCategoryKBackupRestore string = "kBackupRestore"

	// AlertAlertCategoryKArchivalRestore captures enum value "kArchivalRestore"
	AlertAlertCategoryKArchivalRestore string = "kArchivalRestore"

	// AlertAlertCategoryKRemoteReplication captures enum value "kRemoteReplication"
	AlertAlertCategoryKRemoteReplication string = "kRemoteReplication"

	// AlertAlertCategoryKQuota captures enum value "kQuota"
	AlertAlertCategoryKQuota string = "kQuota"

	// AlertAlertCategoryKCDP captures enum value "kCDP"
	AlertAlertCategoryKCDP string = "kCDP"

	// AlertAlertCategoryKViewFailover captures enum value "kViewFailover"
	AlertAlertCategoryKViewFailover string = "kViewFailover"

	// AlertAlertCategoryKDisasterRecovery captures enum value "kDisasterRecovery"
	AlertAlertCategoryKDisasterRecovery string = "kDisasterRecovery"

	// AlertAlertCategoryKStorageDevice captures enum value "kStorageDevice"
	AlertAlertCategoryKStorageDevice string = "kStorageDevice"

	// AlertAlertCategoryKStoragePool captures enum value "kStoragePool"
	AlertAlertCategoryKStoragePool string = "kStoragePool"

	// AlertAlertCategoryKGeneralSoftwareFailure captures enum value "kGeneralSoftwareFailure"
	AlertAlertCategoryKGeneralSoftwareFailure string = "kGeneralSoftwareFailure"

	// AlertAlertCategoryKAgent captures enum value "kAgent"
	AlertAlertCategoryKAgent string = "kAgent"
)

// prop value enum
func (m *Alert) validateAlertCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertCategoryEnum("alertCategory", "body", *m.AlertCategory); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateAlertDocument(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertDocument) { // not required
		return nil
	}

	if m.AlertDocument != nil {
		if err := m.AlertDocument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertDocument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertDocument")
			}
			return err
		}
	}

	return nil
}

var alertTypeAlertStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNote","kOpen","kResolved","kSuppressed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertStatePropEnum = append(alertTypeAlertStatePropEnum, v)
	}
}

const (

	// AlertAlertStateKNote captures enum value "kNote"
	AlertAlertStateKNote string = "kNote"

	// AlertAlertStateKOpen captures enum value "kOpen"
	AlertAlertStateKOpen string = "kOpen"

	// AlertAlertStateKResolved captures enum value "kResolved"
	AlertAlertStateKResolved string = "kResolved"

	// AlertAlertStateKSuppressed captures enum value "kSuppressed"
	AlertAlertStateKSuppressed string = "kSuppressed"
)

// prop value enum
func (m *Alert) validateAlertStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertState(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertStateEnum("alertState", "body", *m.AlertState); err != nil {
		return err
	}

	return nil
}

var alertTypeAlertTypeBucketPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kHardware","kSoftware","kDataService","kMaintenance"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertTypeBucketPropEnum = append(alertTypeAlertTypeBucketPropEnum, v)
	}
}

const (

	// AlertAlertTypeBucketKHardware captures enum value "kHardware"
	AlertAlertTypeBucketKHardware string = "kHardware"

	// AlertAlertTypeBucketKSoftware captures enum value "kSoftware"
	AlertAlertTypeBucketKSoftware string = "kSoftware"

	// AlertAlertTypeBucketKDataService captures enum value "kDataService"
	AlertAlertTypeBucketKDataService string = "kDataService"

	// AlertAlertTypeBucketKMaintenance captures enum value "kMaintenance"
	AlertAlertTypeBucketKMaintenance string = "kMaintenance"
)

// prop value enum
func (m *Alert) validateAlertTypeBucketEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertTypeBucketPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertTypeBucket(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertTypeBucket) { // not required
		return nil
	}

	// value enum
	if err := m.validateAlertTypeBucketEnum("alertTypeBucket", "body", *m.AlertTypeBucket); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validatePropertyList(formats strfmt.Registry) error {
	if swag.IsZero(m.PropertyList) { // not required
		return nil
	}

	for i := 0; i < len(m.PropertyList); i++ {
		if swag.IsZero(m.PropertyList[i]) { // not required
			continue
		}

		if m.PropertyList[i] != nil {
			if err := m.PropertyList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("propertyList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("propertyList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) validateResolutionDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.ResolutionDetails) { // not required
		return nil
	}

	if m.ResolutionDetails != nil {
		if err := m.ResolutionDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resolutionDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resolutionDetails")
			}
			return err
		}
	}

	return nil
}

var alertTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kCritical","kWarning","kInfo"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeSeverityPropEnum = append(alertTypeSeverityPropEnum, v)
	}
}

const (

	// AlertSeverityKCritical captures enum value "kCritical"
	AlertSeverityKCritical string = "kCritical"

	// AlertSeverityKWarning captures enum value "kWarning"
	AlertSeverityKWarning string = "kWarning"

	// AlertSeverityKInfo captures enum value "kInfo"
	AlertSeverityKInfo string = "kInfo"
)

// prop value enum
func (m *Alert) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateSeverity(formats strfmt.Registry) error {
	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", *m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateVaults(formats strfmt.Registry) error {
	if swag.IsZero(m.Vaults) { // not required
		return nil
	}

	for i := 0; i < len(m.Vaults); i++ {
		if swag.IsZero(m.Vaults[i]) { // not required
			continue
		}

		if m.Vaults[i] != nil {
			if err := m.Vaults[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vaults" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vaults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this alert based on the context it is used
func (m *Alert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAlertDocument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePropertyList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResolutionDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVaults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) contextValidateAlertDocument(ctx context.Context, formats strfmt.Registry) error {

	if m.AlertDocument != nil {

		if swag.IsZero(m.AlertDocument) { // not required
			return nil
		}

		if err := m.AlertDocument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertDocument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertDocument")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidatePropertyList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PropertyList); i++ {

		if m.PropertyList[i] != nil {

			if swag.IsZero(m.PropertyList[i]) { // not required
				return nil
			}

			if err := m.PropertyList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("propertyList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("propertyList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Alert) contextValidateResolutionDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.ResolutionDetails != nil {

		if swag.IsZero(m.ResolutionDetails) { // not required
			return nil
		}

		if err := m.ResolutionDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resolutionDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resolutionDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Alert) contextValidateVaults(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vaults); i++ {

		if m.Vaults[i] != nil {

			if swag.IsZero(m.Vaults[i]) { // not required
				return nil
			}

			if err := m.Vaults[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vaults" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vaults" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Alert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Alert) UnmarshalBinary(b []byte) error {
	var res Alert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
