// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PrivateVmwareEntity private vmware entity
//
// swagger:model PrivateVmwareEntity
type PrivateVmwareEntity struct {

	// This field may only be set if 'uses_persistent_agent' is true.
	// It contains the entity id of the registered persistent agent that is
	// running on this VM (the entity type must be kVirtualMachine).
	//
	// If this is not set, and 'uses_persistent_agent' is true, it implies that
	// an unregistered agent is running on this VM.
	AgentEntityID *int64 `json:"agentEntityId,omitempty"`

	// Information about the Agents associated with this VM (see agent.proto
	// for details). This is only set if 'uses_persistent_agent' above is set to
	// true. As of now, there is only one agent associated with a VM. However,
	// this field has been made repeated for compatibility with physical entity
	// and for future support of clustering where we will need to associate
	// mutiple agents with a VM.
	AgentStatusVec []*HostAgentStatus `json:"agentStatusVec"`

	// Represents aggregate used disk space from all the disks in the VM.
	// This information is retrieved only when VMware Tools is running on the VM.
	// If VMware Tools is not running then this will not be set.
	AggregateGuestDiskSpaceUsed *int64 `json:"aggregateGuestDiskSpaceUsed,omitempty"`

	// The API version of the VMware environment. This is currently populated
	// only for entity of type kVCenter.
	APIVersion *string `json:"apiVersion,omitempty"`

	// The connection state of the entity (only if it is of type kHostSystem or
	// kVirtualMachine).
	ConnectionState *int32 `json:"connectionState,omitempty"`

	// Optional list of custom attributes associated with this entity.
	CustomAttributesVec []*CustomAttribute `json:"customAttributesVec"`

	// This will be populated for kHostSystem if it's IP address is present in
	// the subnet provided by user.
	DataTransferIP *string `json:"dataTransferIp,omitempty"`

	// This is populated for entities of type kDatastore.
	DatastoreInfo *PrivateDatastoreInfo `json:"datastoreInfo,omitempty"`

	// This will be populated for kVirtualMachine.
	EsxiHostName *string `json:"esxiHostName,omitempty"`

	// This represents the state of IOFilter on ESX host and cluster compute
	// resource.
	FilterState *IOFilterState `json:"filterState,omitempty"`

	// This is set for entity of type kFolder.
	FolderType *int32 `json:"folderType,omitempty"`

	// Front end size information. An example use case is for billing purposes
	// in "[Backup | Data Management] as a Service" offering.
	FrontEndSizeInfo *SizeInfo `json:"frontEndSizeInfo,omitempty"`

	// VM's guest OS name. e.g., "Microsoft Windows Server 2012 (64-bit)".
	// It is the OS name user specified on VMware, not the actual OS name.
	GuestFullName *string `json:"guestFullName,omitempty"`

	// The host environment type. This is set for entities of type
	// kVirtualMachine.
	HostType *int32 `json:"hostType,omitempty"`

	// This field indicates the path to the entity in vSphere hierarchy. This is
	// curently populated only for Datacenter entities.
	InventoryPath *string `json:"inventoryPath,omitempty"`

	// This field can be used to capture IP Addresses for entities that have it.
	// The table below captures the type if information published by an entity
	// type using this field.
	//
	// Entity Type      |  IP Address Details
	//
	// kHostSystem      |  VMKernel Adapter IP Addresses
	IPAddrVec []string `json:"ipAddrVec"`

	// This will be set only for entities of type kVirtualMachine. The field
	// indicates whether the VM is a Rigel/HyX VM.
	IsSaasConnector *bool `json:"isSaasConnector,omitempty"`

	// If VM is a template, this field is set.
	IsVMTemplate *bool `json:"isVmTemplate,omitempty"`

	// This is set for the vCenter entity.
	IsVmcEnv *bool `json:"isVmcEnv,omitempty"`

	// Time in usecs when the tag hierarchy was last refreshed.
	// This is applicable only for parent entity.
	LastTagRefreshUsecs *int64 `json:"lastTagRefreshUsecs,omitempty"`

	// The logical size of Virtual Machine in bytes. It is calculated by adding
	// logical size of virtual disks attached to the VM.
	LogicalSizeInBytes *int64 `json:"logicalSizeInBytes,omitempty"`

	// The managed object reference to the object (w.r.t vCenter).
	Moref *MORef `json:"moref,omitempty"`

	// A human readable name for the object.
	Name *string `json:"name,omitempty"`

	// This will be populated for kVirtualDatacenter.
	OrgVdcNetworkVec []*OrgVDCNetwork `json:"orgVdcNetworkVec"`

	// This is set for virtual machines in environment kVCloudDirector. It
	// contains its parent VirtualApp's uuid.
	ParentVappUUID *string `json:"parentVappUuid,omitempty"`

	// This is set for vDCs in environment kVCloudDirector. It contains the
	// parent vcenter's uuid.
	ParentVcenterUUID *string `json:"parentVcenterUuid,omitempty"`

	// This will be populated for kVirtualDatacenter.
	StorageProfileVec []*StorageProfile `json:"storageProfileVec"`

	// System resource information about the VM.
	SystemResourceInfo *SystemResourceInfo `json:"systemResourceInfo,omitempty"`

	// Optional list of tag attributes associated with this entity.
	TagAttributesVec []*TagAttributes `json:"tagAttributesVec"`

	// The type of entity this proto refers to.
	Type *int32 `json:"type,omitempty"`

	// Whether to use BIOS UUID for generating VM entity ID. This is only set for
	// entities of type kVirtualMachine.
	UseVMBiosUUID *bool `json:"useVmBiosUuid,omitempty"`

	// Set to true if a persistent agent is running on this VM (the entity type
	// must be kVirtualMachine).
	// If this is set, the agent based backup and restore workflows (such as SQL)
	// will not install/uninstall the agent dynamically.
	UsesPersistentAgent *bool `json:"usesPersistentAgent,omitempty"`

	// The instance UUID of the object.
	// TODO(mark): Fill in more details to locate the object, when the moref is
	// not enough to locate it (e.g, when it becomes invalidated).
	UUID *string `json:"uuid,omitempty"`

	// This is set for certain objects of vCloud director like virtual machines
	// to capture additional vcloud director related attributes.
	VcdAttributes *VCDAttributes `json:"vcdAttributes,omitempty"`

	// This will be populated for kOrganization.
	VcdCatalogVec []*VCDCatalog `json:"vcdCatalogVec"`

	// Static vCenter Id.
	// Note: Applicable only to enironment of type kvCloudDirector. It is
	// needed to be able to distinguish entities across different vCenters
	// registered under the same vCloudDirector. This is because any 2 entities
	// across the vCenters can potentially have the same attributes, resulting
	// in the EntityHash to the same, as parent for both of them would be the
	// vCloudDirector. This field helps distinguish those entities.
	VcenterStaticID *int64 `json:"vcenterStaticId,omitempty"`

	// This is set for vCenter, Host and VM.
	//
	// For vCenter, it shows the software version
	// e.g., "VMware vCenter Server 6.5.0 build-5178943"
	//
	// For Host, it shows the software version
	// e.g., "6.0.0"
	//
	// For VM, it shows the hardware version.
	// e.g., "vmx-10"
	Version *string `json:"version,omitempty"`

	// List of virtual disk info maintained as part of the Virtual Machine HW
	// config. It will be populated only for an entity of type kVirtualMachine.
	VirtualDiskInfo []*PrivateVirtualDiskInfo `json:"virtualDiskInfo"`

	// This is set for virtual machines if we are tracking VM's by it's BIOS UUID
	// instead of instance UUID.
	// NOTE: vCenter doesn't guarantee uniqueness of this Id. It is expected that
	// when we query the entity hierarchy all the VMs with conflicting ids are
	// filtered out and none of them are surfaced up.
	VMBiosUUID *string `json:"vmBiosUuid,omitempty"`

	// This is set for virtual machines even if we are not tracking VM's by its
	// BIOS UUID.
	// Keeping two separate fields to not complicate the entity hash generation
	// code and reduce error scenarios.
	// If populated value of this field is same as vm_bios_uuid.
	VMBiosUUIDSecondary *string `json:"vmBiosUuidSecondary,omitempty"`

	// This is only set for entities of type kVirtualMachine.
	// This stores the source VCenter and VM info, if the VM was migrated from
	// another vCenter.
	VMLinkingInfo *VMLinkingInfo `json:"vmLinkingInfo,omitempty"`

	// The public cloud provider where VMC is hosted. This will be set for only
	// vmc environment.
	VmwareCloudProvider *int32 `json:"vmwareCloudProvider,omitempty"`

	// Map storing custom key against its custom attributes information for a
	// vCenter.
	VmwareCustomAttributesMap interface{} `json:"vmwareCustomAttributesMap,omitempty"`

	// The status of VMware tools on the guest (only if it is of type
	// kVirtualMachine).
	VmwareToolsStatus *int32 `json:"vmwareToolsStatus,omitempty"`
}

// Validate validates this private vmware entity
func (m *PrivateVmwareEntity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgentStatusVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomAttributesVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatastoreInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilterState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrontEndSizeInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMoref(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrgVdcNetworkVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageProfileVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSystemResourceInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagAttributesVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcdAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcdCatalogVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVirtualDiskInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMLinkingInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateVmwareEntity) validateAgentStatusVec(formats strfmt.Registry) error {
	if swag.IsZero(m.AgentStatusVec) { // not required
		return nil
	}

	for i := 0; i < len(m.AgentStatusVec); i++ {
		if swag.IsZero(m.AgentStatusVec[i]) { // not required
			continue
		}

		if m.AgentStatusVec[i] != nil {
			if err := m.AgentStatusVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agentStatusVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agentStatusVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateCustomAttributesVec(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomAttributesVec) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomAttributesVec); i++ {
		if swag.IsZero(m.CustomAttributesVec[i]) { // not required
			continue
		}

		if m.CustomAttributesVec[i] != nil {
			if err := m.CustomAttributesVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customAttributesVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("customAttributesVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateDatastoreInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.DatastoreInfo) { // not required
		return nil
	}

	if m.DatastoreInfo != nil {
		if err := m.DatastoreInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("datastoreInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("datastoreInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) validateFilterState(formats strfmt.Registry) error {
	if swag.IsZero(m.FilterState) { // not required
		return nil
	}

	if m.FilterState != nil {
		if err := m.FilterState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterState")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterState")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) validateFrontEndSizeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.FrontEndSizeInfo) { // not required
		return nil
	}

	if m.FrontEndSizeInfo != nil {
		if err := m.FrontEndSizeInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) validateMoref(formats strfmt.Registry) error {
	if swag.IsZero(m.Moref) { // not required
		return nil
	}

	if m.Moref != nil {
		if err := m.Moref.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("moref")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("moref")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) validateOrgVdcNetworkVec(formats strfmt.Registry) error {
	if swag.IsZero(m.OrgVdcNetworkVec) { // not required
		return nil
	}

	for i := 0; i < len(m.OrgVdcNetworkVec); i++ {
		if swag.IsZero(m.OrgVdcNetworkVec[i]) { // not required
			continue
		}

		if m.OrgVdcNetworkVec[i] != nil {
			if err := m.OrgVdcNetworkVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orgVdcNetworkVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("orgVdcNetworkVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateStorageProfileVec(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageProfileVec) { // not required
		return nil
	}

	for i := 0; i < len(m.StorageProfileVec); i++ {
		if swag.IsZero(m.StorageProfileVec[i]) { // not required
			continue
		}

		if m.StorageProfileVec[i] != nil {
			if err := m.StorageProfileVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("storageProfileVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("storageProfileVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateSystemResourceInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.SystemResourceInfo) { // not required
		return nil
	}

	if m.SystemResourceInfo != nil {
		if err := m.SystemResourceInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("systemResourceInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("systemResourceInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) validateTagAttributesVec(formats strfmt.Registry) error {
	if swag.IsZero(m.TagAttributesVec) { // not required
		return nil
	}

	for i := 0; i < len(m.TagAttributesVec); i++ {
		if swag.IsZero(m.TagAttributesVec[i]) { // not required
			continue
		}

		if m.TagAttributesVec[i] != nil {
			if err := m.TagAttributesVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateVcdAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.VcdAttributes) { // not required
		return nil
	}

	if m.VcdAttributes != nil {
		if err := m.VcdAttributes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcdAttributes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vcdAttributes")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) validateVcdCatalogVec(formats strfmt.Registry) error {
	if swag.IsZero(m.VcdCatalogVec) { // not required
		return nil
	}

	for i := 0; i < len(m.VcdCatalogVec); i++ {
		if swag.IsZero(m.VcdCatalogVec[i]) { // not required
			continue
		}

		if m.VcdCatalogVec[i] != nil {
			if err := m.VcdCatalogVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vcdCatalogVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vcdCatalogVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateVirtualDiskInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VirtualDiskInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.VirtualDiskInfo); i++ {
		if swag.IsZero(m.VirtualDiskInfo[i]) { // not required
			continue
		}

		if m.VirtualDiskInfo[i] != nil {
			if err := m.VirtualDiskInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("virtualDiskInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("virtualDiskInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) validateVMLinkingInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VMLinkingInfo) { // not required
		return nil
	}

	if m.VMLinkingInfo != nil {
		if err := m.VMLinkingInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vmLinkingInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vmLinkingInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this private vmware entity based on the context it is used
func (m *PrivateVmwareEntity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAgentStatusVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomAttributesVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatastoreInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilterState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFrontEndSizeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMoref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrgVdcNetworkVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageProfileVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSystemResourceInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTagAttributesVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVcdAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVcdCatalogVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVirtualDiskInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMLinkingInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateVmwareEntity) contextValidateAgentStatusVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AgentStatusVec); i++ {

		if m.AgentStatusVec[i] != nil {

			if swag.IsZero(m.AgentStatusVec[i]) { // not required
				return nil
			}

			if err := m.AgentStatusVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agentStatusVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agentStatusVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateCustomAttributesVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CustomAttributesVec); i++ {

		if m.CustomAttributesVec[i] != nil {

			if swag.IsZero(m.CustomAttributesVec[i]) { // not required
				return nil
			}

			if err := m.CustomAttributesVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customAttributesVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("customAttributesVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateDatastoreInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.DatastoreInfo != nil {

		if swag.IsZero(m.DatastoreInfo) { // not required
			return nil
		}

		if err := m.DatastoreInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("datastoreInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("datastoreInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateFilterState(ctx context.Context, formats strfmt.Registry) error {

	if m.FilterState != nil {

		if swag.IsZero(m.FilterState) { // not required
			return nil
		}

		if err := m.FilterState.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filterState")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filterState")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateFrontEndSizeInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.FrontEndSizeInfo != nil {

		if swag.IsZero(m.FrontEndSizeInfo) { // not required
			return nil
		}

		if err := m.FrontEndSizeInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("frontEndSizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("frontEndSizeInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateMoref(ctx context.Context, formats strfmt.Registry) error {

	if m.Moref != nil {

		if swag.IsZero(m.Moref) { // not required
			return nil
		}

		if err := m.Moref.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("moref")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("moref")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateOrgVdcNetworkVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OrgVdcNetworkVec); i++ {

		if m.OrgVdcNetworkVec[i] != nil {

			if swag.IsZero(m.OrgVdcNetworkVec[i]) { // not required
				return nil
			}

			if err := m.OrgVdcNetworkVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orgVdcNetworkVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("orgVdcNetworkVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateStorageProfileVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StorageProfileVec); i++ {

		if m.StorageProfileVec[i] != nil {

			if swag.IsZero(m.StorageProfileVec[i]) { // not required
				return nil
			}

			if err := m.StorageProfileVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("storageProfileVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("storageProfileVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateSystemResourceInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.SystemResourceInfo != nil {

		if swag.IsZero(m.SystemResourceInfo) { // not required
			return nil
		}

		if err := m.SystemResourceInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("systemResourceInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("systemResourceInfo")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateTagAttributesVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TagAttributesVec); i++ {

		if m.TagAttributesVec[i] != nil {

			if swag.IsZero(m.TagAttributesVec[i]) { // not required
				return nil
			}

			if err := m.TagAttributesVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributesVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateVcdAttributes(ctx context.Context, formats strfmt.Registry) error {

	if m.VcdAttributes != nil {

		if swag.IsZero(m.VcdAttributes) { // not required
			return nil
		}

		if err := m.VcdAttributes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcdAttributes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vcdAttributes")
			}
			return err
		}
	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateVcdCatalogVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VcdCatalogVec); i++ {

		if m.VcdCatalogVec[i] != nil {

			if swag.IsZero(m.VcdCatalogVec[i]) { // not required
				return nil
			}

			if err := m.VcdCatalogVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vcdCatalogVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vcdCatalogVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateVirtualDiskInfo(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VirtualDiskInfo); i++ {

		if m.VirtualDiskInfo[i] != nil {

			if swag.IsZero(m.VirtualDiskInfo[i]) { // not required
				return nil
			}

			if err := m.VirtualDiskInfo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("virtualDiskInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("virtualDiskInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PrivateVmwareEntity) contextValidateVMLinkingInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.VMLinkingInfo != nil {

		if swag.IsZero(m.VMLinkingInfo) { // not required
			return nil
		}

		if err := m.VMLinkingInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vmLinkingInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vmLinkingInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateVmwareEntity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateVmwareEntity) UnmarshalBinary(b []byte) error {
	var res PrivateVmwareEntity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
