// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RegisterRemoteCluster Register Remote Cluster.
//
// Specifies the settings required for registering a remote Cluster
// on this local Cluster.
//
// swagger:model RegisterRemoteCluster
type RegisterRemoteCluster struct {

	// Specifies whether any endpoint (such as a Node) on the remote Cluster
	// is reachable from this local Cluster.
	// If true, a service running on the local Cluster can communicate
	// directly with any of its peers running on the remote Cluster, without
	// using a proxy.
	AllEndpointsReachable *bool `json:"allEndpointsReachable,omitempty"`

	// Specifies whether the remote cluster needs to be kept in sync.
	// This will be set to true by default.
	AutoRegisterTarget *bool `json:"autoRegisterTarget,omitempty"`

	// Specifies whether the remote registration has happened automatically
	// (due to registration on the other site).
	// Can't think of other states (other than manually & automatically) so this
	// isn't an enum.
	// For a manual registration, this field will not be set.
	AutoRegistration *bool `json:"autoRegistration,omitempty"`

	// Bandwidth Limit.
	//
	// Specifies settings for limiting the data transfer rate between
	// the local and remote Clusters.
	BandwidthLimit *BandwidthLimit `json:"bandwidthLimit,omitempty"`

	// Specifies the unique id of the remote Cluster.
	ClusterID *int64 `json:"clusterId,omitempty"`

	// Specifies the unique incarnation id of the remote Cluster. This
	// id is determined dynamically by contacting the remote Cluster.
	ClusterIncarnationID *int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies whether to compress the outbound data when
	// transferring the replication data over the network to the remote Cluster.
	CompressionEnabled *bool `json:"compressionEnabled,omitempty"`

	// Specifies any additional information if needed.
	Description *string `json:"description,omitempty"`

	// Specifies the encryption key used for encrypting the replication data
	// from a local Cluster to a remote Cluster.
	// If a key is not specified, replication traffic encryption is disabled.
	// When Snapshots are replicated from a local Cluster to a remote Cluster,
	// the encryption key specified on the local Cluster must be the same
	// as the key specified on the remote Cluster.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// Specifies the name of the remote cluster. This field is determined
	// dynamically by contacting the remote cluster.
	Name *string `json:"name,omitempty"`

	// Specifies the name of the network interfaces to use for communicating with
	// the remote Cluster.
	NetworkInterface *string `json:"networkInterface,omitempty"`

	// Specifies the password for Cohesity user to use when
	// connecting to the remote Cluster.
	Password *string `json:"password,omitempty"`

	// Whether the remote cluster will be used for remote access for SPOG.
	PurposeRemoteAccess *bool `json:"purposeRemoteAccess,omitempty"`

	// Whether the remote cluster will be used for replication.
	PurposeReplication *bool `json:"purposeReplication,omitempty"`

	// Optional field for the user credentials to connect to Iris for remote
	// access for SPOG. If this is not specified, then credentials specified
	// for replication set up will be used for remote access for SPOG.
	// Allowing a different user credentials to be set up for SPOG permits
	// having different roles for remote access for SPOG and replication set
	// up.
	RemoteAccessCredentials *AccessTokenCredential `json:"remoteAccessCredentials,omitempty"`

	// Array of Remote Node IP Addresses.
	//
	// Specifies the IP addresses of the Nodes on the remote Cluster to
	// connect with. These IP addresses can also be VIPS.
	// Specifying hostnames is not supported.
	RemoteIps []string `json:"remoteIps"`

	// Array of Ports.
	//
	// Specifies the ports to use when connecting to the Nodes of the
	// remote Cluster.
	RemoteIrisPorts []int64 `json:"remoteIrisPorts"`

	// Specifies whether the Rx regiseter the Tx.
	ReverseRegisted *bool `json:"reverseRegisted,omitempty"`

	// Specifies if the TLS is enabled on the remote cluster.
	TLSEnabled *bool `json:"tlsEnabled,omitempty"`

	// Specifies the Cohesity user name used to connect to the
	// remote Cluster.
	UserName *string `json:"userName,omitempty"`

	// Whether to only validate the credentials without saving the information.
	ValidateOnly *bool `json:"validateOnly,omitempty"`

	// Array of Storage Domain (View Box) Pairs.
	//
	// Specifies pairings between Storage Domains (View Boxes) on the local Cluster
	// with Storage Domains (View Boxes) on a remote Cluster that are used in
	// replication.
	ViewBoxPairInfo []*ViewBoxPairInfo `json:"viewBoxPairInfo"`
}

// Validate validates this register remote cluster
func (m *RegisterRemoteCluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBandwidthLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteAccessCredentials(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewBoxPairInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RegisterRemoteCluster) validateBandwidthLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.BandwidthLimit) { // not required
		return nil
	}

	if m.BandwidthLimit != nil {
		if err := m.BandwidthLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidthLimit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bandwidthLimit")
			}
			return err
		}
	}

	return nil
}

func (m *RegisterRemoteCluster) validateRemoteAccessCredentials(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteAccessCredentials) { // not required
		return nil
	}

	if m.RemoteAccessCredentials != nil {
		if err := m.RemoteAccessCredentials.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteAccessCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteAccessCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *RegisterRemoteCluster) validateViewBoxPairInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ViewBoxPairInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.ViewBoxPairInfo); i++ {
		if swag.IsZero(m.ViewBoxPairInfo[i]) { // not required
			continue
		}

		if m.ViewBoxPairInfo[i] != nil {
			if err := m.ViewBoxPairInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("viewBoxPairInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("viewBoxPairInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this register remote cluster based on the context it is used
func (m *RegisterRemoteCluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBandwidthLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteAccessCredentials(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViewBoxPairInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RegisterRemoteCluster) contextValidateBandwidthLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.BandwidthLimit != nil {

		if swag.IsZero(m.BandwidthLimit) { // not required
			return nil
		}

		if err := m.BandwidthLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidthLimit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bandwidthLimit")
			}
			return err
		}
	}

	return nil
}

func (m *RegisterRemoteCluster) contextValidateRemoteAccessCredentials(ctx context.Context, formats strfmt.Registry) error {

	if m.RemoteAccessCredentials != nil {

		if swag.IsZero(m.RemoteAccessCredentials) { // not required
			return nil
		}

		if err := m.RemoteAccessCredentials.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteAccessCredentials")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteAccessCredentials")
			}
			return err
		}
	}

	return nil
}

func (m *RegisterRemoteCluster) contextValidateViewBoxPairInfo(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ViewBoxPairInfo); i++ {

		if m.ViewBoxPairInfo[i] != nil {

			if swag.IsZero(m.ViewBoxPairInfo[i]) { // not required
				return nil
			}

			if err := m.ViewBoxPairInfo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("viewBoxPairInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("viewBoxPairInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *RegisterRemoteCluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RegisterRemoteCluster) UnmarshalBinary(b []byte) error {
	var res RegisterRemoteCluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
