// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CreateBackupJobArg CreateBackupJobArg is the struct for parameters for creating a backup job.
//
// swagger:model CreateBackupJobArg
type CreateBackupJobArg struct {

	// BackupJobWrapper is the struct for the backup job.
	BackupJob *BackupJobWrapper `json:"backupJob,omitempty"`

	// Entities to be protected with the given RPO policy id. Either
	// 'job_description' or this field should be populated for CreateBackupJob
	// request.
	EntitiesToProtect *CreateBackupJobArgEntitiesToProtect `json:"entitiesToProtect,omitempty"`

	// RunOnceImmediately determines if job will be scheduled once (as a one-off
	// run) as soon as possible. All job admission constraints will be honored.
	RunOnceImmediately *bool `json:"runOnceImmediately,omitempty"`
}

// Validate validates this create backup job arg
func (m *CreateBackupJobArg) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackupJob(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntitiesToProtect(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateBackupJobArg) validateBackupJob(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupJob) { // not required
		return nil
	}

	if m.BackupJob != nil {
		if err := m.BackupJob.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupJob")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupJob")
			}
			return err
		}
	}

	return nil
}

func (m *CreateBackupJobArg) validateEntitiesToProtect(formats strfmt.Registry) error {
	if swag.IsZero(m.EntitiesToProtect) { // not required
		return nil
	}

	if m.EntitiesToProtect != nil {
		if err := m.EntitiesToProtect.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entitiesToProtect")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entitiesToProtect")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create backup job arg based on the context it is used
func (m *CreateBackupJobArg) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBackupJob(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntitiesToProtect(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateBackupJobArg) contextValidateBackupJob(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupJob != nil {

		if swag.IsZero(m.BackupJob) { // not required
			return nil
		}

		if err := m.BackupJob.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupJob")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupJob")
			}
			return err
		}
	}

	return nil
}

func (m *CreateBackupJobArg) contextValidateEntitiesToProtect(ctx context.Context, formats strfmt.Registry) error {

	if m.EntitiesToProtect != nil {

		if swag.IsZero(m.EntitiesToProtect) { // not required
			return nil
		}

		if err := m.EntitiesToProtect.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entitiesToProtect")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entitiesToProtect")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateBackupJobArg) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateBackupJobArg) UnmarshalBinary(b []byte) error {
	var res CreateBackupJobArg
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
