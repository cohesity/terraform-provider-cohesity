// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// NasBackupParams NAS Backup Parameters.
//
// Message to capture any additional backup params for a NAS environment.
//
// swagger:model NasBackupParams
type NasBackupParams struct {

	// This bool parameter will be set only for DP volumes when customer doesn't
	// select the full_backup_snapshot_label and
	// incremental_backup_snapshot_label. When set to true, backend will be
	// using existing oldest snapshot for the first backup. Each incremental
	// will be selected in ascending of snapshot create time on the source.
	BackupAllExistingSnapshot *bool `json:"backupAllExistingSnapshot,omitempty"`

	// Job level list of IP addresses that should not be used.
	BlacklistedIPAddrs []string `json:"blacklistedIpAddrs"`

	// Whether the backup job should continue on errors for snapshot based
	// backups. For non-snapshot-based generic NAS backup jobs, Magneto always
	// continues on errors.
	ContinueOnError *bool `json:"continueOnError,omitempty"`

	// Whether this backup job should use encryption.
	EncryptionEnabled *bool `json:"encryptionEnabled,omitempty"`

	// The filtering policy to decide which objects within a source should be
	// backed up. If this is not specified, then all of the objects within the
	// source will be backed up.
	FilteringPolicy *FilteringPolicyProto `json:"filteringPolicy,omitempty"`

	// File level data lock configuration.
	// To support File DataLock functionality similar to Netapp SnapLock,
	// the following fields will be required from the user.
	// This is same as what Cohesity as a filer offers for File DataLock.
	FldConfig *ViewIDMappingProtoFileLevelDataLockConfig `json:"fldConfig,omitempty"`

	// Only used when we backup using discovered snapshots. This prefix is to
	// figure out which discovered snapshot we need to use for full backup.
	FullBackupSnapshotLabel *string `json:"fullBackupSnapshotLabel,omitempty"`

	// Only used when we backup using discovered snapshots. This prefix is to
	// figure out which discovered snapshot we need to use for incremental
	// backup.
	IncrementalBackupSnapshotLabel *string `json:"incrementalBackupSnapshotLabel,omitempty"`

	// Source initiated backup when the source sends pushes the data like for
	// example snapmirror based backup for netapp.
	IsSourceInitiatedBackup *bool `json:"isSourceInitiatedBackup,omitempty"`

	// If the target entity is a mixed mode volume, which NAS protocol type the
	// user prefer to backup. This does not apply to generic NAS and will be
	// ignored.
	MixedModePreference *int32 `json:"mixedModePreference,omitempty"`

	// Specifies if the source permissions can be modified to allow the backup.
	ModifySourcePermissions *bool `json:"modifySourcePermissions,omitempty"`

	// If the target entity supports both NFSv3 and NFSv4.1, which NAS protocol
	// type the user prefers to backup. This does not apply to generic NAS and
	// will be ignored.
	NfsVersionPreference *int32 `json:"nfsVersionPreference,omitempty"`

	// This message captures all the details of S3 view.
	S3Viewbackupproperties *S3ViewBackupProperties `json:"s3Viewbackupproperties,omitempty"`

	// Specifies the view name if the view is to be shared across multiple
	// backup jobs. Required for backing up multiple directories of the same
	// share through different protection jobs(for faster backup).
	SharedViewName *string `json:"sharedViewName,omitempty"`

	// Whether this backup job should utilize changelist like API when available
	// for faster incremental backups.
	SnapshotChangeEnabled *bool `json:"snapshotChangeEnabled,omitempty"`

	// NAS throttling params for full and incremental backups. This overrides
	// corresponding source level parameters.
	ThrottlingParams *NasThrottlingParams `json:"throttlingParams,omitempty"`

	// Job level list of IP addresses that should be used exclusively.
	WhitelistedIPAddrs []string `json:"whitelistedIpAddrs"`
}

// Validate validates this nas backup params
func (m *NasBackupParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFilteringPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFldConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS3Viewbackupproperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThrottlingParams(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasBackupParams) validateFilteringPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.FilteringPolicy) { // not required
		return nil
	}

	if m.FilteringPolicy != nil {
		if err := m.FilteringPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filteringPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filteringPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *NasBackupParams) validateFldConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.FldConfig) { // not required
		return nil
	}

	if m.FldConfig != nil {
		if err := m.FldConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fldConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fldConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasBackupParams) validateS3Viewbackupproperties(formats strfmt.Registry) error {
	if swag.IsZero(m.S3Viewbackupproperties) { // not required
		return nil
	}

	if m.S3Viewbackupproperties != nil {
		if err := m.S3Viewbackupproperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3Viewbackupproperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3Viewbackupproperties")
			}
			return err
		}
	}

	return nil
}

func (m *NasBackupParams) validateThrottlingParams(formats strfmt.Registry) error {
	if swag.IsZero(m.ThrottlingParams) { // not required
		return nil
	}

	if m.ThrottlingParams != nil {
		if err := m.ThrottlingParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingParams")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this nas backup params based on the context it is used
func (m *NasBackupParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFilteringPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFldConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateS3Viewbackupproperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThrottlingParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NasBackupParams) contextValidateFilteringPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.FilteringPolicy != nil {

		if swag.IsZero(m.FilteringPolicy) { // not required
			return nil
		}

		if err := m.FilteringPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("filteringPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("filteringPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *NasBackupParams) contextValidateFldConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.FldConfig != nil {

		if swag.IsZero(m.FldConfig) { // not required
			return nil
		}

		if err := m.FldConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fldConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fldConfig")
			}
			return err
		}
	}

	return nil
}

func (m *NasBackupParams) contextValidateS3Viewbackupproperties(ctx context.Context, formats strfmt.Registry) error {

	if m.S3Viewbackupproperties != nil {

		if swag.IsZero(m.S3Viewbackupproperties) { // not required
			return nil
		}

		if err := m.S3Viewbackupproperties.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("s3Viewbackupproperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("s3Viewbackupproperties")
			}
			return err
		}
	}

	return nil
}

func (m *NasBackupParams) contextValidateThrottlingParams(ctx context.Context, formats strfmt.Registry) error {

	if m.ThrottlingParams != nil {

		if swag.IsZero(m.ThrottlingParams) { // not required
			return nil
		}

		if err := m.ThrottlingParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("throttlingParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("throttlingParams")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NasBackupParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NasBackupParams) UnmarshalBinary(b []byte) error {
	var res NasBackupParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
