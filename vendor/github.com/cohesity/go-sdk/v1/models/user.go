// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// User User Details.
//
// Specifies details about a user.
//
// swagger:model User
type User struct {

	// Specifies additional information pertaining to an active directory user.
	// This field is set only for AD users who has logged in via active
	// directory.
	AdUserInfo *ADUserInfo `json:"adUserInfo,omitempty"`

	// Array of Additional Groups.
	//
	// Specifies the names of additional groups this User may belong to.
	AdditionalGroupNames []string `json:"additionalGroupNames"`

	// Specifies if the data security user can be modified by the admin users.
	AllowDsoModify *bool `json:"allowDsoModify,omitempty"`

	// Specifies audit settings.
	AuditLogSettings *AuditLogSettings `json:"auditLogSettings,omitempty"`

	// Specifies the authentication type of the user.
	// 'kAuthLocal' implies authenticated user is a local user.
	// 'kAuthAd' implies authenticated user is an Active Directory user.
	// 'kAuthSalesforce' implies authenticated user is a Salesforce user.
	// 'kAuthGoogle' implies authenticated user is a Google user.
	// 'kAuthSso' implies authenticated user is an SAML based SSO user.
	// 'kAuthMcmOnPrem' implies authenticated user is an OnPrem MCM user.
	// 'kAuthService' implies authenticated client is an API consumer.
	// 'kAuthMsftSelfService' implies authenticated client is MSFT based via OIDC.
	// 'kAuthOidcSso' implies authenticated user is an SSO user via OIDC.
	// Enum: ["kAuthLocal","kAuthAd","kAuthSalesforce","kAuthGoogle","kAuthSso","kAuthMcmOnPrem","kAuthService","kAuthMsftSelfService","kAuthOidcSso"]
	AuthenticationType *string `json:"authenticationType,omitempty"`

	// Specifies the list of clusters this user has access to. If this is not
	// specified, access will be granted to all clusters.
	ClusterIdentifiers []*ClusterIdentifier `json:"clusterIdentifiers"`

	// Specifies the epoch time in milliseconds when the user account
	// was created on the Cohesity Cluster.
	CreatedTimeMsecs *int64 `json:"createdTimeMsecs,omitempty"`

	// Specifies the current password when updating the password.
	CurrentPassword *string `json:"currentPassword,omitempty"`

	// Specifies a description about the user.
	Description *string `json:"description,omitempty"`

	// Specifies the fully qualified domain name (FQDN) of an Active Directory
	// or LOCAL for the default LOCAL domain on the Cohesity Cluster.
	// A user is uniquely identified by combination of the username and
	// the domain.
	Domain *string `json:"domain,omitempty"`

	// Specifies the epoch time in milliseconds when the user becomes
	// effective. Until that time, the user cannot log in.
	EffectiveTimeMsecs *int64 `json:"effectiveTimeMsecs,omitempty"`

	// Specifies the email address of the user.
	EmailAddress *string `json:"emailAddress,omitempty"`

	// Specifies the epoch time in milliseconds when the user becomes
	// expired. After that, the user cannot log in.
	ExpiredTimeMsecs *int64 `json:"expiredTimeMsecs,omitempty"`

	// Specifies whether to force user to change password.
	ForcePasswordChange *bool `json:"forcePasswordChange,omitempty"`

	// Specifies additional information pertaining to Google account.
	// This field is set only for Helios BaaS users who has account on Google.
	GoogleAccount *GoogleAccountInfo `json:"googleAccount,omitempty"`

	// Specifies the Cohesity roles to associate with the user' group. These
	// roles can only be edited from group.
	// Read Only: true
	GroupRoles []string `json:"groupRoles"`

	// Specifies additional information pertaining to an IdP user.
	// This field is set only for IdP users who has logged in via IdP.
	IdpUserInfo *IdpUserInfo `json:"idpUserInfo,omitempty"`

	// Specifies the messenger token for intercom identity verification.
	IntercomMessengerToken *string `json:"intercomMessengerToken,omitempty"`

	// Specifies whether the user account is locked.
	IsAccountLocked *bool `json:"isAccountLocked,omitempty"`

	// Specifies if MFA is enabled for the Helios Account.
	// Read Only: true
	IsAccountMfaEnabled *bool `json:"isAccountMfaEnabled,omitempty"`

	// IsActive specifies whether or not a user is active, or has been
	// disactivated by the customer. The default behavior is 'true'.
	IsActive *bool `json:"isActive,omitempty"`

	// Specifies if MFA is enabled on cluster.
	// Read Only: true
	IsClusterMfaEnabled *bool `json:"isClusterMfaEnabled,omitempty"`

	// Specifies the epoch time in milliseconds when the user was last logged in
	// successfully.
	LastSuccessfulLoginTimeMsecs *int64 `json:"lastSuccessfulLoginTimeMsecs,omitempty"`

	// Specifies the epoch time in milliseconds when the user account was last
	// modified on the Cohesity Cluster.
	LastUpdatedTimeMsecs *int64 `json:"lastUpdatedTimeMsecs,omitempty"`

	// Specifies the lockout reason of the user if it is locked.
	// 'NotLocked' implies the user is not locked.
	// 'FailedLoginAttempts' the account is locked due to
	// many failed login attempts.
	// 'LockedByAdmin' implies the account is locked by the admin user.
	// 'Inactivity' implies the account is locked due to long time of inactivity.
	// 'OtherReasons' implied the account is loced for other reasons.
	// Enum: ["NotLocked","FailedLoginAttempts","LockedByAdmin","Inactivity","OtherReasons"]
	LockoutReason *string `json:"lockoutReason,omitempty"`

	// Specifies MFA info if MFA is enabled.
	MfaInfo *MfaInfo `json:"mfaInfo,omitempty"`

	// Specifies MFA methods that enabled on the cluster.
	MfaMethods []string `json:"mfaMethods"`

	// Specifies additional information pertaining to Micrsoft account.
	// This field is set only for users who have been authenticated through
	// MSFT OpenID Connect for Self Service workflows.
	MsftUserInfo *MsftUserInfo `json:"msftUserInfo,omitempty"`

	// Specifies object class of user, could be either user or group.
	ObjectClass *string `json:"objectClass,omitempty"`

	// OrgMembership contains the list of all available tenantIds for this
	// user to switch to. Only when creating the session user, this field is
	// populated on the fly. We discover the tenantIds from various groups
	// assigned to the users.
	OrgMembership []*TenantConfig `json:"orgMembership"`

	// Specifies the password of this user.
	Password *string `json:"password,omitempty"`

	// Specifies preferences of the user.
	Preferences *Preferences `json:"preferences,omitempty"`

	// Specifies the epoch time in milliseconds of previous user login.
	PreviousLoginTimeMsecs *int64 `json:"previousLoginTimeMsecs,omitempty"`

	// Specifies the name of the primary group of this User.
	PrimaryGroupName *string `json:"primaryGroupName,omitempty"`

	// Array of Privileges.
	//
	// Specifies the Cohesity privileges from the roles. This will be populated
	// based on the union of all privileges in roles.
	// Type for unique privilege Id values.
	// All below enum values specify a value for all uniquely defined
	// privileges in Cohesity.
	PrivilegeIds []string `json:"privilegeIds"`

	// Specifies the user profiles.
	// NOTE: Currently used for Helios.
	Profiles []*McmUserProfile `json:"profiles"`

	// Whether the user is a restricted user. A restricted user can only view
	// the objects he has permissions to.
	Restricted *bool `json:"restricted,omitempty"`

	// Array of Roles.
	//
	// Specifies the Cohesity roles to associate with the user such as
	// such as 'Admin', 'Ops' or 'View'.
	// The Cohesity roles determine privileges on the Cohesity Cluster
	// for this user.
	Roles []string `json:"roles"`

	// Specifies the S3 Account Access Key ID.
	S3AccessKeyID *string `json:"s3AccessKeyId,omitempty"`

	// Specifies the S3 Account Canonical User ID.
	S3AccountID *string `json:"s3AccountId,omitempty"`

	// Specifies the S3 Account Secret Key.
	S3SecretKey *string `json:"s3SecretKey,omitempty"`

	// Specifies additional information pertaining to Salesforce account.
	// This field is set only for Helios users who has account on Salesforce.
	SalesforceAccount *SalesforceAccountInfo `json:"salesforceAccount,omitempty"`

	// Specifies the unique Security ID (SID) of the user. This field is
	// mandatory in modifying user.
	Sid *string `json:"sid,omitempty"`

	// Specifies the SPOG context. This will be set for sessions where a user
	// is accessing a remote cluster. This is needed for audit logging purposes.
	SpogContext *SpogContext `json:"spogContext,omitempty"`

	// Specifies the subscription information. If the user has subscribed
	// for Helios, DataProtect, DRaaS.....
	SubscriptionInfo *SubscriptionInfo `json:"subscriptionInfo,omitempty"`

	// Specifies the tenant access available to current user.
	// NOTE: Currently used for Helios.
	TenantAccesses []*TenantAccess `json:"tenantAccesses"`

	// Specifies the effective Tenant ID of the user.
	TenantID *string `json:"tenantId,omitempty"`

	// Specifies the login name of the user.
	Username *string `json:"username,omitempty"`
}

// Validate validates this user
func (m *User) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdUserInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuditLogSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterIdentifiers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGoogleAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdpUserInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLockoutReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMfaInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMsftUserInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrgMembership(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreferences(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivilegeIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSalesforceAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpogContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenantAccesses(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *User) validateAdUserInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.AdUserInfo) { // not required
		return nil
	}

	if m.AdUserInfo != nil {
		if err := m.AdUserInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adUserInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("adUserInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateAuditLogSettings(formats strfmt.Registry) error {
	if swag.IsZero(m.AuditLogSettings) { // not required
		return nil
	}

	if m.AuditLogSettings != nil {
		if err := m.AuditLogSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auditLogSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("auditLogSettings")
			}
			return err
		}
	}

	return nil
}

var userTypeAuthenticationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kAuthLocal","kAuthAd","kAuthSalesforce","kAuthGoogle","kAuthSso","kAuthMcmOnPrem","kAuthService","kAuthMsftSelfService","kAuthOidcSso"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userTypeAuthenticationTypePropEnum = append(userTypeAuthenticationTypePropEnum, v)
	}
}

const (

	// UserAuthenticationTypeKAuthLocal captures enum value "kAuthLocal"
	UserAuthenticationTypeKAuthLocal string = "kAuthLocal"

	// UserAuthenticationTypeKAuthAd captures enum value "kAuthAd"
	UserAuthenticationTypeKAuthAd string = "kAuthAd"

	// UserAuthenticationTypeKAuthSalesforce captures enum value "kAuthSalesforce"
	UserAuthenticationTypeKAuthSalesforce string = "kAuthSalesforce"

	// UserAuthenticationTypeKAuthGoogle captures enum value "kAuthGoogle"
	UserAuthenticationTypeKAuthGoogle string = "kAuthGoogle"

	// UserAuthenticationTypeKAuthSso captures enum value "kAuthSso"
	UserAuthenticationTypeKAuthSso string = "kAuthSso"

	// UserAuthenticationTypeKAuthMcmOnPrem captures enum value "kAuthMcmOnPrem"
	UserAuthenticationTypeKAuthMcmOnPrem string = "kAuthMcmOnPrem"

	// UserAuthenticationTypeKAuthService captures enum value "kAuthService"
	UserAuthenticationTypeKAuthService string = "kAuthService"

	// UserAuthenticationTypeKAuthMsftSelfService captures enum value "kAuthMsftSelfService"
	UserAuthenticationTypeKAuthMsftSelfService string = "kAuthMsftSelfService"

	// UserAuthenticationTypeKAuthOidcSso captures enum value "kAuthOidcSso"
	UserAuthenticationTypeKAuthOidcSso string = "kAuthOidcSso"
)

// prop value enum
func (m *User) validateAuthenticationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userTypeAuthenticationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *User) validateAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthenticationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAuthenticationTypeEnum("authenticationType", "body", *m.AuthenticationType); err != nil {
		return err
	}

	return nil
}

func (m *User) validateClusterIdentifiers(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterIdentifiers) { // not required
		return nil
	}

	for i := 0; i < len(m.ClusterIdentifiers); i++ {
		if swag.IsZero(m.ClusterIdentifiers[i]) { // not required
			continue
		}

		if m.ClusterIdentifiers[i] != nil {
			if err := m.ClusterIdentifiers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusterIdentifiers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clusterIdentifiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *User) validateGoogleAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.GoogleAccount) { // not required
		return nil
	}

	if m.GoogleAccount != nil {
		if err := m.GoogleAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("googleAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("googleAccount")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateIdpUserInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.IdpUserInfo) { // not required
		return nil
	}

	if m.IdpUserInfo != nil {
		if err := m.IdpUserInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("idpUserInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("idpUserInfo")
			}
			return err
		}
	}

	return nil
}

var userTypeLockoutReasonPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NotLocked","FailedLoginAttempts","LockedByAdmin","Inactivity","OtherReasons"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userTypeLockoutReasonPropEnum = append(userTypeLockoutReasonPropEnum, v)
	}
}

const (

	// UserLockoutReasonNotLocked captures enum value "NotLocked"
	UserLockoutReasonNotLocked string = "NotLocked"

	// UserLockoutReasonFailedLoginAttempts captures enum value "FailedLoginAttempts"
	UserLockoutReasonFailedLoginAttempts string = "FailedLoginAttempts"

	// UserLockoutReasonLockedByAdmin captures enum value "LockedByAdmin"
	UserLockoutReasonLockedByAdmin string = "LockedByAdmin"

	// UserLockoutReasonInactivity captures enum value "Inactivity"
	UserLockoutReasonInactivity string = "Inactivity"

	// UserLockoutReasonOtherReasons captures enum value "OtherReasons"
	UserLockoutReasonOtherReasons string = "OtherReasons"
)

// prop value enum
func (m *User) validateLockoutReasonEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userTypeLockoutReasonPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *User) validateLockoutReason(formats strfmt.Registry) error {
	if swag.IsZero(m.LockoutReason) { // not required
		return nil
	}

	// value enum
	if err := m.validateLockoutReasonEnum("lockoutReason", "body", *m.LockoutReason); err != nil {
		return err
	}

	return nil
}

func (m *User) validateMfaInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.MfaInfo) { // not required
		return nil
	}

	if m.MfaInfo != nil {
		if err := m.MfaInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mfaInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mfaInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateMsftUserInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.MsftUserInfo) { // not required
		return nil
	}

	if m.MsftUserInfo != nil {
		if err := m.MsftUserInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("msftUserInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("msftUserInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateOrgMembership(formats strfmt.Registry) error {
	if swag.IsZero(m.OrgMembership) { // not required
		return nil
	}

	for i := 0; i < len(m.OrgMembership); i++ {
		if swag.IsZero(m.OrgMembership[i]) { // not required
			continue
		}

		if m.OrgMembership[i] != nil {
			if err := m.OrgMembership[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orgMembership" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("orgMembership" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *User) validatePreferences(formats strfmt.Registry) error {
	if swag.IsZero(m.Preferences) { // not required
		return nil
	}

	if m.Preferences != nil {
		if err := m.Preferences.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("preferences")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("preferences")
			}
			return err
		}
	}

	return nil
}

var userPrivilegeIdsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kPrincipalView","kPrincipalModify","kAppLaunch","kAppsManagement","kOrganizationView","kOrganizationModify","kOrganizationImpersonate","kCloneView","kCloneModify","kClusterView","kClusterModify","kClusterCreate","kClusterSupport","kClusterUpgrade","kClusterRemoteView","kClusterRemoteModify","kClusterExternalTargetView","kClusterExternalTargetModify","kClusterAudit","kAlertView","kAlertModify","kVlanView","kVlanModify","kHybridExtenderView","kHybridExtenderDownload","kAdLdapView","kAdLdapModify","kSchedulerView","kSchedulerModify","kProtectionView","kProtectionModify","kProtectionJobOperate","kProtectionSourceModify","kProtectionPolicyView","kProtectionPolicyModify","kRestoreView","kRestoreModify","kRestoreDownload","kRemoteRestore","kStorageView","kStorageModify","kStorageDomainView","kStorageDomainModify","kAnalyticsView","kAnalyticsModify","kReportsView","kMcmModify","kDataSecurity","kSmbBackup","kSmbRestore","kSmbTakeOwnership","kSmbAuditing","kMcmUnregister","kMcmUpgrade","kMcmModifySuperAdmin","kMcmViewSuperAdmin","kMcmModifyCohesityAdmin","kMcmViewCohesityAdmin","kObjectSearch","kFileDatalockExpiryTimeDecrease"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userPrivilegeIdsItemsEnum = append(userPrivilegeIdsItemsEnum, v)
	}
}

func (m *User) validatePrivilegeIdsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userPrivilegeIdsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *User) validatePrivilegeIds(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivilegeIds) { // not required
		return nil
	}

	for i := 0; i < len(m.PrivilegeIds); i++ {

		// value enum
		if err := m.validatePrivilegeIdsItemsEnum("privilegeIds"+"."+strconv.Itoa(i), "body", m.PrivilegeIds[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *User) validateProfiles(formats strfmt.Registry) error {
	if swag.IsZero(m.Profiles) { // not required
		return nil
	}

	for i := 0; i < len(m.Profiles); i++ {
		if swag.IsZero(m.Profiles[i]) { // not required
			continue
		}

		if m.Profiles[i] != nil {
			if err := m.Profiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("profiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *User) validateSalesforceAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.SalesforceAccount) { // not required
		return nil
	}

	if m.SalesforceAccount != nil {
		if err := m.SalesforceAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("salesforceAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("salesforceAccount")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateSpogContext(formats strfmt.Registry) error {
	if swag.IsZero(m.SpogContext) { // not required
		return nil
	}

	if m.SpogContext != nil {
		if err := m.SpogContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spogContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spogContext")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateSubscriptionInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.SubscriptionInfo) { // not required
		return nil
	}

	if m.SubscriptionInfo != nil {
		if err := m.SubscriptionInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subscriptionInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subscriptionInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateTenantAccesses(formats strfmt.Registry) error {
	if swag.IsZero(m.TenantAccesses) { // not required
		return nil
	}

	for i := 0; i < len(m.TenantAccesses); i++ {
		if swag.IsZero(m.TenantAccesses[i]) { // not required
			continue
		}

		if m.TenantAccesses[i] != nil {
			if err := m.TenantAccesses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tenantAccesses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tenantAccesses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this user based on the context it is used
func (m *User) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAdUserInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuditLogSettings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClusterIdentifiers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGoogleAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGroupRoles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIdpUserInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsAccountMfaEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsClusterMfaEnabled(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMfaInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMsftUserInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrgMembership(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePreferences(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProfiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSalesforceAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpogContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubscriptionInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTenantAccesses(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *User) contextValidateAdUserInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.AdUserInfo != nil {

		if swag.IsZero(m.AdUserInfo) { // not required
			return nil
		}

		if err := m.AdUserInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adUserInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("adUserInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateAuditLogSettings(ctx context.Context, formats strfmt.Registry) error {

	if m.AuditLogSettings != nil {

		if swag.IsZero(m.AuditLogSettings) { // not required
			return nil
		}

		if err := m.AuditLogSettings.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auditLogSettings")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("auditLogSettings")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateClusterIdentifiers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClusterIdentifiers); i++ {

		if m.ClusterIdentifiers[i] != nil {

			if swag.IsZero(m.ClusterIdentifiers[i]) { // not required
				return nil
			}

			if err := m.ClusterIdentifiers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clusterIdentifiers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("clusterIdentifiers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *User) contextValidateGoogleAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.GoogleAccount != nil {

		if swag.IsZero(m.GoogleAccount) { // not required
			return nil
		}

		if err := m.GoogleAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("googleAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("googleAccount")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateGroupRoles(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "groupRoles", "body", []string(m.GroupRoles)); err != nil {
		return err
	}

	return nil
}

func (m *User) contextValidateIdpUserInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.IdpUserInfo != nil {

		if swag.IsZero(m.IdpUserInfo) { // not required
			return nil
		}

		if err := m.IdpUserInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("idpUserInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("idpUserInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateIsAccountMfaEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isAccountMfaEnabled", "body", m.IsAccountMfaEnabled); err != nil {
		return err
	}

	return nil
}

func (m *User) contextValidateIsClusterMfaEnabled(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "isClusterMfaEnabled", "body", m.IsClusterMfaEnabled); err != nil {
		return err
	}

	return nil
}

func (m *User) contextValidateMfaInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.MfaInfo != nil {

		if swag.IsZero(m.MfaInfo) { // not required
			return nil
		}

		if err := m.MfaInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mfaInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mfaInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateMsftUserInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.MsftUserInfo != nil {

		if swag.IsZero(m.MsftUserInfo) { // not required
			return nil
		}

		if err := m.MsftUserInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("msftUserInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("msftUserInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateOrgMembership(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OrgMembership); i++ {

		if m.OrgMembership[i] != nil {

			if swag.IsZero(m.OrgMembership[i]) { // not required
				return nil
			}

			if err := m.OrgMembership[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orgMembership" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("orgMembership" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *User) contextValidatePreferences(ctx context.Context, formats strfmt.Registry) error {

	if m.Preferences != nil {

		if swag.IsZero(m.Preferences) { // not required
			return nil
		}

		if err := m.Preferences.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("preferences")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("preferences")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateProfiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Profiles); i++ {

		if m.Profiles[i] != nil {

			if swag.IsZero(m.Profiles[i]) { // not required
				return nil
			}

			if err := m.Profiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("profiles" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("profiles" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *User) contextValidateSalesforceAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.SalesforceAccount != nil {

		if swag.IsZero(m.SalesforceAccount) { // not required
			return nil
		}

		if err := m.SalesforceAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("salesforceAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("salesforceAccount")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateSpogContext(ctx context.Context, formats strfmt.Registry) error {

	if m.SpogContext != nil {

		if swag.IsZero(m.SpogContext) { // not required
			return nil
		}

		if err := m.SpogContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spogContext")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spogContext")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateSubscriptionInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.SubscriptionInfo != nil {

		if swag.IsZero(m.SubscriptionInfo) { // not required
			return nil
		}

		if err := m.SubscriptionInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("subscriptionInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("subscriptionInfo")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateTenantAccesses(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TenantAccesses); i++ {

		if m.TenantAccesses[i] != nil {

			if swag.IsZero(m.TenantAccesses[i]) { // not required
				return nil
			}

			if err := m.TenantAccesses[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tenantAccesses" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tenantAccesses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *User) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *User) UnmarshalBinary(b []byte) error {
	var res User
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
