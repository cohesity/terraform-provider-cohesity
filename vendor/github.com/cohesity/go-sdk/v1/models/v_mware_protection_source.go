// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VMwareProtectionSource VMware Protection Source.
//
// Specifies a Protection Source in a VMware environment.
//
// swagger:model VMwareProtectionSource
type VMwareProtectionSource struct {

	// This field specifies VMware cloud provider where VMC is hosted.
	// 'kNone' VMC source is hosted on unknown cloud provider.
	// 'kAWS' VMC source is hosted on AWS cloud.
	// 'kAzure' VMC source is hosted on Azure cloud.
	// 'kGCP' VMC source is hosted on GCP cloud.
	// Enum: ["kNone","kAWS","kAzure","kGCP"]
	VMwareCloudProviderType *string `json:"VMwareCloudProviderType,omitempty"`

	// Specifies the id of the persistent agent.
	AgentID *int64 `json:"agentId,omitempty"`

	// Specifies the list of agent information on the Virtual Machine.
	// This is set only if the Virtual Machine has persistent agent.
	Agents []*AgentInformation `json:"agents"`

	// This field contains the details about Continuous Data Protection (CDP) of
	// the Protection Source.
	CdpInfo *VMwareCdpProtectionSourceInfo `json:"cdpInfo,omitempty"`

	// Specifies the connection state of the Object and are only valid for
	// ESXi hosts ('kHostSystem') or Virtual Machines ('kVirtualMachine').
	// These enums are equivalent to the connection states documented in
	// VMware's reference documentation.
	// Examples of Cohesity connection states include 'kConnected',
	// 'kDisconnected', 'kInacccessible', etc.
	// 'kConnected' indicates that server has access to virtual machine.
	// 'kDisconnected' indicates that server is currently disconnected to virtual
	// machine.
	// 'kInaccessible' indicates that one or more configuration files are
	// inacccessible.
	// 'kInvalid' indicates that virtual machine configuration is invalid.
	// 'kOrphaned' indicates that virtual machine is no longer registered on the
	// host it is associated with.
	// 'kNotResponding' indicates that virtual machine has failed to respond
	// due to external issues such as network connectivity, host not running etc.
	// Enum: ["kConnected","kDisconnected","kInaccessible","kInvalid","kOrphaned","kNotResponding"]
	ConnectionState *string `json:"connectionState,omitempty"`

	// Specifies additional information of entities of type 'kDatastore'.
	DatastoreInfo *DatastoreInfo `json:"datastoreInfo,omitempty"`

	// Specifies the folder type for the 'kFolder' Object.
	// 'kVMFolder' indicates folder can hold VMs or vApps.
	// 'kHostFolder' indicates folder can hold hosts and compute resources.
	// 'kDatastoreFolder' indicates folder can hold datastores and storage pods.
	// 'kNetworkFolder' indicates folder can hold networks and switches.
	// 'kRootFolder' indicates folder can hold datacenters.
	// Enum: ["kVMFolder","kHostFolder","kDatastoreFolder","kNetworkFolder","kRootFolder"]
	FolderType *string `json:"folderType,omitempty"`

	// Set to true if a persistent agent is running on the Virtual Machine.
	// This is populated for entities of type 'kVirtualMachine'.
	HasPersistentAgent *bool `json:"hasPersistentAgent,omitempty"`

	// Specifies the host type for the 'kVirtualMachine' Object.
	// 'kLinux' indicates the Linux operating system.
	// 'kWindows' indicates the Microsoft Windows operating system.
	// 'kAix' indicates the IBM AIX operating system.
	// 'kSolaris' indicates the Oracle Solaris operating system.
	// 'kSapHana' indicates the Sap Hana database system developed by SAP SE.
	// 'kSapOracle' indicates the Sap Oracle database system developed by SAP SE.
	// 'kCockroachDB' indicates the CockroachDB database system.
	// 'kMySQL' indicates the MySQL database system.
	// 'kSapSybase' indicates the SapSybase database system.
	// 'kSapMaxDB' indicates the SapMaxDB database system.
	// 'kSapSybaseIQ' indicates the SapSybaseIQ database system.
	// 'kDB2' indicates the DB2 database system.
	// 'kSapASE' indicates the SapASE database system.
	// 'kMariaDB' indicates the MariaDB database system.
	// 'kPostgreSQL' indicates the PostgreSQL database system.
	// 'kHPUX' indicates the HPUX database system.
	// 'kVOS' indicates the VOS database system.
	// 'kOther' indicates the other types of operating system.
	// Enum: ["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]
	HostType *string `json:"hostType,omitempty"`

	// Specifies the UUID of the VMware Protection Source.
	ID *VMwareObjectID `json:"id,omitempty"`

	// This field can be used to capture IP Addresses for entities that have it.
	IPDetails *IPDetails `json:"ipDetails,omitempty"`

	// The field indicates whether the VM is a Rigel/HyX VM.
	IsSaasConnector *bool `json:"isSaasConnector,omitempty"`

	// IsTemplate specifies if the VM is a template or not.
	IsVMTemplate *bool `json:"isVmTemplate,omitempty"`

	// This field is used for indicating that registered vmware source is a
	// VMC (VMware Cloud) environment.
	IsVmcEntity *bool `json:"isVmcEntity,omitempty"`

	// Specifies a human readable name of the Protection Source.
	Name *string `json:"name,omitempty"`

	// Specifies the optional list of VM Tag attributes associated with this
	// Object.
	TagAttributes []*TagAttribute `json:"tagAttributes"`

	// Specifies the status of VMware Tools for the guest OS on the VM.
	// This is only valid for the 'kVirtualMachine' type.
	// 'kGuestToolsRunning' means the VMware tools are running on the guest OS.
	// 'kGuestToolsNotRunning' means the VMware tools are not running on the
	// guest OS.
	// 'kUnknown' means the state of the VMware tools on the guest OS is not
	// known.
	// 'kGuestToolsExecutingScripts' means the guest OS is currently executing
	// scripts using VMware tools.
	// Enum: ["kUnknown","kGuestToolsExecutingScripts","kGuestToolsNotRunning","kGuestToolsRunning"]
	ToolsRunningStatus *string `json:"toolsRunningStatus,omitempty"`

	// Specifies the type of managed Object in a VMware Protection Source.
	// Examples of VMware Objects include 'kVCenter', 'kFolder', 'kDatacenter',
	// 'kResourcePool', 'kDatastore', 'kVirtualMachine', etc.
	// 'kVCenter' indicates the vCenter entity in a VMware protection source type.
	// 'kFolder indicates the folder entity (of any kind) in a VMware protection source type.
	// 'kDatacenter' indicates the datacenter entity in a VMware protection source type.
	// 'kComputeResource' indicates the physical compute resource entity in a VMware
	// protection source type.
	// 'kResourcePool' indicates the set of physical resources within a compute resource
	// or cloudcompute resource.
	// 'kDataStore' indicates the datastore entity in a VMware protection source type.
	// 'kHostSystem' indicates the ESXi host entity in a VMware protection source type.
	// 'kVirtualMachine' indicates the virtual machine entity in a VMware protection source type.
	// 'kVirtualApp' indicates the virtual app entity in a VMware protection source type.
	// 'kStandaloneHost' indicates the standalone ESXi host entity (not managed by vCenter)
	// in a VMware protection source type.
	// 'kStoragePod' indicates the storage pod entity in a VMware protection source type.
	// 'kNetwork' indicates the standard vSwitch in a VMware protection source type.
	// 'kDistributedVirtualPortgroup' indicates a distributed vSwitch port group in a
	// VMware protection source type.
	// 'kTagCategory' indicates a tag category entity in a VMware protection source type.
	// 'kTag' indicates a tag entity in a VMware protection source type.
	// 'kOpaqueNetwork' indicates an opaque network which is created and managed by an
	// entity outside of vSphere.
	// 'kvCloudDirector' indicates a vCloud director entity in a VMware protection source type.
	// 'kOrganization' indicates an Organization under a vCD in a VMware protection source type.
	// 'kVirtualDatacenter' indicates a virtual datacenter entity in a VMware protection source type.
	// 'kCatalog' indicates a VCD catalog entity in a VMware protection source type.
	// 'kOrgMetadata' indicates an VCD organization metadata in a VMware protection source type.
	// 'kStoragePolicy' indicates a storage policy associated with the vApp in a VMware protection source type.
	// Enum: ["kVCenter","kFolder","kDatacenter","kComputeResource","kClusterComputeResource","kResourcePool","kDatastore","kHostSystem","kVirtualMachine","kVirtualApp","kStandaloneHost","kStoragePod","kNetwork","kDistributedVirtualPortgroup","kTagCategory","kTag","kOpaqueNetwork","kvCloudDirector","kOrganization","kVirtualDatacenter","kCatalog","kOrgMetadata","kStoragePolicy"]
	Type *string `json:"type,omitempty"`

	// Specifies an array of vCenters to be registered
	VCloudDirectorInfo []*VCloudDirectorInfo `json:"vCloudDirectorInfo"`

	// For vCenter and ESXi, this will show the software version. For VMs, this
	// will show the hardware version.
	Version *string `json:"version,omitempty"`

	// Specifies an array of virtual disks that are part of the Virtual Machine.
	// This is populated for entities of type 'kVirtualMachine'.
	VirtualDisks []*VirtualDiskInfo `json:"virtualDisks"`

	// This field contains information about a VM that has been migrated
	// from another vCenter. This is only valid for the 'kVirtualMachine' type.
	VMLinkingInfo *VMLinkingInfo `json:"vmLinkingInfo,omitempty"`
}

// Validate validates this v mware protection source
func (m *VMwareProtectionSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateVMwareCloudProviderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAgents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCdpInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDatastoreInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFolderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagAttributes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToolsRunningStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVCloudDirectorInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVirtualDisks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMLinkingInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var vMwareProtectionSourceTypeVMwareCloudProviderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kNone","kAWS","kAzure","kGCP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vMwareProtectionSourceTypeVMwareCloudProviderTypePropEnum = append(vMwareProtectionSourceTypeVMwareCloudProviderTypePropEnum, v)
	}
}

const (

	// VMwareProtectionSourceVMwareCloudProviderTypeKNone captures enum value "kNone"
	VMwareProtectionSourceVMwareCloudProviderTypeKNone string = "kNone"

	// VMwareProtectionSourceVMwareCloudProviderTypeKAWS captures enum value "kAWS"
	VMwareProtectionSourceVMwareCloudProviderTypeKAWS string = "kAWS"

	// VMwareProtectionSourceVMwareCloudProviderTypeKAzure captures enum value "kAzure"
	VMwareProtectionSourceVMwareCloudProviderTypeKAzure string = "kAzure"

	// VMwareProtectionSourceVMwareCloudProviderTypeKGCP captures enum value "kGCP"
	VMwareProtectionSourceVMwareCloudProviderTypeKGCP string = "kGCP"
)

// prop value enum
func (m *VMwareProtectionSource) validateVMwareCloudProviderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vMwareProtectionSourceTypeVMwareCloudProviderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VMwareProtectionSource) validateVMwareCloudProviderType(formats strfmt.Registry) error {
	if swag.IsZero(m.VMwareCloudProviderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateVMwareCloudProviderTypeEnum("VMwareCloudProviderType", "body", *m.VMwareCloudProviderType); err != nil {
		return err
	}

	return nil
}

func (m *VMwareProtectionSource) validateAgents(formats strfmt.Registry) error {
	if swag.IsZero(m.Agents) { // not required
		return nil
	}

	for i := 0; i < len(m.Agents); i++ {
		if swag.IsZero(m.Agents[i]) { // not required
			continue
		}

		if m.Agents[i] != nil {
			if err := m.Agents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) validateCdpInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.CdpInfo) { // not required
		return nil
	}

	if m.CdpInfo != nil {
		if err := m.CdpInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cdpInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cdpInfo")
			}
			return err
		}
	}

	return nil
}

var vMwareProtectionSourceTypeConnectionStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kConnected","kDisconnected","kInaccessible","kInvalid","kOrphaned","kNotResponding"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vMwareProtectionSourceTypeConnectionStatePropEnum = append(vMwareProtectionSourceTypeConnectionStatePropEnum, v)
	}
}

const (

	// VMwareProtectionSourceConnectionStateKConnected captures enum value "kConnected"
	VMwareProtectionSourceConnectionStateKConnected string = "kConnected"

	// VMwareProtectionSourceConnectionStateKDisconnected captures enum value "kDisconnected"
	VMwareProtectionSourceConnectionStateKDisconnected string = "kDisconnected"

	// VMwareProtectionSourceConnectionStateKInaccessible captures enum value "kInaccessible"
	VMwareProtectionSourceConnectionStateKInaccessible string = "kInaccessible"

	// VMwareProtectionSourceConnectionStateKInvalid captures enum value "kInvalid"
	VMwareProtectionSourceConnectionStateKInvalid string = "kInvalid"

	// VMwareProtectionSourceConnectionStateKOrphaned captures enum value "kOrphaned"
	VMwareProtectionSourceConnectionStateKOrphaned string = "kOrphaned"

	// VMwareProtectionSourceConnectionStateKNotResponding captures enum value "kNotResponding"
	VMwareProtectionSourceConnectionStateKNotResponding string = "kNotResponding"
)

// prop value enum
func (m *VMwareProtectionSource) validateConnectionStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vMwareProtectionSourceTypeConnectionStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VMwareProtectionSource) validateConnectionState(formats strfmt.Registry) error {
	if swag.IsZero(m.ConnectionState) { // not required
		return nil
	}

	// value enum
	if err := m.validateConnectionStateEnum("connectionState", "body", *m.ConnectionState); err != nil {
		return err
	}

	return nil
}

func (m *VMwareProtectionSource) validateDatastoreInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.DatastoreInfo) { // not required
		return nil
	}

	if m.DatastoreInfo != nil {
		if err := m.DatastoreInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("datastoreInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("datastoreInfo")
			}
			return err
		}
	}

	return nil
}

var vMwareProtectionSourceTypeFolderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kVMFolder","kHostFolder","kDatastoreFolder","kNetworkFolder","kRootFolder"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vMwareProtectionSourceTypeFolderTypePropEnum = append(vMwareProtectionSourceTypeFolderTypePropEnum, v)
	}
}

const (

	// VMwareProtectionSourceFolderTypeKVMFolder captures enum value "kVMFolder"
	VMwareProtectionSourceFolderTypeKVMFolder string = "kVMFolder"

	// VMwareProtectionSourceFolderTypeKHostFolder captures enum value "kHostFolder"
	VMwareProtectionSourceFolderTypeKHostFolder string = "kHostFolder"

	// VMwareProtectionSourceFolderTypeKDatastoreFolder captures enum value "kDatastoreFolder"
	VMwareProtectionSourceFolderTypeKDatastoreFolder string = "kDatastoreFolder"

	// VMwareProtectionSourceFolderTypeKNetworkFolder captures enum value "kNetworkFolder"
	VMwareProtectionSourceFolderTypeKNetworkFolder string = "kNetworkFolder"

	// VMwareProtectionSourceFolderTypeKRootFolder captures enum value "kRootFolder"
	VMwareProtectionSourceFolderTypeKRootFolder string = "kRootFolder"
)

// prop value enum
func (m *VMwareProtectionSource) validateFolderTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vMwareProtectionSourceTypeFolderTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VMwareProtectionSource) validateFolderType(formats strfmt.Registry) error {
	if swag.IsZero(m.FolderType) { // not required
		return nil
	}

	// value enum
	if err := m.validateFolderTypeEnum("folderType", "body", *m.FolderType); err != nil {
		return err
	}

	return nil
}

var vMwareProtectionSourceTypeHostTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kLinux","kWindows","kAix","kSolaris","kSapHana","kSapOracle","kCockroachDB","kMySQL","kOther","kSapSybase","kSapMaxDB","kSapSybaseIQ","kDB2","kSapASE","kMariaDB","kPostgreSQL","kVOS","kHPUX"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vMwareProtectionSourceTypeHostTypePropEnum = append(vMwareProtectionSourceTypeHostTypePropEnum, v)
	}
}

const (

	// VMwareProtectionSourceHostTypeKLinux captures enum value "kLinux"
	VMwareProtectionSourceHostTypeKLinux string = "kLinux"

	// VMwareProtectionSourceHostTypeKWindows captures enum value "kWindows"
	VMwareProtectionSourceHostTypeKWindows string = "kWindows"

	// VMwareProtectionSourceHostTypeKAix captures enum value "kAix"
	VMwareProtectionSourceHostTypeKAix string = "kAix"

	// VMwareProtectionSourceHostTypeKSolaris captures enum value "kSolaris"
	VMwareProtectionSourceHostTypeKSolaris string = "kSolaris"

	// VMwareProtectionSourceHostTypeKSapHana captures enum value "kSapHana"
	VMwareProtectionSourceHostTypeKSapHana string = "kSapHana"

	// VMwareProtectionSourceHostTypeKSapOracle captures enum value "kSapOracle"
	VMwareProtectionSourceHostTypeKSapOracle string = "kSapOracle"

	// VMwareProtectionSourceHostTypeKCockroachDB captures enum value "kCockroachDB"
	VMwareProtectionSourceHostTypeKCockroachDB string = "kCockroachDB"

	// VMwareProtectionSourceHostTypeKMySQL captures enum value "kMySQL"
	VMwareProtectionSourceHostTypeKMySQL string = "kMySQL"

	// VMwareProtectionSourceHostTypeKOther captures enum value "kOther"
	VMwareProtectionSourceHostTypeKOther string = "kOther"

	// VMwareProtectionSourceHostTypeKSapSybase captures enum value "kSapSybase"
	VMwareProtectionSourceHostTypeKSapSybase string = "kSapSybase"

	// VMwareProtectionSourceHostTypeKSapMaxDB captures enum value "kSapMaxDB"
	VMwareProtectionSourceHostTypeKSapMaxDB string = "kSapMaxDB"

	// VMwareProtectionSourceHostTypeKSapSybaseIQ captures enum value "kSapSybaseIQ"
	VMwareProtectionSourceHostTypeKSapSybaseIQ string = "kSapSybaseIQ"

	// VMwareProtectionSourceHostTypeKDB2 captures enum value "kDB2"
	VMwareProtectionSourceHostTypeKDB2 string = "kDB2"

	// VMwareProtectionSourceHostTypeKSapASE captures enum value "kSapASE"
	VMwareProtectionSourceHostTypeKSapASE string = "kSapASE"

	// VMwareProtectionSourceHostTypeKMariaDB captures enum value "kMariaDB"
	VMwareProtectionSourceHostTypeKMariaDB string = "kMariaDB"

	// VMwareProtectionSourceHostTypeKPostgreSQL captures enum value "kPostgreSQL"
	VMwareProtectionSourceHostTypeKPostgreSQL string = "kPostgreSQL"

	// VMwareProtectionSourceHostTypeKVOS captures enum value "kVOS"
	VMwareProtectionSourceHostTypeKVOS string = "kVOS"

	// VMwareProtectionSourceHostTypeKHPUX captures enum value "kHPUX"
	VMwareProtectionSourceHostTypeKHPUX string = "kHPUX"
)

// prop value enum
func (m *VMwareProtectionSource) validateHostTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vMwareProtectionSourceTypeHostTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VMwareProtectionSource) validateHostType(formats strfmt.Registry) error {
	if swag.IsZero(m.HostType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHostTypeEnum("hostType", "body", *m.HostType); err != nil {
		return err
	}

	return nil
}

func (m *VMwareProtectionSource) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if m.ID != nil {
		if err := m.ID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *VMwareProtectionSource) validateIPDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.IPDetails) { // not required
		return nil
	}

	if m.IPDetails != nil {
		if err := m.IPDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ipDetails")
			}
			return err
		}
	}

	return nil
}

func (m *VMwareProtectionSource) validateTagAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.TagAttributes) { // not required
		return nil
	}

	for i := 0; i < len(m.TagAttributes); i++ {
		if swag.IsZero(m.TagAttributes[i]) { // not required
			continue
		}

		if m.TagAttributes[i] != nil {
			if err := m.TagAttributes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var vMwareProtectionSourceTypeToolsRunningStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kUnknown","kGuestToolsExecutingScripts","kGuestToolsNotRunning","kGuestToolsRunning"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vMwareProtectionSourceTypeToolsRunningStatusPropEnum = append(vMwareProtectionSourceTypeToolsRunningStatusPropEnum, v)
	}
}

const (

	// VMwareProtectionSourceToolsRunningStatusKUnknown captures enum value "kUnknown"
	VMwareProtectionSourceToolsRunningStatusKUnknown string = "kUnknown"

	// VMwareProtectionSourceToolsRunningStatusKGuestToolsExecutingScripts captures enum value "kGuestToolsExecutingScripts"
	VMwareProtectionSourceToolsRunningStatusKGuestToolsExecutingScripts string = "kGuestToolsExecutingScripts"

	// VMwareProtectionSourceToolsRunningStatusKGuestToolsNotRunning captures enum value "kGuestToolsNotRunning"
	VMwareProtectionSourceToolsRunningStatusKGuestToolsNotRunning string = "kGuestToolsNotRunning"

	// VMwareProtectionSourceToolsRunningStatusKGuestToolsRunning captures enum value "kGuestToolsRunning"
	VMwareProtectionSourceToolsRunningStatusKGuestToolsRunning string = "kGuestToolsRunning"
)

// prop value enum
func (m *VMwareProtectionSource) validateToolsRunningStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vMwareProtectionSourceTypeToolsRunningStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VMwareProtectionSource) validateToolsRunningStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ToolsRunningStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateToolsRunningStatusEnum("toolsRunningStatus", "body", *m.ToolsRunningStatus); err != nil {
		return err
	}

	return nil
}

var vMwareProtectionSourceTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["kVCenter","kFolder","kDatacenter","kComputeResource","kClusterComputeResource","kResourcePool","kDatastore","kHostSystem","kVirtualMachine","kVirtualApp","kStandaloneHost","kStoragePod","kNetwork","kDistributedVirtualPortgroup","kTagCategory","kTag","kOpaqueNetwork","kvCloudDirector","kOrganization","kVirtualDatacenter","kCatalog","kOrgMetadata","kStoragePolicy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vMwareProtectionSourceTypeTypePropEnum = append(vMwareProtectionSourceTypeTypePropEnum, v)
	}
}

const (

	// VMwareProtectionSourceTypeKVCenter captures enum value "kVCenter"
	VMwareProtectionSourceTypeKVCenter string = "kVCenter"

	// VMwareProtectionSourceTypeKFolder captures enum value "kFolder"
	VMwareProtectionSourceTypeKFolder string = "kFolder"

	// VMwareProtectionSourceTypeKDatacenter captures enum value "kDatacenter"
	VMwareProtectionSourceTypeKDatacenter string = "kDatacenter"

	// VMwareProtectionSourceTypeKComputeResource captures enum value "kComputeResource"
	VMwareProtectionSourceTypeKComputeResource string = "kComputeResource"

	// VMwareProtectionSourceTypeKClusterComputeResource captures enum value "kClusterComputeResource"
	VMwareProtectionSourceTypeKClusterComputeResource string = "kClusterComputeResource"

	// VMwareProtectionSourceTypeKResourcePool captures enum value "kResourcePool"
	VMwareProtectionSourceTypeKResourcePool string = "kResourcePool"

	// VMwareProtectionSourceTypeKDatastore captures enum value "kDatastore"
	VMwareProtectionSourceTypeKDatastore string = "kDatastore"

	// VMwareProtectionSourceTypeKHostSystem captures enum value "kHostSystem"
	VMwareProtectionSourceTypeKHostSystem string = "kHostSystem"

	// VMwareProtectionSourceTypeKVirtualMachine captures enum value "kVirtualMachine"
	VMwareProtectionSourceTypeKVirtualMachine string = "kVirtualMachine"

	// VMwareProtectionSourceTypeKVirtualApp captures enum value "kVirtualApp"
	VMwareProtectionSourceTypeKVirtualApp string = "kVirtualApp"

	// VMwareProtectionSourceTypeKStandaloneHost captures enum value "kStandaloneHost"
	VMwareProtectionSourceTypeKStandaloneHost string = "kStandaloneHost"

	// VMwareProtectionSourceTypeKStoragePod captures enum value "kStoragePod"
	VMwareProtectionSourceTypeKStoragePod string = "kStoragePod"

	// VMwareProtectionSourceTypeKNetwork captures enum value "kNetwork"
	VMwareProtectionSourceTypeKNetwork string = "kNetwork"

	// VMwareProtectionSourceTypeKDistributedVirtualPortgroup captures enum value "kDistributedVirtualPortgroup"
	VMwareProtectionSourceTypeKDistributedVirtualPortgroup string = "kDistributedVirtualPortgroup"

	// VMwareProtectionSourceTypeKTagCategory captures enum value "kTagCategory"
	VMwareProtectionSourceTypeKTagCategory string = "kTagCategory"

	// VMwareProtectionSourceTypeKTag captures enum value "kTag"
	VMwareProtectionSourceTypeKTag string = "kTag"

	// VMwareProtectionSourceTypeKOpaqueNetwork captures enum value "kOpaqueNetwork"
	VMwareProtectionSourceTypeKOpaqueNetwork string = "kOpaqueNetwork"

	// VMwareProtectionSourceTypeKvCloudDirector captures enum value "kvCloudDirector"
	VMwareProtectionSourceTypeKvCloudDirector string = "kvCloudDirector"

	// VMwareProtectionSourceTypeKOrganization captures enum value "kOrganization"
	VMwareProtectionSourceTypeKOrganization string = "kOrganization"

	// VMwareProtectionSourceTypeKVirtualDatacenter captures enum value "kVirtualDatacenter"
	VMwareProtectionSourceTypeKVirtualDatacenter string = "kVirtualDatacenter"

	// VMwareProtectionSourceTypeKCatalog captures enum value "kCatalog"
	VMwareProtectionSourceTypeKCatalog string = "kCatalog"

	// VMwareProtectionSourceTypeKOrgMetadata captures enum value "kOrgMetadata"
	VMwareProtectionSourceTypeKOrgMetadata string = "kOrgMetadata"

	// VMwareProtectionSourceTypeKStoragePolicy captures enum value "kStoragePolicy"
	VMwareProtectionSourceTypeKStoragePolicy string = "kStoragePolicy"
)

// prop value enum
func (m *VMwareProtectionSource) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vMwareProtectionSourceTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VMwareProtectionSource) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *VMwareProtectionSource) validateVCloudDirectorInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VCloudDirectorInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.VCloudDirectorInfo); i++ {
		if swag.IsZero(m.VCloudDirectorInfo[i]) { // not required
			continue
		}

		if m.VCloudDirectorInfo[i] != nil {
			if err := m.VCloudDirectorInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vCloudDirectorInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vCloudDirectorInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) validateVirtualDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.VirtualDisks) { // not required
		return nil
	}

	for i := 0; i < len(m.VirtualDisks); i++ {
		if swag.IsZero(m.VirtualDisks[i]) { // not required
			continue
		}

		if m.VirtualDisks[i] != nil {
			if err := m.VirtualDisks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) validateVMLinkingInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VMLinkingInfo) { // not required
		return nil
	}

	if m.VMLinkingInfo != nil {
		if err := m.VMLinkingInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vmLinkingInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vmLinkingInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this v mware protection source based on the context it is used
func (m *VMwareProtectionSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAgents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCdpInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDatastoreInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTagAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVCloudDirectorInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVirtualDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVMLinkingInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VMwareProtectionSource) contextValidateAgents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Agents); i++ {

		if m.Agents[i] != nil {

			if swag.IsZero(m.Agents[i]) { // not required
				return nil
			}

			if err := m.Agents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("agents" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("agents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateCdpInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CdpInfo != nil {

		if swag.IsZero(m.CdpInfo) { // not required
			return nil
		}

		if err := m.CdpInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cdpInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cdpInfo")
			}
			return err
		}
	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateDatastoreInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.DatastoreInfo != nil {

		if swag.IsZero(m.DatastoreInfo) { // not required
			return nil
		}

		if err := m.DatastoreInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("datastoreInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("datastoreInfo")
			}
			return err
		}
	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if m.ID != nil {

		if swag.IsZero(m.ID) { // not required
			return nil
		}

		if err := m.ID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("id")
			}
			return err
		}
	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateIPDetails(ctx context.Context, formats strfmt.Registry) error {

	if m.IPDetails != nil {

		if swag.IsZero(m.IPDetails) { // not required
			return nil
		}

		if err := m.IPDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ipDetails")
			}
			return err
		}
	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateTagAttributes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TagAttributes); i++ {

		if m.TagAttributes[i] != nil {

			if swag.IsZero(m.TagAttributes[i]) { // not required
				return nil
			}

			if err := m.TagAttributes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("tagAttributes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateVCloudDirectorInfo(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VCloudDirectorInfo); i++ {

		if m.VCloudDirectorInfo[i] != nil {

			if swag.IsZero(m.VCloudDirectorInfo[i]) { // not required
				return nil
			}

			if err := m.VCloudDirectorInfo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vCloudDirectorInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vCloudDirectorInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateVirtualDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VirtualDisks); i++ {

		if m.VirtualDisks[i] != nil {

			if swag.IsZero(m.VirtualDisks[i]) { // not required
				return nil
			}

			if err := m.VirtualDisks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("virtualDisks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VMwareProtectionSource) contextValidateVMLinkingInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.VMLinkingInfo != nil {

		if swag.IsZero(m.VMLinkingInfo) { // not required
			return nil
		}

		if err := m.VMLinkingInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vmLinkingInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vmLinkingInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VMwareProtectionSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VMwareProtectionSource) UnmarshalBinary(b []byte) error {
	var res VMwareProtectionSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
