// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// BackupJobProto backup job proto
//
// swagger:model BackupJobProto
type BackupJobProto struct {

	// NOTE: Atmost one of abort_in_exclusion_window and pause_in_blackout_window
	// will be set to true.
	// This field determines whether a backup run should be aborted when it hits
	// an exclusion window (assuming that it was started earlier when it was not
	// in an exclusion window).
	AbortInExclusionWindow *bool `json:"abortInExclusionWindow,omitempty"`

	// Determines the alerting policy for jobs.
	AlertingPolicy *AlertingPolicyProto `json:"alertingPolicy,omitempty"`

	// If job deletion status is kDeleteJobAndBackups and this field is set to
	// true, then it  implies that expiration requests for all archival snapshots
	// of this job (if any) have been acknowledged by Icebox.
	// NOTE: This field may remain false for some period of time even if
	// is_deleted field is set to true for the job.
	AllArchivalSnapshotsExpired *bool `json:"allArchivalSnapshotsExpired,omitempty"`

	// Indicates that all the internal replication views have been deleted.
	AllInternalReplicationViewsDeleted *bool `json:"allInternalReplicationViewsDeleted,omitempty"`

	// Denotes whether for this host based backup jobs we allow parallel runs or
	// not. This is only supported by VMware adapter.
	AllowParallelRuns *bool `json:"allowParallelRuns,omitempty"`

	// The backup QoS principal to use for the backup job.
	BackupQosPrincipal *int32 `json:"backupQosPrincipal,omitempty"`

	// This contains additional backup params that are applicable to sources
	// that are captured as part of the backup job.
	// NOTE: The sources could point to higher level entities (such as a
	// "Cluster" in VMware environment), but the source params captured here
	// will not be for the matching higher level entity, but instead be for
	// leaf-level entities (such as VMs).
	BackupSourceParams []*BackupSourceParams `json:"backupSourceParams"`

	// Post backup script associated with the backup job for cloud based
	// backups. (AWS, Azure, GCP)
	CloudPostBackupScript *CloudBackupJobPreOrPostScript `json:"cloudPostBackupScript,omitempty"`

	// Post Snapshot script associated with the backup job for cloud
	// based backups. (AWS, Azure, GCP)
	CloudPostSnapshotScript *CloudBackupJobPreOrPostScript `json:"cloudPostSnapshotScript,omitempty"`

	// Pre backup script associated with the backup job for cloud based
	// backups. (AWS, Azure, GCP)
	CloudPreBackupScript *CloudBackupJobPreOrPostScript `json:"cloudPreBackupScript,omitempty"`

	// Common Backup Configuration Parameters
	ConfigVec []*ConfigurationParams `json:"configVec"`

	// Whether to continue backing up on quiesce failure.
	ContinueOnQuiesceFailure *bool `json:"continueOnQuiesceFailure,omitempty"`

	// If set to false, a remote view will not be created.
	// If set to true and:
	// 1) Remote view name is not provided by the user, a remote view is created
	// with the same name as source view name.
	// 2) Remote view name is provided by the user, a remote view is created with
	// the given name.
	// NOTE: From 6.6 onwards, remote view is always created for view backups if
	// policy has replication. Hence, this bool is only used for Remote Adapter
	// jobs (kPuppeteer).
	CreateRemoteView *bool `json:"createRemoteView,omitempty"`

	// This will contain the details of network used in transferring the data
	// from source account to Cohesity cluster.
	//
	// Currently it is being used for Azure Native Backups.
	DataTransferInfo *DataTransferInfo `json:"dataTransferInfo,omitempty"`

	// List of source ids for which source side dedup is disabled from the backup
	// job.
	DedupDisabledSourceIDVec []int64 `json:"dedupDisabledSourceIdVec"`

	// Determines if the job (and associated backups) should be deleted. Once a
	// job has been deleted, its status cannot be changed.
	DeletionStatus *int32 `json:"deletionStatus,omitempty"`

	// Job description (as entered by the user).
	Description *string `json:"description,omitempty"`

	// dr to cloud params
	DrToCloudParams *BackupJobProtoDRToCloudParams `json:"drToCloudParams,omitempty"`

	// The parent source in entity hierarchy. This may be set for environments
	// such as SQL and Oracle, where the 'parent_source' may be a SQL/Oracle
	// root container, while the real parent source in entity hierarchy might be
	// a Physical container or a vCenter.
	//
	// We need to send this to the Rx cluster via Replication or Remote restore
	// to generate entity mappings correctly.
	//
	// NOTE: This field is set only by Magneto.
	EhParentSource *EntityProto `json:"ehParentSource,omitempty"`

	// The time (in usecs) after which no backup for the job should be scheduled.
	EndTimeUsecs *int64 `json:"endTimeUsecs,omitempty"`

	// Job level additional environment specific backup params. If this is not
	// specified, we will take default actions (for example for NAS environments,
	// we will backup all objects within the source).
	EnvBackupParams *EnvBackupParams `json:"envBackupParams,omitempty"`

	// The list of sources to exclude from backups. These can have non-leaf-level
	// entities, but it's up to the creator to ensure that a child of these
	// sources hasn't been explicitly added to 'sources'.
	ExcludeSources []*BackupJobProtoExcludeSource `json:"excludeSources"`

	// The list of sources to exclude from backups. These can have non-leaf-level
	// entities, but it's up to the creator to ensure that a child of these
	// sources hasn't been explicitly added to 'sources'.
	ExcludeSourcesDEPRECATED []*EntityProto `json:"excludeSources_DEPRECATED"`

	// Do not run backups in these time-ranges.
	ExclusionRanges []*BackupJobProtoExclusionTimeRange `json:"exclusionRanges"`

	// Determines how often full backups should be run.
	FullBackupJobPolicy *JobPolicyProto `json:"fullBackupJobPolicy,omitempty"`

	// Same as 'sla_time_mins' above, but applies to full backups.
	// NOTE: This value is considered only for full backups that are excepted
	// i.e either scheduled or the first full backup and not for full backups
	// that happen as a result of incremental backup failure.
	FullBackupSLATimeMins *int64 `json:"fullBackupSlaTimeMins,omitempty"`

	// Determines global include and exclude filters which are applied to all
	// sources in a physical job.
	GlobalIncludeExclude *PhysicalFileBackupParamsGlobalIncludeExclude `json:"globalIncludeExclude,omitempty"`

	// Specifies the list of errors, that should not be persisted in error_db
	IgnorableErrorsInErrorDb []*ErrorProto `json:"ignorableErrorsInErrorDb"`

	// Determines the indexing policy (in Yoda) for objects backed up by this
	// job.
	IndexingPolicy *IndexingPolicyProto `json:"indexingPolicy,omitempty"`

	// Whether the backup job is active or not. Details about what an active job
	// is can be found here: https://goo.gl/1mLvS3.
	IsActive *bool `json:"isActive,omitempty"`

	// If set to true and backup job policy has CDP parameters as well as
	// snapshot replication target policy is specified then data is synchronously
	// replicated to the replication target through Atom service.
	IsCdpSyncReplicationEnabled *bool `json:"isCdpSyncReplicationEnabled,omitempty"`

	// Denotes whether the backup job is CloudArchiveDirect (excluding NAS direct
	// archive in native format). NAS direct archive jobs in native format can be
	// identified by checking for the 'is_direct_archive_enabled' field.
	IsCloudArchiveDirect *bool `json:"isCloudArchiveDirect,omitempty"`

	// Indicates if Magneto should continue taking source snapshots even if there
	// is a pending run.
	IsContinuousSnapshottingEnabled *bool `json:"isContinuousSnapshottingEnabled,omitempty"`

	// Tracks whether the backup job has actually been deleted.
	// NOTE: If job deletion status is kDeleteJobAndBackups and this field is
	// true, then it only implies that all local snapshots have been deleted.
	// Status of whether all archival snapshots have been expired can be inferred
	// through 'all_archival_snapshots_expired' field.
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// This field is set to true if this is a direct archive backup job.
	IsDirectArchiveEnabled *bool `json:"isDirectArchiveEnabled,omitempty"`

	// This field is set to true if native format should be used for archiving.
	// Applicable for only direct archive jobs.
	IsDirectArchiveNativeFormatEnabled *bool `json:"isDirectArchiveNativeFormatEnabled,omitempty"`

	// Whether the backup job is an internal job. These jobs are hidden from the
	// user, and are created internally.
	IsInternal *bool `json:"isInternal,omitempty"`

	// Whether the backup job is paused. New backup runs are not scheduled for
	// the paused backup job. Active run of a backup job (if any) is not
	// impacted.
	IsPaused *bool `json:"isPaused,omitempty"`

	// Whether the backup job is an RPO policy job. These jobs are hidden from
	// the user, and are created internally to have a backup schedule for the
	// given source.
	IsRpoJob *bool `json:"isRpoJob,omitempty"`

	// A map from entity id of the source to whether the source backup is paused.
	IsSourcePausedMap interface{} `json:"isSourcePausedMap,omitempty"`

	// Time when this job was first created.
	JobCreationTimeUsecs *int64 `json:"jobCreationTimeUsecs,omitempty"`

	// A unique id for locally created jobs. This should only be used to identify
	// jobs created on the local cluster. When Iris communicates with Magneto,
	// Iris can continue to use this job_id field, which will always be assumed
	// to refer to locally created jobs.
	//
	// For remotely created jobs, the 'job_uid' field should be used. The only
	// time Iris should ever need to refer to a remote job is when restoring an
	// object from a remote snapshot. In all such cases, Iris should use the
	// job_uid field.
	JobID *int64 `json:"jobId,omitempty"`

	// Determines how often the job should run and how long the snapshots of the
	// job should be retained at various targets.
	JobPolicy *JobPolicyProto `json:"jobPolicy,omitempty"`

	// The globally unique id of the job.
	JobUID *UniversalIDProto `json:"jobUid,omitempty"`

	// Time when this job description was last updated.
	LastModificationTimeUsecs *int64 `json:"lastModificationTimeUsecs,omitempty"`

	// Time when the job was last paused or unpaused.
	LastPauseModificationTimeUsecs *int64 `json:"lastPauseModificationTimeUsecs,omitempty"`

	// Last reason for pausing the backup job. Capturing the reason will help in
	// resuming only the jobs that were paused because of a reason once the
	// reason for pausing is not applicable.
	LastPauseReason *int32 `json:"lastPauseReason,omitempty"`

	// Time when this job description was last updated.
	LastStartTimeModificationTimeUsecs *int64 `json:"lastStartTimeModificationTimeUsecs,omitempty"`

	// The user who modified the job most recently.
	LastUpdatedUsername *string `json:"lastUpdatedUsername,omitempty"`

	// This is set to true by the user if nutanix snapshot is requested
	// This is applicable in case if the vcenter in question is registered as a
	// management server on a prism endpoint. This flag will be ignored at the
	// backend if it is not feasible to leverage nutanix snapshot.
	LeverageNutanixSnapshots *bool `json:"leverageNutanixSnapshots,omitempty"`

	// This is set to true by the user in order to backup the objects via a
	// dedicated storage area network (SAN), as opposed to transport via LAN or
	// management network.
	// NOTE: Not all adapters support this method. Currently only VMware.
	LeverageSanTransport *bool `json:"leverageSanTransport,omitempty"`

	// Whether to leverage the storage array based snapshots for this backup
	// job. To leverage storage snapshots, the storage array has to be registered
	// as a source. If storage based snapshots can not be taken, job will
	// fallback to the default backup method.
	// NOTE: This will be set for Pure snapshots.
	LeverageStorageSnapshots *bool `json:"leverageStorageSnapshots,omitempty"`

	// This is set to true by the user if hyperflex snapshots are requested
	// NOTE: If this is set to true, then leverage_storage_snapshots above should
	// be false.
	LeverageStorageSnapshotsForHyperflex *bool `json:"leverageStorageSnapshotsForHyperflex,omitempty"`

	// Determines how often log backups should be run (for SQL jobs).
	LogBackupJobPolicy *JobPolicyProto `json:"logBackupJobPolicy,omitempty"`

	// Same as 'sla_time_mins' above, but applies to log backups.
	LogBackupSLATimeMins *int64 `json:"logBackupSlaTimeMins,omitempty"`

	// Determines the maximum number of source snapshots allowed for a given
	// entity in the job. This is only applicable if
	// 'is_continuous_snapshotting_enabled' is set to true.
	MaxAllowedSourceSnapshots *int32 `json:"maxAllowedSourceSnapshots,omitempty"`

	// The name of this backup job. This must be unique across all jobs.
	Name *string `json:"name,omitempty"`

	// Specifies how many recent snapshots of each backed up entity to retain on
	// the primary environment. If not specified, then snapshots will not be
	// be deleted from the primary environment.
	// NOTE: This is only applicable for certain environments like kPure.
	NumSnapshotsToKeepOnPrimary *int64 `json:"numSnapshotsToKeepOnPrimary,omitempty"`

	// The universal Id of the ObjectBackupSpecification which is used by this
	// backup job.This is relavent only for internal jobs.
	ObjectBackupSpecUID *UniversalIDProto `json:"objectBackupSpecUid,omitempty"`

	// The registered source managing all the sources being backed up. This field
	// is optional.
	ParentSource *EntityProto `json:"parentSource,omitempty"`

	// This field determines whether a backup run should be paused when it hits
	// a blackout window (assuming that it was started earlier when it was not
	// in an blackout window). The backup run will get resumed when the blackout
	// period ends.
	PauseInBlackoutWindow *bool `json:"pauseInBlackoutWindow,omitempty"`

	// Whether or not to perform source side dedup.
	PerformBrickBasedDedup *bool `json:"performBrickBasedDedup,omitempty"`

	// Whether or not to perform source side dedup.
	PerformSourceSideDedup *bool `json:"performSourceSideDedup,omitempty"`

	// Epoch time in milliseconds when the policy was last applied to this job.
	// This field will be used to determine whether a policy has changed after
	// it was applied to a particular job.
	PolicyAppliedTimeMsecs *int64 `json:"policyAppliedTimeMsecs,omitempty"`

	// Id of the policy being applied to the backup job. It is expected to be of
	// the form "cluster_id:cluster_instance_id:local_identifier".
	PolicyID *string `json:"policyId,omitempty"`

	// The name of the policy referred to by policy_uid. This field can be stale
	// and should not be relied upon for the latest name.
	PolicyName *string `json:"policyName,omitempty"`

	// Post backup script associated with the backup job.
	PostBackupScript *BackupJobPreOrPostScript `json:"postBackupScript,omitempty"`

	// Post snapshot script associated with the backup job.
	PostSnapshotScript *BackupJobPreOrPostScript `json:"postSnapshotScript,omitempty"`

	// Pre script associated with the backup job. This field must be specified
	// for 'kPuppeteer' job.
	PreScript *BackupJobPreOrPostScript `json:"preScript,omitempty"`

	// The globally unique id of the original remote job from which this job was
	// derived.
	PrimaryJobUID *UniversalIDProto `json:"primaryJobUid,omitempty"`

	// The priority for the job. This is used at admission time - all admitted
	// jobs are treated equally. This is also used to determine the Madrox
	// replication priority.
	Priority *int32 `json:"priority,omitempty"`

	// Whether to take app-consistent snapshots by quiescing apps and the
	// filesystem before taking a backup.
	Quiesce *bool `json:"quiesce,omitempty"`

	// The globally unique ids of all remote jobs that are linked to this job
	// (because of incoming replications). This field will only be populated for
	// locally created jobs. This field is populated only for the local(stub) job
	// during incoming replications. In the most common case of one cluster
	// replicating to another, this field will only have one entry (which is the
	// id of the job on Tx side) and matches the primary_job_uid.
	// This will have multiple entries in the following situation:
	// A->B, A->C replication.
	// The backup is failed over to B, and B now starts replicating to C.
	// In this case, the stub job at C will have two entries. One is the job
	// id from cluster A, and another is the local(stub) job uid from B.
	// Also note that since the job originated from A, primary_job_uid for
	// all the replicated instances of this job across multiple clusters will
	// remain the same (which is equal to the job id from the original cluster
	// A).
	RemoteJobUids []*UniversalIDProto `json:"remoteJobUids"`

	// A human readable name of the remote view. A remote view is created with
	// name overwriting the latest snapshot.
	// NOTE: From 6.6 onwards, we support protecting multiple views within a
	// protection group, 'remote_view_params' is the new field which captures
	// this information for view backups, 'remote_view_name' here is now only
	// used for Remote Adapter jobs (kPuppeteer).
	RemoteViewName *string `json:"remoteViewName,omitempty"`

	// remote view params
	RemoteViewParams *BackupJobProtoRemoteViewParams `json:"remoteViewParams,omitempty"`

	// The features that are strictly required to be supported by the cluster
	// of the backup job. This is currently used in the following cases:
	// 1. Tx cluster looks at the Rx cluster's supported features and replicates
	// the backup job only if all the features captured here are supported.
	// 2. When performing remote restore of a backup job from an archival, this
	// job will be retrieved only if the cluster supports all the features
	// listed here.
	RequiredFeatureVec []string `json:"requiredFeatureVec"`

	// Whether to skip Rigel for backup or not. This field is applicable only for
	// DMaaS. This field is currently being used in DRaaS workflows only.
	SkipRigelForBackup *bool `json:"skipRigelForBackup,omitempty"`

	// If set to true, skips tenant related validations. Default is false.
	SkipTenantValidations *bool `json:"skipTenantValidations,omitempty"`

	// If specified, this variable determines the amount of time (after backup
	// has started) in which backup is expected to finish for this job. An SLA
	// violation is counted against this job if the amount of time taken exceeds
	// this amount.
	SLATimeMins *int64 `json:"slaTimeMins,omitempty"`

	// Determines include and exclude filters which are applied to entities in
	// a backup source. For SQL, this will be applicable only for auto protect
	// sources.
	SourceFilters *SourceFilters `json:"sourceFilters,omitempty"`

	// The list of sources that should be backed up. A source in this list could
	// be a descendant of another source in the list (this will be used when
	// specifying override backup schedules).
	Sources []*BackupJobProtoBackupSource `json:"sources"`

	// User provided resource(s) for creating a standby VM for each entity
	// present in this backup job. For example in case of VMware, the user will
	// provide the vCenter, datastore and resource pool on which the standby VM
	// should be created.
	// TODO(hmehra) Can the user edit this after the job is created or the
	// resources have been specified?
	StandbyResourceVec []*StandbyResource `json:"standbyResourceVec"`

	// The time when the backup runs for the job should start. This is only
	// applicable if the policy for the job has a daily or monthly schedule.
	StartTime *Time `json:"startTime,omitempty"`

	// Whether this backup job has a policy for storage array snapshot based
	// backups.
	StorageArraySnapshot *bool `json:"storageArraySnapshot,omitempty"`

	// Scheduling and retention policy for stubbing jobs.
	StubbingPolicy *StubbingPolicyProto `json:"stubbingPolicy,omitempty"`

	// Tags associated with the job. User can specify tags/keywords that can
	// indexed by Yoda and can be later searched in UI. For example, user can
	// create a 'kPuppeteer' job to backup Oracle DB for 'payroll' department.
	// User can specify following tags: 'payroll', 'Oracle_DB'.
	TagVec []string `json:"tagVec"`

	// This is a vector of timeouts, for different backup
	// types(kFull, kRegular). A cancellation will automatically gets triggered
	// if the backup tasks inside a run has been running for more than this
	// timeout duration.
	TaskTimeoutVec []*CancellationTimeout `json:"taskTimeoutVec"`

	// Timezone of the backup job. All time fields (i.e., TimeOfDay) in this
	// backup job are stored wrt to this timezone.
	//
	// The time zones have unique names of the form "Area/Location",
	// e.g. "America/New_York". We are using "America/Los_Angeles" as a default
	// value so as to be backward compatible with pre-2.7 code.
	Timezone *string `json:"timezone,omitempty"`

	// Whether to truncate logs after a backup run. This is currently only
	// relevant for full or incremental backups in a SQL environment.
	TruncateLogs *bool `json:"truncateLogs,omitempty"`

	// The type of environment this backup job corresponds to.
	Type *int32 `json:"type,omitempty"`

	// Information if any about the user that owns this job.
	UserInfo *UserInformation `json:"userInfo,omitempty"`

	// The view box to which data will be written.
	ViewBoxID *int64 `json:"viewBoxId,omitempty"`
}

// Validate validates this backup job proto
func (m *BackupJobProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupSourceParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudPostBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudPostSnapshotScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudPreBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataTransferInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrToCloudParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEhParentSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvBackupParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludeSourcesDEPRECATED(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExclusionRanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFullBackupJobPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlobalIncludeExclude(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgnorableErrorsInErrorDb(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJobPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogBackupJobPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectBackupSpecUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParentSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostBackupScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostSnapshotScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteJobUids(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteViewParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStandbyResourceVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStubbingPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskTimeoutVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobProto) validateAlertingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertingPolicy) { // not required
		return nil
	}

	if m.AlertingPolicy != nil {
		if err := m.AlertingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateBackupSourceParams(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupSourceParams) { // not required
		return nil
	}

	for i := 0; i < len(m.BackupSourceParams); i++ {
		if swag.IsZero(m.BackupSourceParams[i]) { // not required
			continue
		}

		if m.BackupSourceParams[i] != nil {
			if err := m.BackupSourceParams[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backupSourceParams" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backupSourceParams" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateCloudPostBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudPostBackupScript) { // not required
		return nil
	}

	if m.CloudPostBackupScript != nil {
		if err := m.CloudPostBackupScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudPostBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudPostBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateCloudPostSnapshotScript(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudPostSnapshotScript) { // not required
		return nil
	}

	if m.CloudPostSnapshotScript != nil {
		if err := m.CloudPostSnapshotScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudPostSnapshotScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudPostSnapshotScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateCloudPreBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudPreBackupScript) { // not required
		return nil
	}

	if m.CloudPreBackupScript != nil {
		if err := m.CloudPreBackupScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudPreBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudPreBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateConfigVec(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigVec) { // not required
		return nil
	}

	for i := 0; i < len(m.ConfigVec); i++ {
		if swag.IsZero(m.ConfigVec[i]) { // not required
			continue
		}

		if m.ConfigVec[i] != nil {
			if err := m.ConfigVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("configVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateDataTransferInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.DataTransferInfo) { // not required
		return nil
	}

	if m.DataTransferInfo != nil {
		if err := m.DataTransferInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataTransferInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataTransferInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateDrToCloudParams(formats strfmt.Registry) error {
	if swag.IsZero(m.DrToCloudParams) { // not required
		return nil
	}

	if m.DrToCloudParams != nil {
		if err := m.DrToCloudParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drToCloudParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("drToCloudParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateEhParentSource(formats strfmt.Registry) error {
	if swag.IsZero(m.EhParentSource) { // not required
		return nil
	}

	if m.EhParentSource != nil {
		if err := m.EhParentSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ehParentSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ehParentSource")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateEnvBackupParams(formats strfmt.Registry) error {
	if swag.IsZero(m.EnvBackupParams) { // not required
		return nil
	}

	if m.EnvBackupParams != nil {
		if err := m.EnvBackupParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("envBackupParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("envBackupParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateExcludeSources(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeSources) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludeSources); i++ {
		if swag.IsZero(m.ExcludeSources[i]) { // not required
			continue
		}

		if m.ExcludeSources[i] != nil {
			if err := m.ExcludeSources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateExcludeSourcesDEPRECATED(formats strfmt.Registry) error {
	if swag.IsZero(m.ExcludeSourcesDEPRECATED) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludeSourcesDEPRECATED); i++ {
		if swag.IsZero(m.ExcludeSourcesDEPRECATED[i]) { // not required
			continue
		}

		if m.ExcludeSourcesDEPRECATED[i] != nil {
			if err := m.ExcludeSourcesDEPRECATED[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateExclusionRanges(formats strfmt.Registry) error {
	if swag.IsZero(m.ExclusionRanges) { // not required
		return nil
	}

	for i := 0; i < len(m.ExclusionRanges); i++ {
		if swag.IsZero(m.ExclusionRanges[i]) { // not required
			continue
		}

		if m.ExclusionRanges[i] != nil {
			if err := m.ExclusionRanges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exclusionRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exclusionRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateFullBackupJobPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.FullBackupJobPolicy) { // not required
		return nil
	}

	if m.FullBackupJobPolicy != nil {
		if err := m.FullBackupJobPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fullBackupJobPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fullBackupJobPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateGlobalIncludeExclude(formats strfmt.Registry) error {
	if swag.IsZero(m.GlobalIncludeExclude) { // not required
		return nil
	}

	if m.GlobalIncludeExclude != nil {
		if err := m.GlobalIncludeExclude.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("globalIncludeExclude")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("globalIncludeExclude")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateIgnorableErrorsInErrorDb(formats strfmt.Registry) error {
	if swag.IsZero(m.IgnorableErrorsInErrorDb) { // not required
		return nil
	}

	for i := 0; i < len(m.IgnorableErrorsInErrorDb); i++ {
		if swag.IsZero(m.IgnorableErrorsInErrorDb[i]) { // not required
			continue
		}

		if m.IgnorableErrorsInErrorDb[i] != nil {
			if err := m.IgnorableErrorsInErrorDb[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateIndexingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IndexingPolicy) { // not required
		return nil
	}

	if m.IndexingPolicy != nil {
		if err := m.IndexingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateJobPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.JobPolicy) { // not required
		return nil
	}

	if m.JobPolicy != nil {
		if err := m.JobPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.JobUID) { // not required
		return nil
	}

	if m.JobUID != nil {
		if err := m.JobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateLogBackupJobPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.LogBackupJobPolicy) { // not required
		return nil
	}

	if m.LogBackupJobPolicy != nil {
		if err := m.LogBackupJobPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logBackupJobPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logBackupJobPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateObjectBackupSpecUID(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectBackupSpecUID) { // not required
		return nil
	}

	if m.ObjectBackupSpecUID != nil {
		if err := m.ObjectBackupSpecUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("objectBackupSpecUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("objectBackupSpecUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateParentSource(formats strfmt.Registry) error {
	if swag.IsZero(m.ParentSource) { // not required
		return nil
	}

	if m.ParentSource != nil {
		if err := m.ParentSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parentSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parentSource")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validatePostBackupScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PostBackupScript) { // not required
		return nil
	}

	if m.PostBackupScript != nil {
		if err := m.PostBackupScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validatePostSnapshotScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PostSnapshotScript) { // not required
		return nil
	}

	if m.PostSnapshotScript != nil {
		if err := m.PostSnapshotScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postSnapshotScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postSnapshotScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validatePreScript(formats strfmt.Registry) error {
	if swag.IsZero(m.PreScript) { // not required
		return nil
	}

	if m.PreScript != nil {
		if err := m.PreScript.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("preScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("preScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validatePrimaryJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.PrimaryJobUID) { // not required
		return nil
	}

	if m.PrimaryJobUID != nil {
		if err := m.PrimaryJobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryJobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("primaryJobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateRemoteJobUids(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteJobUids) { // not required
		return nil
	}

	for i := 0; i < len(m.RemoteJobUids); i++ {
		if swag.IsZero(m.RemoteJobUids[i]) { // not required
			continue
		}

		if m.RemoteJobUids[i] != nil {
			if err := m.RemoteJobUids[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("remoteJobUids" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("remoteJobUids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateRemoteViewParams(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteViewParams) { // not required
		return nil
	}

	if m.RemoteViewParams != nil {
		if err := m.RemoteViewParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteViewParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteViewParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateSourceFilters(formats strfmt.Registry) error {
	if swag.IsZero(m.SourceFilters) { // not required
		return nil
	}

	if m.SourceFilters != nil {
		if err := m.SourceFilters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceFilters")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateSources(formats strfmt.Registry) error {
	if swag.IsZero(m.Sources) { // not required
		return nil
	}

	for i := 0; i < len(m.Sources); i++ {
		if swag.IsZero(m.Sources[i]) { // not required
			continue
		}

		if m.Sources[i] != nil {
			if err := m.Sources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateStandbyResourceVec(formats strfmt.Registry) error {
	if swag.IsZero(m.StandbyResourceVec) { // not required
		return nil
	}

	for i := 0; i < len(m.StandbyResourceVec); i++ {
		if swag.IsZero(m.StandbyResourceVec[i]) { // not required
			continue
		}

		if m.StandbyResourceVec[i] != nil {
			if err := m.StandbyResourceVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("standbyResourceVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("standbyResourceVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if m.StartTime != nil {
		if err := m.StartTime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("startTime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("startTime")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateStubbingPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.StubbingPolicy) { // not required
		return nil
	}

	if m.StubbingPolicy != nil {
		if err := m.StubbingPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stubbingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stubbingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) validateTaskTimeoutVec(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskTimeoutVec) { // not required
		return nil
	}

	for i := 0; i < len(m.TaskTimeoutVec); i++ {
		if swag.IsZero(m.TaskTimeoutVec[i]) { // not required
			continue
		}

		if m.TaskTimeoutVec[i] != nil {
			if err := m.TaskTimeoutVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) validateUserInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.UserInfo) { // not required
		return nil
	}

	if m.UserInfo != nil {
		if err := m.UserInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("userInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("userInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup job proto based on the context it is used
func (m *BackupJobProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAlertingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupSourceParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudPostBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudPostSnapshotScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudPreBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataTransferInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrToCloudParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEhParentSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnvBackupParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludeSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludeSourcesDEPRECATED(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExclusionRanges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFullBackupJobPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlobalIncludeExclude(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIgnorableErrorsInErrorDb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIndexingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJobPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogBackupJobPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectBackupSpecUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateParentSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePostBackupScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePostSnapshotScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePreScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrimaryJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteJobUids(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteViewParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSourceFilters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStandbyResourceVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStubbingPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaskTimeoutVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobProto) contextValidateAlertingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.AlertingPolicy != nil {

		if swag.IsZero(m.AlertingPolicy) { // not required
			return nil
		}

		if err := m.AlertingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("alertingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("alertingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateBackupSourceParams(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BackupSourceParams); i++ {

		if m.BackupSourceParams[i] != nil {

			if swag.IsZero(m.BackupSourceParams[i]) { // not required
				return nil
			}

			if err := m.BackupSourceParams[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backupSourceParams" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backupSourceParams" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateCloudPostBackupScript(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudPostBackupScript != nil {

		if swag.IsZero(m.CloudPostBackupScript) { // not required
			return nil
		}

		if err := m.CloudPostBackupScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudPostBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudPostBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateCloudPostSnapshotScript(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudPostSnapshotScript != nil {

		if swag.IsZero(m.CloudPostSnapshotScript) { // not required
			return nil
		}

		if err := m.CloudPostSnapshotScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudPostSnapshotScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudPostSnapshotScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateCloudPreBackupScript(ctx context.Context, formats strfmt.Registry) error {

	if m.CloudPreBackupScript != nil {

		if swag.IsZero(m.CloudPreBackupScript) { // not required
			return nil
		}

		if err := m.CloudPreBackupScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudPreBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cloudPreBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateConfigVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ConfigVec); i++ {

		if m.ConfigVec[i] != nil {

			if swag.IsZero(m.ConfigVec[i]) { // not required
				return nil
			}

			if err := m.ConfigVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("configVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateDataTransferInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.DataTransferInfo != nil {

		if swag.IsZero(m.DataTransferInfo) { // not required
			return nil
		}

		if err := m.DataTransferInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dataTransferInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dataTransferInfo")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateDrToCloudParams(ctx context.Context, formats strfmt.Registry) error {

	if m.DrToCloudParams != nil {

		if swag.IsZero(m.DrToCloudParams) { // not required
			return nil
		}

		if err := m.DrToCloudParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drToCloudParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("drToCloudParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateEhParentSource(ctx context.Context, formats strfmt.Registry) error {

	if m.EhParentSource != nil {

		if swag.IsZero(m.EhParentSource) { // not required
			return nil
		}

		if err := m.EhParentSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ehParentSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ehParentSource")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateEnvBackupParams(ctx context.Context, formats strfmt.Registry) error {

	if m.EnvBackupParams != nil {

		if swag.IsZero(m.EnvBackupParams) { // not required
			return nil
		}

		if err := m.EnvBackupParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("envBackupParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("envBackupParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateExcludeSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludeSources); i++ {

		if m.ExcludeSources[i] != nil {

			if swag.IsZero(m.ExcludeSources[i]) { // not required
				return nil
			}

			if err := m.ExcludeSources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateExcludeSourcesDEPRECATED(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludeSourcesDEPRECATED); i++ {

		if m.ExcludeSourcesDEPRECATED[i] != nil {

			if swag.IsZero(m.ExcludeSourcesDEPRECATED[i]) { // not required
				return nil
			}

			if err := m.ExcludeSourcesDEPRECATED[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("excludeSources_DEPRECATED" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateExclusionRanges(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExclusionRanges); i++ {

		if m.ExclusionRanges[i] != nil {

			if swag.IsZero(m.ExclusionRanges[i]) { // not required
				return nil
			}

			if err := m.ExclusionRanges[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exclusionRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exclusionRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateFullBackupJobPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.FullBackupJobPolicy != nil {

		if swag.IsZero(m.FullBackupJobPolicy) { // not required
			return nil
		}

		if err := m.FullBackupJobPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fullBackupJobPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fullBackupJobPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateGlobalIncludeExclude(ctx context.Context, formats strfmt.Registry) error {

	if m.GlobalIncludeExclude != nil {

		if swag.IsZero(m.GlobalIncludeExclude) { // not required
			return nil
		}

		if err := m.GlobalIncludeExclude.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("globalIncludeExclude")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("globalIncludeExclude")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateIgnorableErrorsInErrorDb(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IgnorableErrorsInErrorDb); i++ {

		if m.IgnorableErrorsInErrorDb[i] != nil {

			if swag.IsZero(m.IgnorableErrorsInErrorDb[i]) { // not required
				return nil
			}

			if err := m.IgnorableErrorsInErrorDb[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateIndexingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.IndexingPolicy != nil {

		if swag.IsZero(m.IndexingPolicy) { // not required
			return nil
		}

		if err := m.IndexingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("indexingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("indexingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateJobPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.JobPolicy != nil {

		if swag.IsZero(m.JobPolicy) { // not required
			return nil
		}

		if err := m.JobPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.JobUID != nil {

		if swag.IsZero(m.JobUID) { // not required
			return nil
		}

		if err := m.JobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateLogBackupJobPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.LogBackupJobPolicy != nil {

		if swag.IsZero(m.LogBackupJobPolicy) { // not required
			return nil
		}

		if err := m.LogBackupJobPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logBackupJobPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logBackupJobPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateObjectBackupSpecUID(ctx context.Context, formats strfmt.Registry) error {

	if m.ObjectBackupSpecUID != nil {

		if swag.IsZero(m.ObjectBackupSpecUID) { // not required
			return nil
		}

		if err := m.ObjectBackupSpecUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("objectBackupSpecUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("objectBackupSpecUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateParentSource(ctx context.Context, formats strfmt.Registry) error {

	if m.ParentSource != nil {

		if swag.IsZero(m.ParentSource) { // not required
			return nil
		}

		if err := m.ParentSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("parentSource")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("parentSource")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidatePostBackupScript(ctx context.Context, formats strfmt.Registry) error {

	if m.PostBackupScript != nil {

		if swag.IsZero(m.PostBackupScript) { // not required
			return nil
		}

		if err := m.PostBackupScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postBackupScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postBackupScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidatePostSnapshotScript(ctx context.Context, formats strfmt.Registry) error {

	if m.PostSnapshotScript != nil {

		if swag.IsZero(m.PostSnapshotScript) { // not required
			return nil
		}

		if err := m.PostSnapshotScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postSnapshotScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postSnapshotScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidatePreScript(ctx context.Context, formats strfmt.Registry) error {

	if m.PreScript != nil {

		if swag.IsZero(m.PreScript) { // not required
			return nil
		}

		if err := m.PreScript.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("preScript")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("preScript")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidatePrimaryJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.PrimaryJobUID != nil {

		if swag.IsZero(m.PrimaryJobUID) { // not required
			return nil
		}

		if err := m.PrimaryJobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryJobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("primaryJobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateRemoteJobUids(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RemoteJobUids); i++ {

		if m.RemoteJobUids[i] != nil {

			if swag.IsZero(m.RemoteJobUids[i]) { // not required
				return nil
			}

			if err := m.RemoteJobUids[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("remoteJobUids" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("remoteJobUids" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateRemoteViewParams(ctx context.Context, formats strfmt.Registry) error {

	if m.RemoteViewParams != nil {

		if swag.IsZero(m.RemoteViewParams) { // not required
			return nil
		}

		if err := m.RemoteViewParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteViewParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteViewParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateSourceFilters(ctx context.Context, formats strfmt.Registry) error {

	if m.SourceFilters != nil {

		if swag.IsZero(m.SourceFilters) { // not required
			return nil
		}

		if err := m.SourceFilters.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceFilters")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sourceFilters")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Sources); i++ {

		if m.Sources[i] != nil {

			if swag.IsZero(m.Sources[i]) { // not required
				return nil
			}

			if err := m.Sources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateStandbyResourceVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StandbyResourceVec); i++ {

		if m.StandbyResourceVec[i] != nil {

			if swag.IsZero(m.StandbyResourceVec[i]) { // not required
				return nil
			}

			if err := m.StandbyResourceVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("standbyResourceVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("standbyResourceVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateStartTime(ctx context.Context, formats strfmt.Registry) error {

	if m.StartTime != nil {

		if swag.IsZero(m.StartTime) { // not required
			return nil
		}

		if err := m.StartTime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("startTime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("startTime")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateStubbingPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.StubbingPolicy != nil {

		if swag.IsZero(m.StubbingPolicy) { // not required
			return nil
		}

		if err := m.StubbingPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stubbingPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stubbingPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobProto) contextValidateTaskTimeoutVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaskTimeoutVec); i++ {

		if m.TaskTimeoutVec[i] != nil {

			if swag.IsZero(m.TaskTimeoutVec[i]) { // not required
				return nil
			}

			if err := m.TaskTimeoutVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobProto) contextValidateUserInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.UserInfo != nil {

		if swag.IsZero(m.UserInfo) { // not required
			return nil
		}

		if err := m.UserInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("userInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("userInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupJobProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupJobProto) UnmarshalBinary(b []byte) error {
	var res BackupJobProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
