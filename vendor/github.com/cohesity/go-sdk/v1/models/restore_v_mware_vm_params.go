// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RestoreVMwareVMParams This message defines the VMware specific VMs restore params.
//
// swagger:model RestoreVMwareVMParams
type RestoreVMwareVMParams struct {

	// Whether to fallback to use NBDSSL transport for recovery in case using
	// SAN transport recovery fails.
	AllowNbdsslTransportFallback *bool `json:"allowNbdsslTransportFallback,omitempty"`

	// This field is only applicable when overwrite_existing_vm is set to true.
	// If this field is true, as part of overwrite existing vm, differential
	// restore will be attempted.
	AttemptDifferentialRestore *bool `json:"attemptDifferentialRestore,omitempty"`

	// Specifies the name of the catalog for vapp template recovery.
	// This is applicable for recovery to a VCD.
	CatalogUUID *string `json:"catalogUuid,omitempty"`

	// Whether to perform copy recovery instead of instant recovery.
	CopyRecovery *bool `json:"copyRecovery,omitempty"`

	// Datastore entities if the restore is to alternate location.
	DatastoreEntityVec []*EntityProto `json:"datastoreEntityVec"`

	// This specifies vmware virtual disk provisioning policies
	DiskProvisionType *int32 `json:"diskProvisionType,omitempty"`

	// This will be true if this is on prem deploy task.
	// attempt_differential_restore should also be set to true in case of doing
	// on prem deploy.
	IsOnPremDeploy *bool `json:"isOnPremDeploy,omitempty"`

	// Specifies the name of the org VDC network to be used for the recovery.
	// This is applicable for recovery to a VCD.
	OrgVdcNetworkName *string `json:"orgVdcNetworkName,omitempty"`

	// Specifies the VCD UUID of the org VDC network to be used for the recovery.
	// This is applicable for recovery to a VCD.
	OrgVdcNetworkVcdUUID *string `json:"orgVdcNetworkVcdUuid,omitempty"`

	// This option is only potentially populated in the case that there are no
	// rename parameters specified for a recovery. Note that this option is
	// mutually exclusive with power_off_and_rename_existing_vm.
	OverwriteExistingVM *bool `json:"overwriteExistingVm,omitempty"`

	// This option is only potentially populated in the case that there are no
	// rename parameters specified for a recovery. Note that this option is
	// mutually exclusive with overwrite_existing_vm.
	PowerOffAndRenameExistingVM *bool `json:"powerOffAndRenameExistingVm,omitempty"`

	// Whether to preserve custom attributes for the clone op.
	PreserveCustomAttributesDuringClone *bool `json:"preserveCustomAttributesDuringClone,omitempty"`

	// Whether to preserve tags for the clone op.
	PreserveTagsDuringClone *bool `json:"preserveTagsDuringClone,omitempty"`

	// Resource pool entity if the restore is to alternate location.
	ResourcePoolEntity *EntityProto `json:"resourcePoolEntity,omitempty"`

	// This is only populated for VCD restore to alternate location. It contains
	// the name of the destination storage profile.
	StorageProfileName *string `json:"storageProfileName,omitempty"`

	// This is only populated for VCD restore to alternate location. It contains
	// the vcd uuid of the destination storage profile.
	StorageProfileVcdUUID *string `json:"storageProfileVcdUuid,omitempty"`

	// Folder where the restore datastore should be created. This is applicable
	// only when the VMs are being cloned.
	TargetDatastoreFolder *EntityProto `json:"targetDatastoreFolder,omitempty"`

	// Folder where the VMs should be created. This is applicable only when the
	// VMs are being restored to an alternate location or if clone is being
	// performed.
	TargetVMFolder *EntityProto `json:"targetVmFolder,omitempty"`
}

// Validate validates this restore v mware VM params
func (m *RestoreVMwareVMParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDatastoreEntityVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourcePoolEntity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDatastoreFolder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetVMFolder(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestoreVMwareVMParams) validateDatastoreEntityVec(formats strfmt.Registry) error {
	if swag.IsZero(m.DatastoreEntityVec) { // not required
		return nil
	}

	for i := 0; i < len(m.DatastoreEntityVec); i++ {
		if swag.IsZero(m.DatastoreEntityVec[i]) { // not required
			continue
		}

		if m.DatastoreEntityVec[i] != nil {
			if err := m.DatastoreEntityVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datastoreEntityVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("datastoreEntityVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestoreVMwareVMParams) validateResourcePoolEntity(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourcePoolEntity) { // not required
		return nil
	}

	if m.ResourcePoolEntity != nil {
		if err := m.ResourcePoolEntity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resourcePoolEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resourcePoolEntity")
			}
			return err
		}
	}

	return nil
}

func (m *RestoreVMwareVMParams) validateTargetDatastoreFolder(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetDatastoreFolder) { // not required
		return nil
	}

	if m.TargetDatastoreFolder != nil {
		if err := m.TargetDatastoreFolder.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("targetDatastoreFolder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("targetDatastoreFolder")
			}
			return err
		}
	}

	return nil
}

func (m *RestoreVMwareVMParams) validateTargetVMFolder(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetVMFolder) { // not required
		return nil
	}

	if m.TargetVMFolder != nil {
		if err := m.TargetVMFolder.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("targetVmFolder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("targetVmFolder")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this restore v mware VM params based on the context it is used
func (m *RestoreVMwareVMParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDatastoreEntityVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourcePoolEntity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetDatastoreFolder(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetVMFolder(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RestoreVMwareVMParams) contextValidateDatastoreEntityVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DatastoreEntityVec); i++ {

		if m.DatastoreEntityVec[i] != nil {

			if swag.IsZero(m.DatastoreEntityVec[i]) { // not required
				return nil
			}

			if err := m.DatastoreEntityVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("datastoreEntityVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("datastoreEntityVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RestoreVMwareVMParams) contextValidateResourcePoolEntity(ctx context.Context, formats strfmt.Registry) error {

	if m.ResourcePoolEntity != nil {

		if swag.IsZero(m.ResourcePoolEntity) { // not required
			return nil
		}

		if err := m.ResourcePoolEntity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resourcePoolEntity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resourcePoolEntity")
			}
			return err
		}
	}

	return nil
}

func (m *RestoreVMwareVMParams) contextValidateTargetDatastoreFolder(ctx context.Context, formats strfmt.Registry) error {

	if m.TargetDatastoreFolder != nil {

		if swag.IsZero(m.TargetDatastoreFolder) { // not required
			return nil
		}

		if err := m.TargetDatastoreFolder.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("targetDatastoreFolder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("targetDatastoreFolder")
			}
			return err
		}
	}

	return nil
}

func (m *RestoreVMwareVMParams) contextValidateTargetVMFolder(ctx context.Context, formats strfmt.Registry) error {

	if m.TargetVMFolder != nil {

		if swag.IsZero(m.TargetVMFolder) { // not required
			return nil
		}

		if err := m.TargetVMFolder.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("targetVmFolder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("targetVmFolder")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RestoreVMwareVMParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RestoreVMwareVMParams) UnmarshalBinary(b []byte) error {
	var res RestoreVMwareVMParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
