// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// BackupJobRunStateProto This message contains persistent information about a specific backup
// instance run (which could include one or more backup run attempts).
//
// swagger:model BackupJobRunStateProto
type BackupJobRunStateProto struct {

	// If there is an ongoing active attempt, this field contains that attempt.
	ActiveAttempt *BackupJobAttemptStateProto `json:"activeAttempt,omitempty"`

	// Refer to RunBackupJobOnceArg.additional_param_vec for details about how
	// this is used.
	AdditionalParamVec []*BackupTaskAdditionalParams `json:"additionalParamVec"`

	// Additional environment specific information stored at the run level.
	AdditionalRunInfo AdditionalRunInfo `json:"additionalRunInfo,omitempty"`

	// In case of direct archive we want to generate archive uid at the time of
	// backup run creation. This field will be used to store this.
	//
	// Please note that we currently support only one archival target for direct
	// archive job.
	ArchiveJobUID *UniversalIDProto `json:"archiveJobUid,omitempty"`

	// Contains basic information about the backup run.
	Base *BackupJobTaskStateBaseProto `json:"base,omitempty"`

	// Action to take on the backup run when blackout window starts. This is
	// inherited from the job settings and policy. However, this can be
	// overridden kNone in the following cases:
	// (a) An OOB run is triggered during an exclusion window.
	// (b) A paused run is resumed by user during an exclusion window.
	BlackoutWindowAction *int32 `json:"blackoutWindowAction,omitempty"`

	// This field specifies the copy snapshot params of the backup run. Note that
	// this list MUST contain at least the params for the 'kLocal' target.
	// Params for other targets can be specified if the snapshots have to be
	// copied to those targets.
	//
	// Note that this field must be set if the above field 'is_out_of_band_run'
	// is set to true and is used to override the copy targets of the backup run
	// as defined in the job policy.
	CopySnapshotParamsVec []*CopySnapshotParams `json:"copySnapshotParamsVec"`

	// The time beyond which the backup run should not be allowed to run
	// (cancelled or paused based on blackout_window_action).
	// NOTE: This field is deprecated as of 6.7. Instead of saving the deadline
	// time within the run, we rely on periodically checking for exclusion window
	// ranges configured in the policy to figure out whether a run should be
	// canceled or paused/resumed.
	DeadlineTimeUsecs *int64 `json:"deadlineTimeUsecs,omitempty"`

	// DRToCloud params, the backup job was configured with, when the backup run
	// happened.
	DrToCloudParams *BackupJobProtoDRToCloudParams `json:"drToCloudParams,omitempty"`

	// Run level additional environment specific backup params. If this is not
	// specified, we will take default actions (for example for NAS environments,
	// we will backup all objects within the source).
	EnvBackupParams *EnvBackupParams `json:"envBackupParams,omitempty"`

	// Whether copy run proto is published in change log on rx cluster. If true,
	// ETL should  ignore the backup run info.
	// This is added as part of ENG-388025, to fix a Day0 issue where copy
	// runs were not published in changelog on rx.
	EtlIgnoreBackupRun *bool `json:"etlIgnoreBackupRun,omitempty"`

	// The list of all finished attempts corresponding to this backup run.
	FinishedAttempts []*BackupJobAttemptStateProto `json:"finishedAttempts"`

	// Specifies the list of errors, that should be ignored in error
	// messages, error files
	IgnorableErrorsInErrorDb []*PrivateErrorProto `json:"ignorableErrorsInErrorDb"`

	// Whether this run has been triggered by a failover operation.
	IsFailoverRun *bool `json:"isFailoverRun,omitempty"`

	// Whether this is the first run for the object.
	IsFirstRunForTheObject *bool `json:"isFirstRunForTheObject,omitempty"`

	// Whether this is a missed run created due to scheduling constraints.
	IsMissedRun *bool `json:"isMissedRun,omitempty"`

	// Whether this is a out of band (OOB) backup run scheduled by a user. An
	// OOB snapshot and the list of targets (if any) to which the snapshot was
	// copied to are ignored when determining:
	// 1. If backup run needs to be scheduled for the backup job and
	// 2. If the snapshots of another backup run needs to be copied to a target
	// to satisfy the backup job policy.
	IsOutOfBandRun *bool `json:"isOutOfBandRun,omitempty"`

	// A list of the latest finished task for each source in the job run.
	LatestFinishedTasks []*BackupTaskStateProto `json:"latestFinishedTasks"`

	// This is set to true by the user if nutanix snapshots are requested
	// This is applicable in case if the vcenter in question is registered as a
	// management server on a prism endpoint. This flag will be ignored at the
	// backend if it is not feasible to leverage nutanix snapshot.
	LeverageNutanixSnapshots *bool `json:"leverageNutanixSnapshots,omitempty"`

	// This is set to true by the user in order to backup the objects via SAN
	// transport, as opposed to NBDSSL transport.
	// NOTE: Not all adapters support this method. Currently only VMware.
	LeverageSanTransport *bool `json:"leverageSanTransport,omitempty"`

	// Whether to leverage the storage array based snapshots for this backup
	// run. If storage based snapshots can not be taken for the sources, then
	// we will fallback to the default backup method.
	LeverageStorageSnapshots *bool `json:"leverageStorageSnapshots,omitempty"`

	// Whether the metadata for this backup run has been deleted from the
	// master's state. If this field is true, it also implies that the backup
	// snapshots on SnapFS have been deleted (i.e., 'snapshots_deleted' has to
	// be true as well).
	MetadataDeleted *bool `json:"metadataDeleted,omitempty"`

	// This will be populated with the timestamp at which the run's metadata
	// was marked as deleted (should be set only when 'metadata_deleted' is
	// true).
	MetadataDeletedTimestampUsecs *int64 `json:"metadataDeletedTimestampUsecs,omitempty"`

	// Total number of application instances backed up by this run. For example,
	// if the environment type is kSQL, this number is for the SQL server
	// instances.
	//
	// TODO(abhijit): Deprecate this since we do not backup instances
	// themselves. We only backup databases.
	NumAppInstances *int32 `json:"numAppInstances,omitempty"`

	// Total number of application objects whose backup was cancelled.
	NumCancelledAppObjects *int32 `json:"numCancelledAppObjects,omitempty"`

	// Number of backup tasks that were cancelled in the run so far.
	NumCancelledTasks *int64 `json:"numCancelledTasks,omitempty"`

	// Total number of application objects that failed the backup.
	NumFailedAppObjects *int32 `json:"numFailedAppObjects,omitempty"`

	// Number of backup tasks that failed in the run so far.
	NumFailedTasks *int64 `json:"numFailedTasks,omitempty"`

	// Number of backup tasks that were skipped in the run so far.
	NumSkippedTasks *int64 `json:"numSkippedTasks,omitempty"`

	// Total number of application objects successfully backed up by this run.
	// For example, for SQL and Oracle environments, this will be the number
	// of databases successfully backed up by this run.
	NumSuccessfulAppObjects *int32 `json:"numSuccessfulAppObjects,omitempty"`

	// Number of backup tasks that were successful in the run so far.
	NumSuccessfulTasks *int64 `json:"numSuccessfulTasks,omitempty"`

	// This will be set if this corresponds to a out-of-band backup run request.
	OobUID *UniversalIDProto `json:"oobUid,omitempty"`

	// The name of the original cluster on which this run executed.
	OriginClusterName *string `json:"originClusterName,omitempty"`

	// The originator type for this run. This specifies the origin from where
	// this run came to this cluster. The possibilities are:
	// 1) kLocal: This is a local run.
	// 2) kRemote: This is a remote replicated run.
	// 3) kArchival: This run was remote restored by Icebox.
	//
	// Reason for ignoring tenant migration checks is because on the source
	// cluster originator_type will be kLocal but on the destination cluster it
	// will be kArchival.
	OriginatorType *int32 `json:"originatorType,omitempty"`

	// Retention policy that applies to this run.
	// We can no longer depend on protection policy settings
	// for retentions due to multiple schedule support in CBS.
	// At the time of scheduling, the best schedule is picked
	// from amongst possible schedules and the retention
	// policy associated with that schedule is preserved here
	// to be used during a backup run.
	// This object will be nuked after copy task generation.
	// TODO(Suchi): Nuke the object when support for job runs
	// with multiple schedules is added.
	RetentionPolicy *RetentionPolicyProto `json:"retentionPolicy,omitempty"`

	// Optional field to add some label to the run.
	// Currently this is used only for labelling backup runs when run-now is
	// requested for failover.
	RunLabel *string `json:"runLabel,omitempty"`

	// This is a vector of timeouts, taken from the policy,for different backup
	// types(kFull, kRegular). A cancellation will automatically gets triggered
	// if the backup run has been running for more than this timeout duration.
	RunTimeoutVec []*CancellationTimeout `json:"runTimeoutVec"`

	// If this backup run was received via an incoming replication from another
	// cluster, and the replication failed with an error, this field will contain
	// the details of the replication error. If this field is set, the snapshots
	// for the sources may not exist on SnapFS, and hence the backup run should
	// be considered as an invalid run entirely.
	RxReplicationError *PrivateErrorProto `json:"rxReplicationError,omitempty"`

	// A list of targets where the snapshots of this backup run will possibly be
	// copied to. If the backup run encounters an error, the snapshots may not
	// actually end up being copied to these targets.
	SnapshotTargetsDEPRECATED []*SnapshotTarget `json:"snapshotTargets_DEPRECATED"`

	// Whether the backup snapshots created on SnapFS by this run have been
	// deleted (due to either retention policies or because the user asked us
	// to). The metadata for such backup runs might still be preserved in the
	// master's state (unless the 'metadata_deleted' field is also set to true).
	//
	// Reason for ignoring tenant migration checks is because on the destination
	// cluster except for the latest snapshot none of the other snapshots for an
	// object will be downloaded, only the metadata for those snapshots will be
	// downloaded.
	SnapshotsDeleted *bool `json:"snapshotsDeleted,omitempty"`

	// This will be populated with the timestamp at which the run was marked as
	// removed.
	SnapshotsDeletedTimestampUsecs *int64 `json:"snapshotsDeletedTimestampUsecs,omitempty"`

	// The environment type of the sources that are being backed up. This can
	// possibly be different than the environment type of the backup job itself
	// (e.g., a SQL backup job can be backing up SQL databases that are running
	// within a VMware source environment).
	SourceEnvType *int32 `json:"sourceEnvType,omitempty"`

	// This field is set to true if the run is created for backup of type
	// storage array snapshot.
	StorageArraySnapshot *bool `json:"storageArraySnapshot,omitempty"`

	// Same as above, but applies to all the tasks inside this backup run.
	TaskTimeoutVec []*CancellationTimeout `json:"taskTimeoutVec"`

	// WORM protection details. This field is inherited from protection policy
	// at the start of a backup run. For copy tasks of type kLocal, the
	// data_lock_constraints field in CopyBackupRunTaskStateProto has higher
	// precedence over this.
	WormRetention *WormRetentionProto `json:"wormRetention,omitempty"`

	// Magneto will create root progress monitor task path for Yoda AddSnapshot
	// RPCs. This field stores that path.
	YodaProgressMonitorRootPath *string `json:"yodaProgressMonitorRootPath,omitempty"`
}

// Validate validates this backup job run state proto
func (m *BackupJobRunStateProto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActiveAttempt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdditionalParamVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchiveJobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBase(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCopySnapshotParamsVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrToCloudParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvBackupParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinishedAttempts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgnorableErrorsInErrorDb(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLatestFinishedTasks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOobUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetentionPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunTimeoutVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRxReplicationError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotTargetsDEPRECATED(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskTimeoutVec(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWormRetention(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobRunStateProto) validateActiveAttempt(formats strfmt.Registry) error {
	if swag.IsZero(m.ActiveAttempt) { // not required
		return nil
	}

	if m.ActiveAttempt != nil {
		if err := m.ActiveAttempt.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activeAttempt")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("activeAttempt")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateAdditionalParamVec(formats strfmt.Registry) error {
	if swag.IsZero(m.AdditionalParamVec) { // not required
		return nil
	}

	for i := 0; i < len(m.AdditionalParamVec); i++ {
		if swag.IsZero(m.AdditionalParamVec[i]) { // not required
			continue
		}

		if m.AdditionalParamVec[i] != nil {
			if err := m.AdditionalParamVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("additionalParamVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("additionalParamVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateArchiveJobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchiveJobUID) { // not required
		return nil
	}

	if m.ArchiveJobUID != nil {
		if err := m.ArchiveJobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveJobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archiveJobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateBase(formats strfmt.Registry) error {
	if swag.IsZero(m.Base) { // not required
		return nil
	}

	if m.Base != nil {
		if err := m.Base.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("base")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("base")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateCopySnapshotParamsVec(formats strfmt.Registry) error {
	if swag.IsZero(m.CopySnapshotParamsVec) { // not required
		return nil
	}

	for i := 0; i < len(m.CopySnapshotParamsVec); i++ {
		if swag.IsZero(m.CopySnapshotParamsVec[i]) { // not required
			continue
		}

		if m.CopySnapshotParamsVec[i] != nil {
			if err := m.CopySnapshotParamsVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateDrToCloudParams(formats strfmt.Registry) error {
	if swag.IsZero(m.DrToCloudParams) { // not required
		return nil
	}

	if m.DrToCloudParams != nil {
		if err := m.DrToCloudParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drToCloudParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("drToCloudParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateEnvBackupParams(formats strfmt.Registry) error {
	if swag.IsZero(m.EnvBackupParams) { // not required
		return nil
	}

	if m.EnvBackupParams != nil {
		if err := m.EnvBackupParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("envBackupParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("envBackupParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateFinishedAttempts(formats strfmt.Registry) error {
	if swag.IsZero(m.FinishedAttempts) { // not required
		return nil
	}

	for i := 0; i < len(m.FinishedAttempts); i++ {
		if swag.IsZero(m.FinishedAttempts[i]) { // not required
			continue
		}

		if m.FinishedAttempts[i] != nil {
			if err := m.FinishedAttempts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedAttempts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedAttempts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateIgnorableErrorsInErrorDb(formats strfmt.Registry) error {
	if swag.IsZero(m.IgnorableErrorsInErrorDb) { // not required
		return nil
	}

	for i := 0; i < len(m.IgnorableErrorsInErrorDb); i++ {
		if swag.IsZero(m.IgnorableErrorsInErrorDb[i]) { // not required
			continue
		}

		if m.IgnorableErrorsInErrorDb[i] != nil {
			if err := m.IgnorableErrorsInErrorDb[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateLatestFinishedTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.LatestFinishedTasks) { // not required
		return nil
	}

	for i := 0; i < len(m.LatestFinishedTasks); i++ {
		if swag.IsZero(m.LatestFinishedTasks[i]) { // not required
			continue
		}

		if m.LatestFinishedTasks[i] != nil {
			if err := m.LatestFinishedTasks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latestFinishedTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("latestFinishedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateOobUID(formats strfmt.Registry) error {
	if swag.IsZero(m.OobUID) { // not required
		return nil
	}

	if m.OobUID != nil {
		if err := m.OobUID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateRetentionPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.RetentionPolicy) { // not required
		return nil
	}

	if m.RetentionPolicy != nil {
		if err := m.RetentionPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retentionPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retentionPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateRunTimeoutVec(formats strfmt.Registry) error {
	if swag.IsZero(m.RunTimeoutVec) { // not required
		return nil
	}

	for i := 0; i < len(m.RunTimeoutVec); i++ {
		if swag.IsZero(m.RunTimeoutVec[i]) { // not required
			continue
		}

		if m.RunTimeoutVec[i] != nil {
			if err := m.RunTimeoutVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runTimeoutVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("runTimeoutVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateRxReplicationError(formats strfmt.Registry) error {
	if swag.IsZero(m.RxReplicationError) { // not required
		return nil
	}

	if m.RxReplicationError != nil {
		if err := m.RxReplicationError.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rxReplicationError")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rxReplicationError")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) validateSnapshotTargetsDEPRECATED(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotTargetsDEPRECATED) { // not required
		return nil
	}

	for i := 0; i < len(m.SnapshotTargetsDEPRECATED); i++ {
		if swag.IsZero(m.SnapshotTargetsDEPRECATED[i]) { // not required
			continue
		}

		if m.SnapshotTargetsDEPRECATED[i] != nil {
			if err := m.SnapshotTargetsDEPRECATED[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshotTargets_DEPRECATED" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshotTargets_DEPRECATED" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateTaskTimeoutVec(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskTimeoutVec) { // not required
		return nil
	}

	for i := 0; i < len(m.TaskTimeoutVec); i++ {
		if swag.IsZero(m.TaskTimeoutVec[i]) { // not required
			continue
		}

		if m.TaskTimeoutVec[i] != nil {
			if err := m.TaskTimeoutVec[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) validateWormRetention(formats strfmt.Registry) error {
	if swag.IsZero(m.WormRetention) { // not required
		return nil
	}

	if m.WormRetention != nil {
		if err := m.WormRetention.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("wormRetention")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("wormRetention")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup job run state proto based on the context it is used
func (m *BackupJobRunStateProto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActiveAttempt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAdditionalParamVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchiveJobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBase(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCopySnapshotParamsVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrToCloudParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnvBackupParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinishedAttempts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIgnorableErrorsInErrorDb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLatestFinishedTasks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOobUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetentionPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRunTimeoutVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRxReplicationError(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSnapshotTargetsDEPRECATED(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaskTimeoutVec(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWormRetention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupJobRunStateProto) contextValidateActiveAttempt(ctx context.Context, formats strfmt.Registry) error {

	if m.ActiveAttempt != nil {

		if swag.IsZero(m.ActiveAttempt) { // not required
			return nil
		}

		if err := m.ActiveAttempt.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activeAttempt")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("activeAttempt")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateAdditionalParamVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AdditionalParamVec); i++ {

		if m.AdditionalParamVec[i] != nil {

			if swag.IsZero(m.AdditionalParamVec[i]) { // not required
				return nil
			}

			if err := m.AdditionalParamVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("additionalParamVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("additionalParamVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateArchiveJobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchiveJobUID != nil {

		if swag.IsZero(m.ArchiveJobUID) { // not required
			return nil
		}

		if err := m.ArchiveJobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveJobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("archiveJobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateBase(ctx context.Context, formats strfmt.Registry) error {

	if m.Base != nil {

		if swag.IsZero(m.Base) { // not required
			return nil
		}

		if err := m.Base.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("base")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("base")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateCopySnapshotParamsVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CopySnapshotParamsVec); i++ {

		if m.CopySnapshotParamsVec[i] != nil {

			if swag.IsZero(m.CopySnapshotParamsVec[i]) { // not required
				return nil
			}

			if err := m.CopySnapshotParamsVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("copySnapshotParamsVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateDrToCloudParams(ctx context.Context, formats strfmt.Registry) error {

	if m.DrToCloudParams != nil {

		if swag.IsZero(m.DrToCloudParams) { // not required
			return nil
		}

		if err := m.DrToCloudParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drToCloudParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("drToCloudParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateEnvBackupParams(ctx context.Context, formats strfmt.Registry) error {

	if m.EnvBackupParams != nil {

		if swag.IsZero(m.EnvBackupParams) { // not required
			return nil
		}

		if err := m.EnvBackupParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("envBackupParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("envBackupParams")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateFinishedAttempts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FinishedAttempts); i++ {

		if m.FinishedAttempts[i] != nil {

			if swag.IsZero(m.FinishedAttempts[i]) { // not required
				return nil
			}

			if err := m.FinishedAttempts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("finishedAttempts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("finishedAttempts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateIgnorableErrorsInErrorDb(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IgnorableErrorsInErrorDb); i++ {

		if m.IgnorableErrorsInErrorDb[i] != nil {

			if swag.IsZero(m.IgnorableErrorsInErrorDb[i]) { // not required
				return nil
			}

			if err := m.IgnorableErrorsInErrorDb[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ignorableErrorsInErrorDb" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateLatestFinishedTasks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.LatestFinishedTasks); i++ {

		if m.LatestFinishedTasks[i] != nil {

			if swag.IsZero(m.LatestFinishedTasks[i]) { // not required
				return nil
			}

			if err := m.LatestFinishedTasks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("latestFinishedTasks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("latestFinishedTasks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateOobUID(ctx context.Context, formats strfmt.Registry) error {

	if m.OobUID != nil {

		if swag.IsZero(m.OobUID) { // not required
			return nil
		}

		if err := m.OobUID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("oobUid")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("oobUid")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateRetentionPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.RetentionPolicy != nil {

		if swag.IsZero(m.RetentionPolicy) { // not required
			return nil
		}

		if err := m.RetentionPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retentionPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retentionPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateRunTimeoutVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RunTimeoutVec); i++ {

		if m.RunTimeoutVec[i] != nil {

			if swag.IsZero(m.RunTimeoutVec[i]) { // not required
				return nil
			}

			if err := m.RunTimeoutVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("runTimeoutVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("runTimeoutVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateRxReplicationError(ctx context.Context, formats strfmt.Registry) error {

	if m.RxReplicationError != nil {

		if swag.IsZero(m.RxReplicationError) { // not required
			return nil
		}

		if err := m.RxReplicationError.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rxReplicationError")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rxReplicationError")
			}
			return err
		}
	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateSnapshotTargetsDEPRECATED(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SnapshotTargetsDEPRECATED); i++ {

		if m.SnapshotTargetsDEPRECATED[i] != nil {

			if swag.IsZero(m.SnapshotTargetsDEPRECATED[i]) { // not required
				return nil
			}

			if err := m.SnapshotTargetsDEPRECATED[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("snapshotTargets_DEPRECATED" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("snapshotTargets_DEPRECATED" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateTaskTimeoutVec(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaskTimeoutVec); i++ {

		if m.TaskTimeoutVec[i] != nil {

			if swag.IsZero(m.TaskTimeoutVec[i]) { // not required
				return nil
			}

			if err := m.TaskTimeoutVec[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taskTimeoutVec" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupJobRunStateProto) contextValidateWormRetention(ctx context.Context, formats strfmt.Registry) error {

	if m.WormRetention != nil {

		if swag.IsZero(m.WormRetention) { // not required
			return nil
		}

		if err := m.WormRetention.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("wormRetention")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("wormRetention")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupJobRunStateProto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupJobRunStateProto) UnmarshalBinary(b []byte) error {
	var res BackupJobRunStateProto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
