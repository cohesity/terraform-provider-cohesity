// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ObjectSnapshotDocumentVersionInfo object snapshot document version info
//
// swagger:model ObjectSnapshotDocument_VersionInfo
type ObjectSnapshotDocumentVersionInfo struct {

	// The size of the delta we pulled from source object. For a base
	// snapshot, this is equal to logical_size_bytes. For a delta, this is the
	// delta size. When a base snapshot is dropped, the next snapshot's delta
	// changes to logical_size_bytes.
	DeltaSizeBytes *int64 `json:"deltaSizeBytes,omitempty"`

	// Whether System backup was enabled by the user or not.
	EnableSystemBackup *bool `json:"enableSystemBackup,omitempty"`

	// Store environment specific extended information (e.g. for recovery).
	// This field is not stored in elasticsearch.
	ExtendedInfo *AddSnapshotArgExtendedInformation `json:"extendedInfo,omitempty"`

	// Indexing status of this version.
	IndexingStatus *int32 `json:"indexingStatus,omitempty"`

	// instance Id
	InstanceID *MagnetoInstanceID `json:"instanceId,omitempty"`

	// Whether the snapshot was app consistent (e.g. VM was quiesced).
	IsAppConsistent *bool `json:"isAppConsistent,omitempty"`

	// Whether the version is direct archive snapshot. In this case kLocal
	// replica should not be searchable.
	IsDirectArchiveSnapshot *bool `json:"isDirectArchiveSnapshot,omitempty"`

	// Whether the snapshot is a full backup.
	IsFullBackup *bool `json:"isFullBackup,omitempty"`

	// Location of the snapshot dir, relative to the view. This field was not
	// present before 2.5 - in that case, the path can be constructed using the
	// function: ConstructSnapshotDir. When using in tests, the path will be a
	// local path without the viewbox/view mount path.
	LocalSnapshotDir *string `json:"localSnapshotDir,omitempty"`

	// logical_size represents the amount of data if snapshot was a base
	// snapshot. This is the stat size: ls -l
	LogicalSizeBytes *int64 `json:"logicalSizeBytes,omitempty"`

	// The NAS protocol type(s) if this is a file backup based snapshot.
	// Currently we only support a single backup type. In the future we could
	// support mixed types of backup, in which case this vector will contain
	// all the types that are backed up.
	NasBackupTypeVec []int32 `json:"nasBackupTypeVec"`

	// Number of entries indexed in this version.
	NumEntriesIndexed *int64 `json:"numEntriesIndexed,omitempty"`

	// Number of partitions not detected/indexed by yoda.
	NumUndetectedPartitions *int32 `json:"numUndetectedPartitions,omitempty"`

	// This is the amount of data actually being used on disk that's attributed
	// to this snapshot. This is typically not available at the time of
	// indexing, but can be updated later.
	PhysicalSizeBytes *int64 `json:"physicalSizeBytes,omitempty"`

	// This size if set represents the total amount of space taken up by the
	// object on the primary datastore. This is equivalent to the output of du.
	// For ex: If a VMDK of size 100GB is created as thin provisioned and the
	// actual usage of it is 20GB, then the logical size of this object is
	// 100GB and the physical size is 20GB.
	PrimaryPhysicalSizeBytes *int64 `json:"primaryPhysicalSizeBytes,omitempty"`

	// record stats
	RecordStats *ObjectSnapshotDocumentVersionInfoRecordStats `json:"recordStats,omitempty"`

	// Replica and expiry information for each snapshot.
	ReplicaInfo *SnapshotReplicas `json:"replicaInfo,omitempty"`

	// The type of the backup run that was actually scheduled.
	ScheduledBackupType *int32 `json:"scheduledBackupType,omitempty"`

	// Whether to skip kLocal replica in search results.
	SkipLocalReplicaInSearch *bool `json:"skipLocalReplicaInSearch,omitempty"`

	// Whether indexing is disabled or not in the indexing policy. This will
	// cause slave indexing to be disabled.
	SlaveIndexingDisabled *bool `json:"slaveIndexingDisabled,omitempty"`

	// Specifies the backup type within the version for the given entity.
	//
	// This will only be populated for Object based backups where Magneto sends
	// jobId as -1. This can be used to differentiate between backup types
	// applicable on the same entity for every version.
	//
	// In OnPrem scenarios, 'backup_type' within each doc should be used
	// instead, for differentiation.
	SnapshotBackupType *int32 `json:"snapshotBackupType,omitempty"`

	// Micros from epoch when the snapshot was taken. This is expected to be
	// the time at which the VM was made quiescent for the purpose of snapshot.
	// It need not be the exact time - user identifiable snapshot time.
	SnapshotTimestampUsecs *int64 `json:"snapshotTimestampUsecs,omitempty"`

	// Snapshot type of the object.
	SnapshotType *int32 `json:"snapshotType,omitempty"`

	// Time taken in indexing this version by slave. This does not include
	// time taken in computing volume mapping.
	TimeTakenInIndexingUsecs *int64 `json:"timeTakenInIndexingUsecs,omitempty"`

	// uda params
	UdaParams *ObjectSnapshotDocumentVersionInfoUdaParams `json:"udaParams,omitempty"`

	// View name where the snapshot is present.
	ViewName *string `json:"viewName,omitempty"`

	// Per volume indexing info to be stored.
	VolumeInfo []*VolumeIndexingInfo `json:"volumeInfo"`
}

// Validate validates this object snapshot document version info
func (m *ObjectSnapshotDocumentVersionInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExtendedInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstanceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecordStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReplicaInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUdaParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) validateExtendedInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtendedInfo) { // not required
		return nil
	}

	if m.ExtendedInfo != nil {
		if err := m.ExtendedInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("extendedInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("extendedInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) validateInstanceID(formats strfmt.Registry) error {
	if swag.IsZero(m.InstanceID) { // not required
		return nil
	}

	if m.InstanceID != nil {
		if err := m.InstanceID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instanceId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instanceId")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) validateRecordStats(formats strfmt.Registry) error {
	if swag.IsZero(m.RecordStats) { // not required
		return nil
	}

	if m.RecordStats != nil {
		if err := m.RecordStats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recordStats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recordStats")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) validateReplicaInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ReplicaInfo) { // not required
		return nil
	}

	if m.ReplicaInfo != nil {
		if err := m.ReplicaInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) validateUdaParams(formats strfmt.Registry) error {
	if swag.IsZero(m.UdaParams) { // not required
		return nil
	}

	if m.UdaParams != nil {
		if err := m.UdaParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udaParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("udaParams")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) validateVolumeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.VolumeInfo); i++ {
		if swag.IsZero(m.VolumeInfo[i]) { // not required
			continue
		}

		if m.VolumeInfo[i] != nil {
			if err := m.VolumeInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this object snapshot document version info based on the context it is used
func (m *ObjectSnapshotDocumentVersionInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExtendedInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInstanceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecordStats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReplicaInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUdaParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) contextValidateExtendedInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ExtendedInfo != nil {

		if swag.IsZero(m.ExtendedInfo) { // not required
			return nil
		}

		if err := m.ExtendedInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("extendedInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("extendedInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) contextValidateInstanceID(ctx context.Context, formats strfmt.Registry) error {

	if m.InstanceID != nil {

		if swag.IsZero(m.InstanceID) { // not required
			return nil
		}

		if err := m.InstanceID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instanceId")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instanceId")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) contextValidateRecordStats(ctx context.Context, formats strfmt.Registry) error {

	if m.RecordStats != nil {

		if swag.IsZero(m.RecordStats) { // not required
			return nil
		}

		if err := m.RecordStats.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recordStats")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("recordStats")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) contextValidateReplicaInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ReplicaInfo != nil {

		if swag.IsZero(m.ReplicaInfo) { // not required
			return nil
		}

		if err := m.ReplicaInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replicaInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replicaInfo")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) contextValidateUdaParams(ctx context.Context, formats strfmt.Registry) error {

	if m.UdaParams != nil {

		if swag.IsZero(m.UdaParams) { // not required
			return nil
		}

		if err := m.UdaParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("udaParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("udaParams")
			}
			return err
		}
	}

	return nil
}

func (m *ObjectSnapshotDocumentVersionInfo) contextValidateVolumeInfo(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeInfo); i++ {

		if m.VolumeInfo[i] != nil {

			if swag.IsZero(m.VolumeInfo[i]) { // not required
				return nil
			}

			if err := m.VolumeInfo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeInfo" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ObjectSnapshotDocumentVersionInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ObjectSnapshotDocumentVersionInfo) UnmarshalBinary(b []byte) error {
	var res ObjectSnapshotDocumentVersionInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
