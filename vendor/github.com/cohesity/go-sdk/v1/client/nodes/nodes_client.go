// Code generated by go-swagger; DO NOT EDIT.

package nodes

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new nodes API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new nodes API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new nodes API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for nodes API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	GetNodeByID(params *GetNodeByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeByIDOK, error)

	GetNodeStats(params *GetNodeStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeStatsOK, error)

	GetNodeStatus(params *GetNodeStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeStatusOK, error)

	GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error)

	ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error)

	MarkNodeForRemoval(params *MarkNodeForRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeForRemovalAccepted, error)

	UpdateNode(params *UpdateNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNodeOK, error)

	UpgradeNode(params *UpgradeNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeNodeAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
GetNodeByID lists details about a single node

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the Node corresponding to the specified Node Id.
*/
func (a *Client) GetNodeByID(params *GetNodeByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodeByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodeById",
		Method:             "GET",
		PathPattern:        "/public/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodeByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodeByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodeByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNodeStats lists details about node stats

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the top level stats for the nodes in the clusters.
*/
func (a *Client) GetNodeStats(params *GetNodeStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeStatsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodeStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodeStats",
		Method:             "GET",
		PathPattern:        "/nodeStats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodeStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodeStatsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodeStatsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNodeStatus sends a request to a node to get the status of that node

**Privileges:** ```CLUSTER_VIEW, NODE_VIEW``` <br><br>
*/
func (a *Client) GetNodeStatus(params *GetNodeStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodeStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodeStatus",
		Method:             "GET",
		PathPattern:        "/public/node/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodeStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodeStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodeStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetNodes lists nodes of the cluster

	**Privileges:** ```CLUSTER_VIEW``` <br><br>If no parameters are specified, all Nodes currently on the Cohesity Cluster are

returned.
Specifying parameters filters the results that are returned.
*/
func (a *Client) GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodes",
		Method:             "GET",
		PathPattern:        "/public/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListFreeNodes lists the free nodes present on a network

	**Privileges:** ```CLUSTER_VIEW, CLUSTER_CREATE``` <br><br>Sends a request to any Node to list all of the free Nodes that are present on

the network.
*/
func (a *Client) ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListFreeNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListFreeNodes",
		Method:             "GET",
		PathPattern:        "/public/freeNodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListFreeNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListFreeNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListFreeNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkNodeForRemoval marks a node for removal

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns removal status upon completion.
*/
func (a *Client) MarkNodeForRemoval(params *MarkNodeForRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeForRemovalAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkNodeForRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkNodeForRemoval",
		Method:             "POST",
		PathPattern:        "/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkNodeForRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkNodeForRemovalAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkNodeForRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateNode updates a node

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the updated Node.
*/
func (a *Client) UpdateNode(params *UpdateNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateNode",
		Method:             "PUT",
		PathPattern:        "/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateNodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpgradeNode upgrades the software on a node

	**Privileges:** ```CLUSTER_CREATE``` <br><br>Sends a request to upgrade the software version of a Node. By default, the

Node that the request is sent to is the only one upgraded, but the user can
specify if they want to attempt to upgrade all free nodes on the network.
Before using this, you need to upload a new package to the Node you want to
upgrade by using the /public/packages endpoint.
*/
func (a *Client) UpgradeNode(params *UpgradeNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeNodeAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeNode",
		Method:             "PUT",
		PathPattern:        "/public/nodes/software",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeNodeAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
