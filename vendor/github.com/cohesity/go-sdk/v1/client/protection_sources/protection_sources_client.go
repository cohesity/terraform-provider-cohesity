// Code generated by go-swagger; DO NOT EDIT.

package protection_sources

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new protection sources API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new protection sources API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new protection sources API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for protection sources API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DownloadCftFile(params *DownloadCftFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DownloadCftFileOK, error)

	DownloadPhysicalAgent(params *DownloadPhysicalAgentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DownloadPhysicalAgentOK, error)

	GetProtectionSourcesObjectByID(params *GetProtectionSourcesObjectByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProtectionSourcesObjectByIDOK, error)

	GetProtectionSourcesObjects(params *GetProtectionSourcesObjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProtectionSourcesObjectsOK, error)

	ListApplicationServers(params *ListApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListApplicationServersOK, error)

	ListDataStoreInformation(params *ListDataStoreInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDataStoreInformationOK, error)

	ListExchangeDagHosts(params *ListExchangeDagHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListExchangeDagHostsOK, error)

	ListProtectedObjects(params *ListProtectedObjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectedObjectsOK, error)

	ListProtectionSources(params *ListProtectionSourcesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectionSourcesOK, error)

	ListProtectionSourcesRegistrationInfo(params *ListProtectionSourcesRegistrationInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectionSourcesRegistrationInfoOK, error)

	ListProtectionSourcesRootNodes(params *ListProtectionSourcesRootNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectionSourcesRootNodesOK, error)

	ListSQLAagHostsAndDatabases(params *ListSQLAagHostsAndDatabasesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListSQLAagHostsAndDatabasesOK, error)

	ListVirtualMachines(params *ListVirtualMachinesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListVirtualMachinesOK, error)

	RefreshProtectionSourceByID(params *RefreshProtectionSourceByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RefreshProtectionSourceByIDNoContent, error)

	RegisterApplicationServers(params *RegisterApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RegisterApplicationServersOK, error)

	RegisterProtectionSource(params *RegisterProtectionSourceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RegisterProtectionSourceOK, error)

	RunDiagnostics(params *RunDiagnosticsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RunDiagnosticsCreated, error)

	UnregisterApplicationServers(params *UnregisterApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnregisterApplicationServersOK, error)

	UnregisterProtectionSource(params *UnregisterProtectionSourceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnregisterProtectionSourceNoContent, error)

	UpdateApplicationServers(params *UpdateApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateApplicationServersOK, error)

	UpdateProtectionSource(params *UpdateProtectionSourceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProtectionSourceOK, error)

	UpgradePhysicalAgents(params *UpgradePhysicalAgentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradePhysicalAgentsCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DownloadCftFile downloads the c f t

**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>
*/
func (a *Client) DownloadCftFile(params *DownloadCftFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DownloadCftFileOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadCftFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DownloadCftFile",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/downloadCftFile",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadCftFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadCftFileOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DownloadCftFileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DownloadPhysicalAgent downloads the physical agent for a host type

**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>Host type could be Linux, Windows, AIX.
*/
func (a *Client) DownloadPhysicalAgent(params *DownloadPhysicalAgentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DownloadPhysicalAgentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadPhysicalAgentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DownloadPhysicalAgent",
		Method:             "GET",
		PathPattern:        "/public/physicalAgents/download",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadPhysicalAgentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadPhysicalAgentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DownloadPhysicalAgentDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProtectionSourcesObjectByID gets details about a single protection source object

**Privileges:** ```PROTECTION_VIEW``` <br><br>Returns the Protection Source object corresponding to the specified id.
*/
func (a *Client) GetProtectionSourcesObjectByID(params *GetProtectionSourcesObjectByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProtectionSourcesObjectByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProtectionSourcesObjectByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProtectionSourcesObjectById",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/objects/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetProtectionSourcesObjectByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetProtectionSourcesObjectByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetProtectionSourcesObjectByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProtectionSourcesObjects lists details about protection source objects

**Privileges:** ```PROTECTION_VIEW``` <br><br>Returns the Protection Source objects corresponding to the specified ids.
*/
func (a *Client) GetProtectionSourcesObjects(params *GetProtectionSourcesObjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProtectionSourcesObjectsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProtectionSourcesObjectsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProtectionSourcesObjects",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/objects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetProtectionSourcesObjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetProtectionSourcesObjectsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetProtectionSourcesObjectsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListApplicationServers returns the registered application servers and their object subtrees

	**Privileges:** ```PROTECTION_VIEW``` <br><br>Given the root node id of a Protection Source tree, returns the list of

Application Servers registered under that tree based on the filters.
*/
func (a *Client) ListApplicationServers(params *ListApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListApplicationServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListApplicationServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListApplicationServers",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/applicationServers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListApplicationServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListApplicationServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListApplicationServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDataStoreInformation returns the datastore information in v mware environment

**Privileges:** ```PROTECTION_VIEW``` <br><br>
*/
func (a *Client) ListDataStoreInformation(params *ListDataStoreInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDataStoreInformationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDataStoreInformationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListDataStoreInformation",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/datastores",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDataStoreInformationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDataStoreInformationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDataStoreInformationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListExchangeDagHosts **Privileges:** ```PROTECTION_VIEW``` <br><br>Returns information about all the exchange hosts that belong to an Exchange

DAG.
*/
func (a *Client) ListExchangeDagHosts(params *ListExchangeDagHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListExchangeDagHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListExchangeDagHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListExchangeDagHosts",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/exchangeDagHosts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListExchangeDagHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListExchangeDagHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListExchangeDagHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListProtectedObjects returns the list of protected objects in a registered protection source

**Privileges:** ```PROTECTION_VIEW``` <br><br>
*/
func (a *Client) ListProtectedObjects(params *ListProtectedObjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectedObjectsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListProtectedObjectsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListProtectedObjects",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/protectedObjects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListProtectedObjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListProtectedObjectsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListProtectedObjectsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListProtectionSources returns the registered protection sources and their object subtrees

	**Privileges:** ```PROTECTION_VIEW``` <br><br>If no parameters are specified, all Protection Sources that are registered

on the Cohesity Cluster are returned.
In addition, an Object subtree gathered from each Source is returned.
For example, the Cohesity Cluster interrogates a Source VMware vCenter Server
and creates an hierarchical Object subtree that mirrors the
Inventory tree on vCenter Server.
The contents of the Object tree are returned as a "nodes" hierarchy
of "protectionSource"s.
Specifying parameters can alter the results that are returned.
*/
func (a *Client) ListProtectionSources(params *ListProtectionSourcesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectionSourcesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListProtectionSourcesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListProtectionSources",
		Method:             "GET",
		PathPattern:        "/public/protectionSources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListProtectionSourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListProtectionSourcesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListProtectionSourcesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListProtectionSourcesRegistrationInfo **Privileges:** ```PROTECTION_VIEW``` <br><br>Returns the registration and protection information of the registered

Protection Sources.
*/
func (a *Client) ListProtectionSourcesRegistrationInfo(params *ListProtectionSourcesRegistrationInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectionSourcesRegistrationInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListProtectionSourcesRegistrationInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListProtectionSourcesRegistrationInfo",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/registrationInfo",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListProtectionSourcesRegistrationInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListProtectionSourcesRegistrationInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListProtectionSourcesRegistrationInfoDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListProtectionSourcesRootNodes returns the top level root protection sources with registration information

	**Privileges:** ```PROTECTION_VIEW``` <br><br>Returns the root Protection Sources and the registration information for

each of these Sources.
*/
func (a *Client) ListProtectionSourcesRootNodes(params *ListProtectionSourcesRootNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProtectionSourcesRootNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListProtectionSourcesRootNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListProtectionSourcesRootNodes",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/rootNodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListProtectionSourcesRootNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListProtectionSourcesRootNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListProtectionSourcesRootNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListSQLAagHostsAndDatabases returns the registered protection sources and their object subtrees

	**Privileges:** ```PROTECTION_VIEW``` <br><br>Given a list of Protection Source Ids registered as SQL servers, returns

AAGs found and the databases in AAG(Always on Availablity Group).
*/
func (a *Client) ListSQLAagHostsAndDatabases(params *ListSQLAagHostsAndDatabasesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListSQLAagHostsAndDatabasesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListSQLAagHostsAndDatabasesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListSqlAagHostsAndDatabases",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/sqlAagHostsAndDatabases",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListSQLAagHostsAndDatabasesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListSQLAagHostsAndDatabasesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListSQLAagHostsAndDatabasesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ListVirtualMachines returns the virtual machines in a v center server

	**Privileges:** ```PROTECTION_VIEW``` <br><br>Returns all Virtual Machines found in all the vCenter Servers registered

on the Cohesity Cluster that match the filter criteria specified using
parameters.
If an id is specified, only VMs found in the specified vCenter Server
are returned.
Only VM Objects are returned.
Other VMware Objects such as datacenters are not returned.
*/
func (a *Client) ListVirtualMachines(params *ListVirtualMachinesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListVirtualMachinesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListVirtualMachinesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListVirtualMachines",
		Method:             "GET",
		PathPattern:        "/public/protectionSources/virtualMachines",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListVirtualMachinesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListVirtualMachinesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListVirtualMachinesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	RefreshProtectionSourceByID refreshes the object hierarchy of the protection sources tree

	**Privileges:** ```PROTECTION_VIEW``` <br><br>Force an immediate refresh between the specified Protection Source tree

on the Cohesity Cluster and the Inventory tree
in the associated vCenter Server.

For example if a new VM is added to the vCenter Server, after a refresh,
a new Protection Source node for this VM is added to the Protection Sources
tree.

Success indicates the forced refresh has been completed. For larger sources it
is possible for the operation to timeout before the force refresh has been
completed. This timeout can be increased by modifying the
'iris_post_timeout_msecs_to_magneto' gflag on the Iris service.
*/
func (a *Client) RefreshProtectionSourceByID(params *RefreshProtectionSourceByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RefreshProtectionSourceByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRefreshProtectionSourceByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RefreshProtectionSourceById",
		Method:             "POST",
		PathPattern:        "/public/protectionSources/refresh/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RefreshProtectionSourceByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RefreshProtectionSourceByIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RefreshProtectionSourceByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	RegisterApplicationServers registers a protection source as running one or more application servers like microsoft SQL servers or microsoft exchange servers

	**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>Registering Application Servers will help Cohesity Cluster such that any

application specific data can be backed up.

Returns the Protection Source registered upon success.
*/
func (a *Client) RegisterApplicationServers(params *RegisterApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RegisterApplicationServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRegisterApplicationServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RegisterApplicationServers",
		Method:             "POST",
		PathPattern:        "/public/protectionSources/applicationServers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RegisterApplicationServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RegisterApplicationServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RegisterApplicationServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	RegisterProtectionSource registers a protection source

	**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>Register a Protection Source on the Cohesity Cluster.

It could be the root node of a vCenter Server or a physical server.

Returns the newly registered Protection Source upon success.
*/
func (a *Client) RegisterProtectionSource(params *RegisterProtectionSourceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RegisterProtectionSourceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRegisterProtectionSourceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RegisterProtectionSource",
		Method:             "POST",
		PathPattern:        "/public/protectionSources/register",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RegisterProtectionSourceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RegisterProtectionSourceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RegisterProtectionSourceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	RunDiagnostics collects diagnostics of the protection source for a host type

	**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>If the request is successful, the diagnostics script is triggered on Cohesity

agent which generates a tarball containing various diagnostics and uploads it
to the Cohesity cluster. Host type could be Linux, Windows.
*/
func (a *Client) RunDiagnostics(params *RunDiagnosticsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RunDiagnosticsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRunDiagnosticsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RunDiagnostics",
		Method:             "POST",
		PathPattern:        "/public/protectionSources/diagnostics/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RunDiagnosticsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RunDiagnosticsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RunDiagnosticsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UnregisterApplicationServers unregisters application servers like microsoft SQL servers or microsoft exchange servers running on a protection source

	**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>Unregistering Application Servers will fail if the Protection Source is

currently being backed up.

Returns the Protection Source whose Application Servers are unregistered upon
success.
*/
func (a *Client) UnregisterApplicationServers(params *UnregisterApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnregisterApplicationServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnregisterApplicationServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UnregisterApplicationServers",
		Method:             "DELETE",
		PathPattern:        "/public/protectionSources/applicationServers/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnregisterApplicationServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnregisterApplicationServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnregisterApplicationServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UnregisterProtectionSource unregisters a previously registered protection source

**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>
*/
func (a *Client) UnregisterProtectionSource(params *UnregisterProtectionSourceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnregisterProtectionSourceNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnregisterProtectionSourceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UnregisterProtectionSource",
		Method:             "DELETE",
		PathPattern:        "/public/protectionSources/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UnregisterProtectionSourceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnregisterProtectionSourceNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnregisterProtectionSourceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpdateApplicationServers modifies the registration parameters of application servers in a protection source

	**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>Returns the Protection Source whose registration parameters of its

Application Servers are modified upon success.
*/
func (a *Client) UpdateApplicationServers(params *UpdateApplicationServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateApplicationServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateApplicationServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateApplicationServers",
		Method:             "PUT",
		PathPattern:        "/public/protectionSources/applicationServers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateApplicationServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateApplicationServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateApplicationServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateProtectionSource updates a previously registered protection source with new details

**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>
*/
func (a *Client) UpdateProtectionSource(params *UpdateProtectionSourceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProtectionSourceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateProtectionSourceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateProtectionSource",
		Method:             "PATCH",
		PathPattern:        "/public/protectionSources/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateProtectionSourceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateProtectionSourceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateProtectionSourceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpgradePhysicalAgents initiates a request to upgrade cohesity agents on one or more physical servers registered on the cohesity cluster

	**Privileges:** ```PROTECTION_SOURCE_MODIFY``` <br><br>If the request is successful, the Cohesity agents on the specified

Physical Servers are upgraded to the agent release
currently available from this Cohesity Cluster.
For example if the Cluster is upgraded from 3.7.1 to 4.0,
the agents on the specified Physical Servers can be upgraded to 4.0 using
this POST operation.
To get the agentIds to pass into this operation, call
GET /public/protectionSources with the environment set to 'KPhysical'.
In addition this GET operation returns the agentUpgradability field, that
indicates if an agent can be upgraded. Use the agentUpgradability field
to determine which Physical Servers to upgrade using this
POST /public/physicalAgents/upgrade operation.

WARNING: Only agents at a particular Cohesity release can be
upgraded using this operation.
See the Cohesity online help for details.

Returns the status of the upgrade initiation.
*/
func (a *Client) UpgradePhysicalAgents(params *UpgradePhysicalAgentsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradePhysicalAgentsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradePhysicalAgentsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradePhysicalAgents",
		Method:             "POST",
		PathPattern:        "/public/physicalAgents/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradePhysicalAgentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradePhysicalAgentsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradePhysicalAgentsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
