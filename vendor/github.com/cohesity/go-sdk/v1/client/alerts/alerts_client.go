// Code generated by go-swagger; DO NOT EDIT.

package alerts

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new alerts API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new alerts API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new alerts API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for alerts API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateNotificationRule(params *CreateNotificationRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateNotificationRuleCreated, error)

	CreateResolution(params *CreateResolutionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateResolutionCreated, error)

	DeleteNotificationRule(params *DeleteNotificationRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteNotificationRuleNoContent, error)

	GetAlertByID(params *GetAlertByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertByIDOK, error)

	GetAlertCategories(params *GetAlertCategoriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertCategoriesOK, error)

	GetAlertTypes(params *GetAlertTypesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertTypesOK, error)

	GetAlerts(params *GetAlertsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertsOK, error)

	GetNotificationRules(params *GetNotificationRulesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNotificationRulesOK, error)

	GetResolutionByID(params *GetResolutionByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetResolutionByIDOK, error)

	GetResolutions(params *GetResolutionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetResolutionsOK, error)

	UpdateNotificationRule(params *UpdateNotificationRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNotificationRuleOK, error)

	UpdateResolution(params *UpdateResolutionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateResolutionOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	CreateNotificationRule creates a new alert notification rule

	**Privileges:** ```ALERT_MODIFY``` <br><br>Creates a new notification rule with provided delivery targets such as email

addresses and external apis.
*/
func (a *Client) CreateNotificationRule(params *CreateNotificationRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateNotificationRuleCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateNotificationRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateNotificationRule",
		Method:             "POST",
		PathPattern:        "/public/alertNotificationRules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateNotificationRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateNotificationRuleCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateNotificationRuleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CreateResolution creates an alert resolution

	**Privileges:** ```ALERT_MODIFY``` <br><br>Create an Alert Resolution and apply it to one or more Alerts.

Mark the Alerts as resolved.
*/
func (a *Client) CreateResolution(params *CreateResolutionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateResolutionCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateResolutionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateResolution",
		Method:             "POST",
		PathPattern:        "/public/alertResolutions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateResolutionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateResolutionCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateResolutionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteNotificationRule deletes an alert notification rule

**Privileges:** ```ALERT_MODIFY``` <br><br>Deletes an existing alert notification rule matching the rule id.
*/
func (a *Client) DeleteNotificationRule(params *DeleteNotificationRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteNotificationRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteNotificationRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteNotificationRule",
		Method:             "DELETE",
		PathPattern:        "/public/alertNotificationRules/{ruleId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteNotificationRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteNotificationRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteNotificationRuleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAlertByID lists details about a single alert

**Privileges:** ```ALERT_VIEW``` <br><br>Returns the Alert object corresponding to the specified id.
*/
func (a *Client) GetAlertByID(params *GetAlertByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAlertById",
		Method:             "GET",
		PathPattern:        "/public/alerts/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAlertByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAlertByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAlertByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAlertCategories gets alert categories in the cohesity cluster

**Privileges:** ```ALERT_VIEW``` <br><br>Returns alert categories in Cohesity cluster.
*/
func (a *Client) GetAlertCategories(params *GetAlertCategoriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertCategoriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertCategoriesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAlertCategories",
		Method:             "GET",
		PathPattern:        "/public/alertCategories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAlertCategoriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAlertCategoriesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAlertCategoriesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetAlertTypes gets registered alerts in the cohesity cluster

	**Privileges:** ```ALERT_VIEW``` <br><br>Returns registered alerts in the Cohesity cluster that match the filter

criteria specified using parameters. If no filter parameters are specified,
all registered alerts in the Cohesity cluster are returned.
*/
func (a *Client) GetAlertTypes(params *GetAlertTypesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertTypesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAlertTypes",
		Method:             "GET",
		PathPattern:        "/public/alertTypes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAlertTypesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAlertTypesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAlertTypesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetAlerts lists the alerts on the cohesity cluster

	**Privileges:** ```ALERT_VIEW``` <br><br>Returns all Alert objects found on the Cohesity Cluster that

match the filter criteria specified using parameters.
The Cohesity Cluster creates an Alert when a potential problem
is found or when a threshold has been exceeded on the Cohesity Cluster.
If no filter parameters are specified, all Alert objects are returned.
Each object provides details about the Alert such as the Status and Severity.
*/
func (a *Client) GetAlerts(params *GetAlertsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAlerts",
		Method:             "GET",
		PathPattern:        "/public/alerts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAlertsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAlertsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAlertsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetNotificationRules gets all alert notification rules

	**Privileges:** ```ALERT_VIEW``` <br><br>Gets all alert notification rules containing criteria to deliver notification

to delivery targets such as email addresses, invoking external apis etc.
*/
func (a *Client) GetNotificationRules(params *GetNotificationRulesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNotificationRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNotificationRulesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNotificationRules",
		Method:             "GET",
		PathPattern:        "/public/alertNotificationRules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNotificationRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNotificationRulesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNotificationRulesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetResolutionByID lists details about a single alert resolution

	**Privileges:** ```ALERT_VIEW``` <br><br>Returns the Alert Resolution object corresponding to passed in Alert

Resolution Id.
*/
func (a *Client) GetResolutionByID(params *GetResolutionByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetResolutionByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResolutionByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetResolutionById",
		Method:             "GET",
		PathPattern:        "/public/alertResolutions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetResolutionByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetResolutionByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetResolutionByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetResolutions lists the alert resolutions on the cohesity cluster

	**Privileges:** ```ALERT_VIEW``` <br><br>Returns all Alert Resolution objects found on the Cohesity Cluster

that match the filter criteria specified using parameters.
If no filter parameters are specified,
all Alert Resolution objects are returned.
Each object provides details about the Alert Resolution such as
the resolution summary and details.
*/
func (a *Client) GetResolutions(params *GetResolutionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetResolutionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResolutionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetResolutions",
		Method:             "GET",
		PathPattern:        "/public/alertResolutions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetResolutionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetResolutionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetResolutionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpdateNotificationRule updates an existing alert notification rule

	**Privileges:** ```ALERT_MODIFY``` <br><br>Updates delivery targets such as email addresses and external apis in an

existing notification rule.
*/
func (a *Client) UpdateNotificationRule(params *UpdateNotificationRuleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNotificationRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateNotificationRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateNotificationRule",
		Method:             "PUT",
		PathPattern:        "/public/alertNotificationRules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateNotificationRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateNotificationRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateNotificationRuleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpdateResolution applies an existing alert resolution to additional alerts

	**Privileges:** ```ALERT_MODIFY``` <br><br>Apply an existing Alert Resolution to one or more additional Alerts.

Mark those additional Alerts as resolved.
*/
func (a *Client) UpdateResolution(params *UpdateResolutionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateResolutionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateResolutionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateResolution",
		Method:             "PUT",
		PathPattern:        "/public/alertResolutions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateResolutionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateResolutionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateResolutionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
