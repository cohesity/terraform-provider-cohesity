// Code generated by go-swagger; DO NOT EDIT.

package clusters

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new clusters API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new clusters API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new clusters API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for clusters API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ChangeServiceState(params *ChangeServiceStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangeServiceStateAccepted, error)

	ClusterListMasters(params *ClusterListMastersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterListMastersOK, error)

	CreateCloudCluster(params *CreateCloudClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCloudClusterAccepted, error)

	CreatePhysicalCluster(params *CreatePhysicalClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreatePhysicalClusterAccepted, error)

	CreateVirtualCluster(params *CreateVirtualClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVirtualClusterAccepted, error)

	DownloadSnmpMibs(params *DownloadSnmpMibsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DownloadSnmpMibsOK, error)

	ExpandCloudCluster(params *ExpandCloudClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExpandCloudClusterAccepted, error)

	ExpandPhysicalCluster(params *ExpandPhysicalClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExpandPhysicalClusterAccepted, error)

	GetBackgroundActivitySchedule(params *GetBackgroundActivityScheduleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBackgroundActivityScheduleOK, error)

	GetClientSubnetWhitelist(params *GetClientSubnetWhitelistParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientSubnetWhitelistOK, error)

	GetClusterCreationProgress(params *GetClusterCreationProgressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterCreationProgressOK, error)

	GetClusterKeys(params *GetClusterKeysParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterKeysOK, error)

	GetClusterPlatforms(params *GetClusterPlatformsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPlatformsOK, error)

	GetClusterPublicKey(params *GetClusterPublicKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPublicKeyOK, error)

	GetClusterStats(params *GetClusterStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStatsOK, error)

	GetClusterSubnets(params *GetClusterSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSubnetsOK, error)

	GetClusterUpgradeStatus(params *GetClusterUpgradeStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterUpgradeStatusOK, error)

	GetExternalClientSubnets(params *GetExternalClientSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetExternalClientSubnetsOK, error)

	GetIoPreferentialTier(params *GetIoPreferentialTierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIoPreferentialTierOK, error)

	GetIoPreferentialTierMixin0(params *GetIoPreferentialTierMixin0Params, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIoPreferentialTierMixin0OK, error)

	GetNFSExportPaths(params *GetNFSExportPathsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNFSExportPathsOK, error)

	GetNtpServers(params *GetNtpServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNtpServersOK, error)

	GetProxyServers(params *GetProxyServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxyServersOK, error)

	GetServiceGflag(params *GetServiceGflagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetServiceGflagOK, error)

	ListServiceStates(params *ListServiceStatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListServiceStatesOK, error)

	PutIoPreferentialTier(params *PutIoPreferentialTierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PutIoPreferentialTierOK, error)

	RemoveNode(params *RemoveNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveNodeNoContent, error)

	RemoveProxyServer(params *RemoveProxyServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveProxyServerNoContent, error)

	UpdateBackgroundActivitySchedule(params *UpdateBackgroundActivityScheduleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateBackgroundActivityScheduleOK, error)

	UpdateClientSubnetWhitelist(params *UpdateClientSubnetWhitelistParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClientSubnetWhitelistOK, error)

	UpdateClusterSubnets(params *UpdateClusterSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSubnetsOK, error)

	UpdateExternalClientSubnets(params *UpdateExternalClientSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateExternalClientSubnetsOK, error)

	UpdateIoPreferentialTier(params *UpdateIoPreferentialTierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIoPreferentialTierOK, error)

	UpdateNtpServers(params *UpdateNtpServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNtpServersOK, error)

	UpdateProxyServer(params *UpdateProxyServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProxyServerOK, error)

	UpdateServiceFlag(params *UpdateServiceFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateServiceFlagOK, error)

	UpdateServiceGflag(params *UpdateServiceGflagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateServiceGflagOK, error)

	UpgradeCluster(params *UpgradeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeClusterAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	ChangeServiceState changes the state of one or more services on a cohesity cluster

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to either stop, start, or restart one or more of the services

on a Cohesity Cluster and returns a message describing the result.

WARNING: This is a destructive operation.
*/
func (a *Client) ChangeServiceState(params *ChangeServiceStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ChangeServiceStateAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewChangeServiceStateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ChangeServiceState",
		Method:             "POST",
		PathPattern:        "/public/clusters/services/states",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ChangeServiceStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ChangeServiceStateAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ChangeServiceStateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ClusterListMasters tos fetch list of master nodes for all components

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the list of master nodes for all components.
*/
func (a *Client) ClusterListMasters(params *ClusterListMastersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClusterListMastersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterListMastersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ClusterListMasters",
		Method:             "GET",
		PathPattern:        "/gandalf/listMasters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClusterListMastersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterListMastersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClusterListMastersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CreateCloudCluster creates a new cloud edition cohesity cluster

	**Privileges:** ```CLUSTER_CREATE``` <br><br>Sends a request to create a new Cloud Edition Cohesity Cluster and returns

the IDs, name, and software version of the new cluster. Also returns the
status of each node.
*/
func (a *Client) CreateCloudCluster(params *CreateCloudClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateCloudClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCloudClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateCloudCluster",
		Method:             "POST",
		PathPattern:        "/public/clusters/cloudEdition",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateCloudClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateCloudClusterAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateCloudClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CreatePhysicalCluster creates a new physical edition cohesity cluster

	**Privileges:** ```CLUSTER_CREATE``` <br><br>Sends a request to create a new Physical Edition Cohesity Cluster and returns

the IDs, name, and software version of the new cluster. Also returns the
status of each node.
*/
func (a *Client) CreatePhysicalCluster(params *CreatePhysicalClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreatePhysicalClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePhysicalClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreatePhysicalCluster",
		Method:             "POST",
		PathPattern:        "/public/clusters/physicalEdition",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreatePhysicalClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreatePhysicalClusterAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreatePhysicalClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	CreateVirtualCluster creates a new virtual edition cohesity cluster

	**Privileges:** ```CLUSTER_CREATE``` <br><br>Sends a request to create a new Virtual Edition Cohesity Cluster and returns

the IDs, name and software version of the new cluster.
*/
func (a *Client) CreateVirtualCluster(params *CreateVirtualClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateVirtualClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateVirtualClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateVirtualCluster",
		Method:             "POST",
		PathPattern:        "/public/clusters/virtualEdition",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateVirtualClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateVirtualClusterAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateVirtualClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DownloadSnmpMibs downloads the s n m p mibs file from the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the SNMP Mibs file from the cluster.
*/
func (a *Client) DownloadSnmpMibs(params *DownloadSnmpMibsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DownloadSnmpMibsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadSnmpMibsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DownloadSnmpMibs",
		Method:             "GET",
		PathPattern:        "/snmp/mibsFile",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadSnmpMibsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadSnmpMibsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DownloadSnmpMibsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExpandCloudCluster expands a cloud edition cohesity cluster

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to expand a Cloud Edition Cohesity Cluster and returns some

information about the request and each new Node.
*/
func (a *Client) ExpandCloudCluster(params *ExpandCloudClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExpandCloudClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExpandCloudClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ExpandCloudCluster",
		Method:             "POST",
		PathPattern:        "/public/clusters/cloudEdition/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExpandCloudClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExpandCloudClusterAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExpandCloudClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	ExpandPhysicalCluster expands a physical edition cohesity cluster

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to expand a Physical Edition Cohesity Cluster and returns some

information about the request and each new Node.
*/
func (a *Client) ExpandPhysicalCluster(params *ExpandPhysicalClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExpandPhysicalClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExpandPhysicalClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ExpandPhysicalCluster",
		Method:             "POST",
		PathPattern:        "/public/clusters/physicalEdition/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExpandPhysicalClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExpandPhysicalClusterAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExpandPhysicalClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetBackgroundActivitySchedule gets the apollo throttling schedule

**Privileges:** ```CLUSTER_VIEW``` <br><br>Sends a request to get the apollo throttling settings applied for the cluster.
*/
func (a *Client) GetBackgroundActivitySchedule(params *GetBackgroundActivityScheduleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBackgroundActivityScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBackgroundActivityScheduleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetBackgroundActivitySchedule",
		Method:             "GET",
		PathPattern:        "/public/cluster/backgroundActivitySchedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBackgroundActivityScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetBackgroundActivityScheduleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetBackgroundActivityScheduleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClientSubnetWhitelist lists the client subnet whitelist for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the Client Subnet Whitelist for the cluster.
*/
func (a *Client) GetClientSubnetWhitelist(params *GetClientSubnetWhitelistParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClientSubnetWhitelistOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientSubnetWhitelistParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClientSubnetWhitelist",
		Method:             "GET",
		PathPattern:        "/clientSubnetWhitelist",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClientSubnetWhitelistReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClientSubnetWhitelistOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClientSubnetWhitelistDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	GetClusterCreationProgress checks the progress of the creation of a new cohesity cluster

	**Privileges:** ```CLUSTER_CREATE, CLUSTER_VIEW``` <br><br>Sends a request to check the progress of the creation of a new Cohesity

Cluster and returns some information about the creation process along
with an estimated time remaining and completion percentage.
*/
func (a *Client) GetClusterCreationProgress(params *GetClusterCreationProgressParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterCreationProgressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterCreationProgressParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterCreationProgress",
		Method:             "GET",
		PathPattern:        "/public/clusters/creationProgress",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterCreationProgressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterCreationProgressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterCreationProgressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterKeys lists the public keys for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the Public Keys for the cluster.
*/
func (a *Client) GetClusterKeys(params *GetClusterKeysParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterKeysOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterKeysParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterKeys",
		Method:             "GET",
		PathPattern:        "/public/cluster/keys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterKeysReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterKeysOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterKeysDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterPlatforms lists the cluster platform types for all nodes

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the PlatformParam object for the cluster.
*/
func (a *Client) GetClusterPlatforms(params *GetClusterPlatformsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPlatformsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterPlatformsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterPlatforms",
		Method:             "GET",
		PathPattern:        "/clusterPlatforms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterPlatformsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterPlatformsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterPlatformsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterPublicKey lists the public key for the cluster

**Privileges:** ```CLUSTER_VIEW, TENANT_VIEW``` <br><br>Returns the Public Key for the cluster.
*/
func (a *Client) GetClusterPublicKey(params *GetClusterPublicKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPublicKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterPublicKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterPublicKey",
		Method:             "GET",
		PathPattern:        "/clusterPublicKey",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterPublicKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterPublicKeyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterPublicKeyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterStats lists the cluster stats

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the top level stats for the cluster.
*/
func (a *Client) GetClusterStats(params *GetClusterStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStatsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterStats",
		Method:             "GET",
		PathPattern:        "/clusterStats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterStatsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterStatsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterSubnets lists the cluster subnet

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the subnet object for the cluster.
*/
func (a *Client) GetClusterSubnets(params *GetClusterSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterSubnetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterSubnetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterSubnets",
		Method:             "GET",
		PathPattern:        "/clusterSubnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterSubnetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterSubnetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterSubnetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterUpgradeStatus lists the cluster upgrade status

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the upgrade status for the cluster.
*/
func (a *Client) GetClusterUpgradeStatus(params *GetClusterUpgradeStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterUpgradeStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterUpgradeStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterUpgradeStatus",
		Method:             "GET",
		PathPattern:        "/clusterUpgradeStatus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterUpgradeStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterUpgradeStatusOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterUpgradeStatusDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetExternalClientSubnets lists the external client subnets for the cluster

**Privileges:** ```STORAGE_VIEW``` <br><br>Returns the external Client Subnets for the cluster.
*/
func (a *Client) GetExternalClientSubnets(params *GetExternalClientSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetExternalClientSubnetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetExternalClientSubnetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetExternalClientSubnets",
		Method:             "GET",
		PathPattern:        "/public/externalClientSubnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetExternalClientSubnetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetExternalClientSubnetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetExternalClientSubnetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIoPreferentialTier lists the i o preferential tier for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the IO Preferential Tier for the cluster.
*/
func (a *Client) GetIoPreferentialTier(params *GetIoPreferentialTierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIoPreferentialTierOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIoPreferentialTierParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIoPreferentialTier",
		Method:             "GET",
		PathPattern:        "/ioPreferentialTier",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIoPreferentialTierReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIoPreferentialTierOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIoPreferentialTierDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIoPreferentialTierMixin0 returns the i o preferential tiers of the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Get the IO preferential tiers of the cluster.
*/
func (a *Client) GetIoPreferentialTierMixin0(params *GetIoPreferentialTierMixin0Params, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIoPreferentialTierMixin0OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIoPreferentialTierMixin0Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIoPreferentialTierMixin0",
		Method:             "GET",
		PathPattern:        "/public/clusters/ioPreferentialTier",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIoPreferentialTierMixin0Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIoPreferentialTierMixin0OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIoPreferentialTierMixin0Default)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNFSExportPaths lists the n f s export path list for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the NFS Export Path List for the cluster.
*/
func (a *Client) GetNFSExportPaths(params *GetNFSExportPathsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNFSExportPathsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNFSExportPathsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNFSExportPaths",
		Method:             "GET",
		PathPattern:        "/nfsExportPaths",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNFSExportPathsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNFSExportPathsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNFSExportPathsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNtpServers lists the n t p servers for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the NTP Servers for the cluster.
*/
func (a *Client) GetNtpServers(params *GetNtpServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNtpServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNtpServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNtpServers",
		Method:             "GET",
		PathPattern:        "/ntpServers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNtpServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNtpServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNtpServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetProxyServers lists the proxy servers for the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Returns the Proxy Servers for the cluster.
*/
func (a *Client) GetProxyServers(params *GetProxyServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProxyServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProxyServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetProxyServers",
		Method:             "GET",
		PathPattern:        "/proxyServers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetProxyServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetProxyServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetProxyServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetServiceGflag gets the gflags of a cohesity cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Sends a request to get the gflags of the current Cluster.
*/
func (a *Client) GetServiceGflag(params *GetServiceGflagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetServiceGflagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServiceGflagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetServiceGflag",
		Method:             "GET",
		PathPattern:        "/clusters/gflag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetServiceGflagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetServiceGflagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetServiceGflagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListServiceStates lists the states of the services on the cluster

**Privileges:** ```CLUSTER_VIEW``` <br><br>Sends a request to list the states of all of the services on a Cluster.
*/
func (a *Client) ListServiceStates(params *ListServiceStatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListServiceStatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListServiceStatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListServiceStates",
		Method:             "GET",
		PathPattern:        "/public/clusters/services/states",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListServiceStatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListServiceStatesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListServiceStatesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutIoPreferentialTier updates the i o preferential tiers and return the updated i o preferential tiers of the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Update the IO preferential tiers of the cluster.
*/
func (a *Client) PutIoPreferentialTier(params *PutIoPreferentialTierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PutIoPreferentialTierOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutIoPreferentialTierParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PutIoPreferentialTier",
		Method:             "PUT",
		PathPattern:        "/public/clusters/ioPreferentialTier",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutIoPreferentialTierReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutIoPreferentialTierOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutIoPreferentialTierDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	RemoveNode removes a node from a cohesity cluster

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to remove a Node from a Cohesity Cluster.

WARNING: This is a destructive operation.
*/
func (a *Client) RemoveNode(params *RemoveNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveNodeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoveNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RemoveNode",
		Method:             "DELETE",
		PathPattern:        "/public/clusters/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RemoveNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoveNodeNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RemoveNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RemoveProxyServer removes specified proxy server from the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns delete status upon completion.
*/
func (a *Client) RemoveProxyServer(params *RemoveProxyServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveProxyServerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoveProxyServerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RemoveProxyServer",
		Method:             "DELETE",
		PathPattern:        "/proxyServers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RemoveProxyServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoveProxyServerNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RemoveProxyServerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpdateBackgroundActivitySchedule updates the apollo throttling schedule

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to update the apollo throttling settings for the cluster.

Returns the updated apollo throttling settings of the cluster.
*/
func (a *Client) UpdateBackgroundActivitySchedule(params *UpdateBackgroundActivityScheduleParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateBackgroundActivityScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateBackgroundActivityScheduleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateBackgroundActivitySchedule",
		Method:             "PUT",
		PathPattern:        "/public/cluster/backgroundActivitySchedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateBackgroundActivityScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateBackgroundActivityScheduleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateBackgroundActivityScheduleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClientSubnetWhitelist updates the client subnet whitelist of the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the updated Client Subnet Whitelist of the cluster.
*/
func (a *Client) UpdateClientSubnetWhitelist(params *UpdateClientSubnetWhitelistParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClientSubnetWhitelistOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClientSubnetWhitelistParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClientSubnetWhitelist",
		Method:             "PUT",
		PathPattern:        "/clientSubnetWhitelist",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClientSubnetWhitelistReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClientSubnetWhitelistOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClientSubnetWhitelistDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterSubnets updates the cluster subnets

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the updated Cluster Subnets.
*/
func (a *Client) UpdateClusterSubnets(params *UpdateClusterSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterSubnetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterSubnetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterSubnets",
		Method:             "PUT",
		PathPattern:        "/clusterSubnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterSubnetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterSubnetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterSubnetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateExternalClientSubnets updates the external client subnet of the cluster

**Privileges:** ```STORAGE_MODIFY``` <br><br>Returns the updated external Client Subnets of the cluster.
*/
func (a *Client) UpdateExternalClientSubnets(params *UpdateExternalClientSubnetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateExternalClientSubnetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateExternalClientSubnetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateExternalClientSubnets",
		Method:             "PUT",
		PathPattern:        "/public/externalClientSubnets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateExternalClientSubnetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateExternalClientSubnetsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateExternalClientSubnetsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIoPreferentialTier updates the i o preferential tier of the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the updated IO Preferential Tier of the cluster.
*/
func (a *Client) UpdateIoPreferentialTier(params *UpdateIoPreferentialTierParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIoPreferentialTierOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIoPreferentialTierParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIoPreferentialTier",
		Method:             "PUT",
		PathPattern:        "/ioPreferentialTier",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIoPreferentialTierReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIoPreferentialTierOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIoPreferentialTierDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateNtpServers updates the n t p servers of the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the updated NTP Servers of the cluster.
*/
func (a *Client) UpdateNtpServers(params *UpdateNtpServersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNtpServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateNtpServersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateNtpServers",
		Method:             "PUT",
		PathPattern:        "/ntpServers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateNtpServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateNtpServersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateNtpServersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateProxyServer updates the proxy servers of the cluster

```Unknown Privileges``` <br><br>Returns the updated Proxy Server on the cluster.
*/
func (a *Client) UpdateProxyServer(params *UpdateProxyServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProxyServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateProxyServerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateProxyServer",
		Method:             "POST",
		PathPattern:        "/proxyServers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateProxyServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateProxyServerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateProxyServerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateServiceFlag updates the service flag on all the nodes of the cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Returns the service flag update response of all the nodes on the cluster.
*/
func (a *Client) UpdateServiceFlag(params *UpdateServiceFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateServiceFlagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateServiceFlagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateServiceFlag",
		Method:             "POST",
		PathPattern:        "/flagz",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateServiceFlagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateServiceFlagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateServiceFlagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateServiceGflag updates the gflags of a cohesity cluster

**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to update the gflags of the current Cluster.
*/
func (a *Client) UpdateServiceGflag(params *UpdateServiceGflagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateServiceGflagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateServiceGflagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateServiceGflag",
		Method:             "PUT",
		PathPattern:        "/clusters/gflag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateServiceGflagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateServiceGflagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateServiceGflagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
	UpgradeCluster upgrades a cohesity cluster

	**Privileges:** ```CLUSTER_MODIFY``` <br><br>Sends a request to upgrade the software version of a Cohesity Cluster

and returns a message specifying the result. Before using this, you need to
use the /public/packages endpoint to upload a new package to the Cluster.
*/
func (a *Client) UpgradeCluster(params *UpgradeClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeClusterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCluster",
		Method:             "PUT",
		PathPattern:        "/public/clusters/software",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeClusterAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
